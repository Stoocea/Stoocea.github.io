{"title":"CodeQL学习","uid":"21952381f57493672835351001f3cf9b","slug":"CodeQL学习","date":"2024-05-02T08:00:00.000Z","updated":"2024-06-28T15:08:52.369Z","comments":true,"path":"api/articles/CodeQL学习.json","keywords":null,"cover":"https://bu.dusays.com/2024/06/28/667ecf00d23c4.webp","content":"<p>本文为个人学习笔记+一些个人的理解调试，仅供学习参考</p>\n<p>首先存几个学习地点<br><a href=\"https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/\">https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/</a><br><a href=\"https://www.freebuf.com/articles/web/283795.html\">https://www.freebuf.com/articles/web/283795.html</a><br><a href=\"https://codeql.github.com/docs/codeql-overview/about-codeql/\">https://codeql.github.com/docs/codeql-overview/about-codeql/</a></p>\n<h1 id=\"什么是-CodeQL\"><a href=\"#什么是-CodeQL\" class=\"headerlink\" title=\"什么是 CodeQL\"></a>什么是 CodeQL</h1><p>这里我本来想用一句话总结的，但是自己学的还不够，所以无法总结，深入学习之后再总结</p>\n<h1 id=\"CodeQL-配置\"><a href=\"#CodeQL-配置\" class=\"headerlink\" title=\"CodeQL 配置\"></a>CodeQL 配置</h1><p>首先要先下载 CodeQL 的 CIL，这个官网的 releases 上有，我们选择 win64 版本的安装包<br>然后下 SDK</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">git</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">clone</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">https://github.com/Semmle/ql</span></span></code></pre></div><p>下完之后的目录结构如下<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714028475927-93e54d1f-95a1-4acb-b766-e0cbd8764e51.png#averageHue=%23fbfbfb&clientId=uaa2b4734-80a9-4&from=paste&height=201&id=ub7157620&originHeight=376&originWidth=1474&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21552&status=done&style=none&taskId=ud0f0da22-d5b3-44e1-9ac7-6ca9b525191&title=&width=786.1333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\">然后配置环境变量，配置一个 codeql 的路径即可，这里的路径以我的为例就是</p>\n<div class=\"language-latex\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">latex</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">H:</span><span style=\"color: #89DDFF\">\\</span><span style=\"color: #82AAFF\">CodeQL</span><span style=\"color: #89DDFF\">\\</span><span style=\"color: #82AAFF\">codeql</span></span></code></pre></div><p>然后运行一下 codeql 命令，出现如下内容就没太大问题了<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714029257839-be740358-135a-4f8e-92e1-04c37dd89bb8.png#averageHue=%2345474e&clientId=uaa2b4734-80a9-4&from=paste&height=491&id=u7770b83e&originHeight=920&originWidth=1339&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=695160&status=done&style=none&taskId=u3cf96e93-64c0-440c-99fb-afed2c21753&title=&width=714.1333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n<h1 id=\"CodeQL-使用\"><a href=\"#CodeQL-使用\" class=\"headerlink\" title=\"CodeQL 使用\"></a>CodeQL 使用</h1><h2 id=\"0x01-测试-Helloworld\"><a href=\"#0x01-测试-Helloworld\" class=\"headerlink\" title=\"0x01 测试 Helloworld\"></a>0x01 测试 Helloworld</h2><p>Codeql 处理对象并不是项目源码本身，而是中间生成的 AST 结构数据库，所以每次分析之前，我们需要将项目源码转化成 Codeql 能够识别的 CodeDataBase<br>这里以我们从<a href=\"https://github.com/l4yn3/micro_service_seclab/\">micro_service_seclab</a>靶场获取的源码为例，稍微看一下目录结构，作者写的一个很标准的 Springboot 的项目<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714029189965-318d9304-26f5-47e1-b3ce-669bd4fdf6aa.png#averageHue=%233d4243&clientId=uaa2b4734-80a9-4&from=paste&height=434&id=u30a15417&originHeight=813&originWidth=897&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=226094&status=done&style=none&taskId=u07345504-1b0c-48af-8f9b-833048f5eae&title=&width=478.4\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>然后我们执行如下命令</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">codeql database create </span><span style=\"color: #89DDFF\">./</span><span style=\"color: #BABED8\">databases</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">micro_service_seclab_database  </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">language</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">java</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\">  </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">command</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">mvn clean install --file pom.xml</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">source</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">root</span><span style=\"color: #89DDFF\">=./</span><span style=\"color: #BABED8\">practice</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">micro_service_seclab</span><span style=\"color: #89DDFF\">/</span></span></code></pre></div><p>但是初次运行，有很大概率会报错<br>这个原因有很多，解决方法可参考这位师傅，找了很多关于 java 本身 maven 编译项目的问题，都无法解决<br><a href=\"https://blog.csdn.net/m0_63303407/article/details/128750198\">https://blog.csdn.net/m0_63303407&#x2F;article&#x2F;details&#x2F;128750198</a><br>然后是我的环境变量<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714100745081-2c749e89-728f-4974-86aa-8b1b7ae5388d.png#averageHue=%23f3f0ed&clientId=ud3265ec2-e53a-4&from=paste&height=34&id=uef6d0d98&originHeight=63&originWidth=600&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5682&status=done&style=none&taskId=u7759ff90-eabf-47f7-82ed-4d8801cc8c5&title=&width=320\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>我个人这么配置之后基本上没啥问题了<br>然后是 Vscode 中配置一下我们刚才生成的 database，配置完这个之后我们就能够写查询语句了<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714110696673-0070c5e1-3058-40d6-b884-1068f256db65.png#averageHue=%23221f2d&clientId=ud3e91435-e9be-4&from=paste&height=499&id=uc6371d9e&originHeight=1248&originWidth=841&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=242911&status=done&style=none&taskId=uad9cac80-4823-41f5-a89a-59bacc94fc7&title=&width=336.5333557128906\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>在当前这个目录下，新建一个 demo.ql 文件，用来写我们的查询语句，这里我们简单的 select 出来一个 helloworld 字符串<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714110750954-0698a9f5-6ec3-41a4-8e0f-fcd9d659a3ec.png#averageHue=%23272333&clientId=ud3e91435-e9be-4&from=paste&height=728&id=ufd4f9034&originHeight=1365&originWidth=2560&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=736744&status=done&style=none&taskId=u33a47813-f83d-49a8-9cdc-d223cd43021&title=&width=1365.3333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n<h2 id=\"0x02-CodeQL-基本语法\"><a href=\"#0x02-CodeQL-基本语法\" class=\"headerlink\" title=\"0x02 CodeQL 基本语法\"></a>0x02 CodeQL 基本语法</h2><p>我们最开始提到了在 CodeQL 中，代码被视作数据，而漏洞，错误或者其他报错都被建模为可以针对的从代码中提权的数据库查询。其实就拿刚才的项目来说，我们先将项目中的内容转化为 Codeql 能够识别出来的数据库，这个过程其实就是 codeql 引擎将我们的项目内容（java 代码）转化为了我们 codeql 可识别的 AST 数据库，然后按照 Codql 中的编写的规则去查询数据库中的数据。这个思想其实在我看来就是将面向对象的数据库查询<br>稍微理解了一下 Codeql 整体的流程，看个例子</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">import</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">java</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">from int i</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">where i=1</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">select i</span></span></code></pre></div><p><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714111820691-a739d39c-59f9-4bfa-83b8-4dfb0dfb686f.png#averageHue=%232d2939&clientId=ud3e91435-e9be-4&from=paste&height=247&id=u5d04bff4&originHeight=464&originWidth=2183&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=225030&status=done&style=none&taskId=u2965f6a6-7b09-4088-bc6a-e0735bbbf5d&title=&width=1164.2666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n<ul>\n<li><code>import java</code> 由于我们审计的是 java 项目，所以要导入 java 的类库</li>\n<li><code>from int i</code> 这句代码表示我们从 int 这个整数组中取一个变量作为 i，其实这一步更像是给 i 这个属性定类型，int i </li>\n<li><code>where i= 1</code> 就是当我们的 i 为 1 时，就执行下面的逻辑</li>\n<li><code>select 1</code> 也就是在上一句的 where 条件达成之后，我们执行一段 select 语句</li>\n</ul>\n<p>其实大部分的 codeql 代码都可以浓缩为这一段</p>\n<h2 id=\"0x03-类库\"><a href=\"#0x03-类库\" class=\"headerlink\" title=\"0x03 类库\"></a>0x03 类库</h2><p>上面提到了 codeql 引擎把 java 代码转化为了 databases，这里其实有一个细节，就是复数 databases，我们知道 java 是一门典型的面向对象的语言，类是必不可少的，而这里的每一个 dababase，就对应一个类。这也是为什么每一个 java 项目转化之后被称为了 databases 了—-类数据集。而类库的具体实现，就是一个一个 AST 结构表示出来的，这里我们演示一段查看某一 database 的 AST 结构<br>首先将我们的源码添加到工作区，我们待会能够直接从 vscode 中指定到源码<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714188363446-9dff9b5b-53db-409c-a420-f74dc52bb7b6.png#averageHue=%23211e2c&clientId=u591b4bf5-34dd-4&from=paste&height=426&id=u9b528ae4&originHeight=798&originWidth=675&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=109815&status=done&style=none&taskId=u56e123bb-9ea5-420c-b21a-6b590cb3f93&title=&width=360\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>添加成功之后你就能够看到在 CodeQL 这个大文件夹外面会多一层源码目录，这个时候我们选定 IndexController.java 文件<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714188468096-45e70570-6b72-45a3-813b-8ccd5efeeab9.png#averageHue=%23282435&clientId=u591b4bf5-34dd-4&from=paste&height=676&id=u454e3adf&originHeight=1267&originWidth=2423&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=895204&status=done&style=none&taskId=u380528e5-6c73-4572-bf22-261fdef61c2&title=&width=1292.2666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>再去 codeql 中点击 view AST，就能够看到当前 IndexController.java 类的 AST 结构了<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714188529071-ae86f1a8-558e-4ac2-a2ed-b5457d2ccfa2.png#averageHue=%23292536&clientId=u591b4bf5-34dd-4&from=paste&height=641&id=ue05c82a2&originHeight=1202&originWidth=2393&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=921086&status=done&style=none&taskId=ubcaf0fbe-7863-492e-a71b-311638ff43e&title=&width=1276.2666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>当然除了我们本来的这些 java 代码的类库，我们还有 codeql 中帮助我们集成的一些类库，比如 Method，MethodAccess，Parameter 等。这里列出来的三个都是很常见的三个类库，具体作用如下：</p>\n<ol>\n<li>Method，方法类库，用来存储当前项目的中的所有方法</li>\n<li>MethodAccess，调用方法类库，用来存储当前项目中的所有方法调用</li>\n<li>Parameter，参数类库，用来存储当前项目中所有的参数</li>\n</ol>\n<p>当然，这三个类库都是有对应类的，名字是一样的。既然是类，那么一定有类方法和类属性，我们这里稍微看一下 Method 类的方法使用</p>\n<div class=\"language-plsql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">plsql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">import </span><span style=\"color: #89DDFF\">java</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">from</span><span style=\"color: #BABED8\"> Method method</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">where</span><span style=\"color: #BABED8\"> method.hasName(</span><span style=\"color: #C3E88D\">&quot;getStudent&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">select</span><span style=\"color: #BABED8\"> method.getName(),method.getDeclaringType()</span></span></code></pre></div><p>下面是结果<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714270196970-8878fd0c-aa14-45e7-8d15-6c71ee2e5062.png#averageHue=%23322d3e&clientId=ue4758036-374d-4&from=paste&height=130&id=u91d3760b&originHeight=244&originWidth=897&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50181&status=done&style=none&taskId=ucaa4a13e-aaa9-4791-bd87-2d1e968ddd2&title=&width=478.4\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>method.getName 就是获取到我们搜索到的方法名，method.getDeclaringType 就是获取到定义当前方法的类</p>\n<h2 id=\"0x04-谓词使用\"><a href=\"#0x04-谓词使用\" class=\"headerlink\" title=\"0x04 谓词使用\"></a>0x04 谓词使用</h2><p>谓词的出现，是为了解决 where 条件过长，影响逻辑分析的情况。其实谓词也可以叫做函数，只不过在 codeql 中都是叫谓词，看如下谓词</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">import java</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">predicate</span><span style=\"color: #BABED8\"> isgetStudent(Method method) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #F78C6C\">exists</span><span style=\"color: #BABED8\">(|method.hasName(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">getStudent</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">from</span><span style=\"color: #BABED8\"> Method method</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">where</span><span style=\"color: #BABED8\"> isgetStudent(method)</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">select</span><span style=\"color: #BABED8\"> method.getName</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\">,method.getDeclaringType</span><span style=\"color: #89DDFF\">()</span></span></code></pre></div><p>格式和函数是差不多的</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>predicate 表示当前方法没有返回值<br>exists 叫做子查询，他可以根据参数中的子查询来返回 true 或者 false，这里要注意一下格式，子查询前面有一个 |,这个格式其实用意在于，| 前半段的数据作为参数，| 后半段的代码作为执行的判断逻辑代码，前面的参数是可以传递给后半段的代码执行中的</p></blockquote>\n<h2 id=\"0x05-Node，Expr，Param\"><a href=\"#0x05-Node，Expr，Param\" class=\"headerlink\" title=\"0x05 Node，Expr，Param\"></a>0x05 Node，Expr，Param</h2><p>这一块算是自己单独分出来的一部分笔记，因为我学到后面之后有些参数的意思不能够瞬间反应出来，觉得有些基础概念还是没过<br>Expr 和 Param 分别叫做表达式和参数，他们两者都是 Node 的类型，并且 Node 就这两种类型，我们能够分别通过 asExpr()和 asParam()方法将他们取出来<br>Expr：</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #C792EA\">public</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">List</span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #BABED8\">Student</span><span style=\"color: #89DDFF\">&gt;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">getStudent</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">String</span><span style=\"color: #BABED8\"> username</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">        </span><span style=\"color: #676E95; font-style: italic\">//String sql = &quot;select * from students where username like &#39;%&quot; + username.get() + &quot;%&#39;&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #C792EA\">String</span><span style=\"color: #BABED8\"> sql </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">select * from students where username like &#39;%</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">+</span><span style=\"color: #BABED8\"> username </span><span style=\"color: #89DDFF\">+</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">%&#39;</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">        </span><span style=\"color: #676E95; font-style: italic\">//String sql = &quot;select * from students where username like ?&quot;;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #BABED8\"> jdbcTemplate</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">query</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">sql</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> ROW_MAPPER</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><h2 id=\"0x06-source-，sink，-sanitizer\"><a href=\"#0x06-source-，sink，-sanitizer\" class=\"headerlink\" title=\"0x06 source ，sink， sanitizer\"></a>0x06 source ，sink， sanitizer</h2><p>sink 应该很熟悉了，\t指最终执行点。source 指的是入口点，也就是漏洞污染链条输入点。sanitizer 叫做净化函数，在整个漏洞链条的执行过程中如果出现了一个点，能够阻断整条攻击链的逻辑执行，那么这个点就叫做sanitizer<br>总结一下，如果用 codeql 编写规则去找漏洞，我们要保证 source 和 sink 都存在，并且链中不存在 sanitizer 即可</p>\n<p>这里我们进行一个关于 Springboot 中的 SQL 注入的攻击链寻找，那么最终触发的方法（sink）一般是 query 或者 exeSql 了。当然还需要考虑入口点，也就是 source，Springboot 中一般就是各路由下的接收变量参数了</p>\n<h3 id=\"1x01-设置-source\"><a href=\"#1x01-设置-source\" class=\"headerlink\" title=\"1x01 设置 source\"></a>1x01 设置 source</h3><p>在 codeql 中我们可以用如下谓词来查询 source</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">override</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">predicate</span><span style=\"color: #BABED8\"> isSource(DataFlow::Node src)&#123;&#125;</span></span></code></pre></div><p>由于我们当前分析的是 SpringBoot 的项目，入口点应该是每一个具有接收数据流的参数，以及它对应的类<br>比如 IndexController 中大部分路由下都有的一个 RequestParam 参数<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714274559202-402479b8-717d-4b5c-9d4d-2b75dc840ad3.png#averageHue=%232d283a&clientId=ubd7eff1b-c86b-4&from=paste&height=443&id=ufab7df02&originHeight=830&originWidth=1140&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=435834&status=done&style=none&taskId=u17e4c21b-ac04-4caf-b833-576862ec06e&title=&width=608\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>这些都是我们需要去收集的 source<br>那收集这些参数的谓词该怎么写呢？我们可以拿 Codeql 中原生的规则来用</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">override</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">predicate</span><span style=\"color: #BABED8\"> isSource(DataFlow::Node src) &#123; </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">src instanceof RemoteFlowSource </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p>这是 SDK 中自带的规则，里面包含了大多数常用的 Source 入口<br>这段初看还是有点懵的，先看 RemoteFlowSource，它是一个类库，具体位置在 <code>semmle.code.java.dataflow.FlowSources</code>，本来的用意是存储可能的远程用户控制的数据流源，它里面内置了很多常见的 source 入口，包括我们本次要用到的 Springboot 中的常见传参<br>至于谓词里面的内容，我们之后再记，这里插个 flag</p>\n<h3 id=\"1x02-设置-sink\"><a href=\"#1x02-设置-sink\" class=\"headerlink\" title=\"1x02 设置 sink\"></a>1x02 设置 sink</h3><p>开头提到了我们本次案例查找 SQL 注入的最终触发方法是 query 方法或者 exeSql 方法，所以在 sink 的谓词中，我们会直接查找 query 或者 exeSql 方法，以及它的调用</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">override</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">predicate</span><span style=\"color: #BABED8\"> isSink(DataFlow::Node sink) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #F78C6C\">exists</span><span style=\"color: #BABED8\">(Method method, MethodAccess </span><span style=\"color: #F78C6C\">call</span><span style=\"color: #BABED8\"> |</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  method.hasName(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">query</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #F78C6C\">and</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  call.getMethod</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> method </span><span style=\"color: #F78C6C\">and</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  sink.asExpr</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> call.getArgument(</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p>这里的语法初见肯定会奇怪，我们拆开来分析<br>谓词结构:</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">override</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">predicate</span><span style=\"color: #BABED8\"> isSink(DataFlow::Node sink) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">......</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">&#125;</span></span></code></pre></div><p>里面的内容先不看，我们只看整体的结构，参数 DataFlow::Node 类型的 sink，这里举个例子来理解：java 种各式各样的攻击链，期间一定会有一段参数是一直在传递的，这个参数一般就是我们的最开始输入的 payload。我们再看 source 谓词的参数：<code>DataFlow::Node src</code>，也就是这个 DataFlow::Node 其实就是我们一开始输入的正常参数或者 payload<br>我们再看谓词里面的内容 ：</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">exists</span><span style=\"color: #BABED8\">(Method method, MethodAccess </span><span style=\"color: #F78C6C\">call</span><span style=\"color: #BABED8\"> |</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  method.hasName(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">query</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #F78C6C\">and</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  call.getMethod</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> method </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #F78C6C\">and</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  sink.asExpr</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> call.getArgument(</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #BABED8\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">)</span></span></code></pre></div><p>其实整体就是一个 exists 子查询，exists(object| …..)，这里接收到了 Method，以及调用参数 MethodAccess。后续的调用中我们会判断该方法名是否等于 “query”。然后判断调用当前方法的方法<br>其实这里我一直不太理解为什么要加<code>call.getMethod() = method</code>，甚至可以说我不太理解这整段关于 sink 的寻找，直到下面整体使用的时候才稍微清晰一点,这里就拿后面的理解提前分析一下这段关于 sink 的子查询了<br>首先是 <code>method.hashName(&quot;query&quot;)</code>，他其实就是先从所有调用流中将我们所有包含 query 方法的数据流给检索出来，当然这里检索出来可能并不会直接调用到 query 方法，可能是调用链的第 N 环<br>然后是<code>call.getMethod() = method</code>，结合上面我们检索出的数据流，我们查找调用方法中，当前正在调用 query 方法 Node 节点<br>最后 <code>sink.asExpr() = call.getArgument(0)</code>，就是判断 sink 点是否作为当前方法调用的第一个参数，结合上面两个流程，意思就是说我们的 sink 点要作为 query 方法的第一个参数</p>\n<h3 id=\"1x03-Flow-数据流\"><a href=\"#1x03-Flow-数据流\" class=\"headerlink\" title=\"1x03 Flow 数据流\"></a>1x03 Flow 数据流</h3><p>我们确定好开头 source 以及链尾 sink 之后，还需要保证整条攻击链是打通的，也就是说不能够出现跟进一半流程跟不下去的情况。那么该怎么去写 codeql 代码保证 Flow 数据流能够正常流通呢？这个确保联通的工作其实交由 codeql 引擎帮助我们完成，我们可以通过<code>Vulnconfig.hasFlowPath</code> 方法来判断是否联通<br>测试代码如下：</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">from </span><span style=\"color: #C792EA\">VulnConfig</span><span style=\"color: #BABED8\"> config</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\">DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">PathNode</span><span style=\"color: #BABED8\"> source</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\">DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">PathNode</span><span style=\"color: #BABED8\">\tsink</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">where config</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">hasFlowPath</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">source</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\">sink</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">select source</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getNode</span><span style=\"color: #89DDFF\">(),</span><span style=\"color: #BABED8\">source</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\">sink</span></span></code></pre></div><h3 id=\"1x04-整体查询\"><a href=\"#1x04-整体查询\" class=\"headerlink\" title=\"1x04 整体查询\"></a>1x04 整体查询</h3><p>Codeql 的语法其实和 java 的很像，写完之后才理解为什么说 codeql 是面向对象版的 sql 查询</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">import</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">java</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">dataflow</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">FlowSources</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">security</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">QueryInjection</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import DataFlow::PathGraph</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">class VulConfig extends TaintTracking::Configuration &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot; &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">   </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">   </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     override predicate isSink(DataFlow::Node sink) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">       exists(Method method, MethodAccess call |</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">        </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         method</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">hasName(&quot;query&quot;)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         and</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         call</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getMethod() = method</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         and</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         sink</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">asExpr() = call</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getArgument(0)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">       )</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">   &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">where config</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">hasFlowPath(source, sink)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">select source</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getNode(), source, sink, &quot;source&quot;</span></span></code></pre></div><p>其实 isSource 或者 isSink 如果直接按照我上面分析的一样去写是会报错的，因为加了一个限定词 Override,很明显它肯定是一个重写方法，那他最开始的定义在哪里呢？我们跟进TaintTracking 的定义<br>发现TaintTracking 很像一个接口形式的类，也就是大致的包含和定义还是规定了，但是具体的定义没有写<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714390728462-b9acbf7c-ac17-4246-83d8-9f4d1a08f34a.png#averageHue=%23242234&clientId=u6622cb15-b286-4&from=paste&height=377&id=u4018e3ba&originHeight=706&originWidth=1784&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=302659&status=done&style=none&taskId=ubc50db75-348d-4ed0-90fb-a7e9428e03e&title=&width=951.4666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>有一个TaintTrackingImpl，我们拿面向对象的思想去套，说不定它里面就有呢？跟进之后发现这是一个文件，后缀是 qll，这个没太了解，但是我么能够在这个文件中找到<code>Configuration extends DataFlow::Configuration</code>的定义，这也是我们为什么定义的 Class 要继承<code>TaintTracking::Configuration</code>，往后翻就能在Configuration 中找到 isSource 和 isSink 的定义<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714392663239-24311c96-0497-4cab-9d16-a9693826dc2b.png#averageHue=%23252235&clientId=u6622cb15-b286-4&from=paste&height=535&id=u86bfc050&originHeight=1003&originWidth=1011&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=290136&status=done&style=none&taskId=ubc7063d9-9a09-4fbb-a033-49a84c8ea80&title=&width=539.2\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>相信整体的代码也能够理解了，为什么要先写一个类继承自<code>TaintTracking::Configuration</code>，然后再写 isSink 和 isSource 方法，这跟面向对象的语法其实是很像的<br>再解析一下最后三行的代码：<br>实例化（？）一个我们重写的 VulnConfig，然后获取两个 DataFlow 的节点 Node，分别叫做 source 和 sink，只不过之后放入 config 中就会由 codeql 引擎去判断以及我们写的 issink 或者 issource 是否为 sink 和 source，然后判断数据流是否通了。</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">from </span><span style=\"color: #C792EA\">VulConfig</span><span style=\"color: #BABED8\"> config</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">PathNode</span><span style=\"color: #BABED8\"> source</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">PathNode</span><span style=\"color: #BABED8\"> sink</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">where config</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">hasFlowPath</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">source</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> sink</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">select source</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getNode</span><span style=\"color: #89DDFF\">(),</span><span style=\"color: #BABED8\"> source</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> sink</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">source</span><span style=\"color: #89DDFF\">&quot;</span></span></code></pre></div><p>结果如下<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714393791808-ad72c883-001f-4c79-aa4c-ffc06b9200af.png#averageHue=%23272433&clientId=u6622cb15-b286-4&from=paste&height=254&id=u2335cbec&originHeight=476&originWidth=1293&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=133496&status=done&style=none&taskId=uc4585cf9-a1c2-4b37-8486-0fc3d822e72&title=&width=689.6\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>这里可能还有一个疑问，isSource 和 isSink 是在哪里执行的？跟进hasFlowPath()就能够找到具体执行的点了<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714439540109-147209f9-9c52-4c95-b482-7160d226ea20.png#averageHue=%23272437&clientId=u34ffbe8d-3e30-4&from=paste&height=165&id=ud52ca25d&originHeight=310&originWidth=1087&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=78288&status=done&style=none&taskId=uae401d48-6ace-4102-be09-eafc32982d7&title=&width=579.7333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n<h1 id=\"结果优化\"><a href=\"#结果优化\" class=\"headerlink\" title=\"结果优化\"></a>结果优化</h1><h2 id=\"0x01-误报\"><a href=\"#0x01-误报\" class=\"headerlink\" title=\"0x01 误报\"></a>0x01 误报</h2><p>我们一个一个去检查结果，发现在第三个结果中出现了误报现象：<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714436651363-557f5145-af90-4478-b859-3a334d6478e9.png#averageHue=%23262436&clientId=u34ffbe8d-3e30-4&from=paste&height=108&id=u3604c111&originHeight=203&originWidth=1006&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=59302&status=done&style=none&taskId=u41349745-02bc-4c4a-8f4e-15db4b83a8f&title=&width=536.5333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>其实靶场的作者也帮我们标注出来了，发现 source 的传参类型是 List<long>的类型，也就是长整数类型，我们并不能够通过参数的传入打入 SQL 注入<br>其实大多数情况下，如果结果 ql 代码这么写的话，都是会出现这种情况的误报的，那如何去解决这个问题呢？<br>这里我们可以用到<code>TaintTracking::Configuration</code>中提供的方法—isSanitier，他是 Configuration 中提供的净化方法，我们能够从源码中找到它的原型定义<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714437065383-81eeec4e-8f68-4c0f-8c8b-cbb8d316806d.png#averageHue=%23232033&clientId=u34ffbe8d-3e30-4&from=paste&height=71&id=ud7dc979a&originHeight=133&originWidth=820&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27591&status=done&style=none&taskId=u9f454ae7-37d0-495d-9c17-23556af1cb7&title=&width=437.3333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714437125709-88f39ada-138d-4fca-a5cf-af03493e8bd8.png#averageHue=%23262335&clientId=u34ffbe8d-3e30-4&from=paste&height=124&id=u7a2f0a7c&originHeight=232&originWidth=1112&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47984&status=done&style=none&taskId=ueb369164-f69c-4d8b-92b4-842ec2ced1e&title=&width=593.0666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>isSanitier 方法它本身是会对基础类型以及一些奇怪类型进行判断的：</long></p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">override predicate </span><span style=\"color: #82AAFF\">isSanitizer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">Node</span><span style=\"color: #BABED8\"> node</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">PrimitiveType</span><span style=\"color: #BABED8\"> or</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">BoxedType</span><span style=\"color: #BABED8\"> or</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">NumberType</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>第一个类型好像在 Unity 引擎中见到过，但是第二个类型是真没见过，当然第三个类型就是数字类型了。也就是这三种类型，如果 DataFlow 在当前节点中判断出是这三种基础类型，就会直接切断污染链的运行<br>我们可以通过重写该方法来实现更多类型的过滤</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">override predicate </span><span style=\"color: #82AAFF\">isSanitizer</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">Node</span><span style=\"color: #BABED8\"> node</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">PrimitiveType</span><span style=\"color: #BABED8\"> or</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">BoxedType</span><span style=\"color: #BABED8\"> or</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">NumberType</span><span style=\"color: #BABED8\"> or</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #82AAFF\">exists</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">ParameterizedType</span><span style=\"color: #BABED8\"> pt</span><span style=\"color: #89DDFF\">|</span><span style=\"color: #BABED8\"> node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> pt and pt</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getTypeArgument</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> NumberType </span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>我们重点关注这句<code>exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )</code><br>传参的类型是ParameterizedType，他其实是一个关于泛型参数的 class，它所代表的其实是泛型中的参数，比如 List<Long>,那么ParameterizedType 就代表 Long<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714438124654-aa3daa14-3acd-4590-a2f6-301edc6a267b.png#averageHue=%23252235&clientId=u34ffbe8d-3e30-4&from=paste&height=243&id=uc3ab5a19&originHeight=455&originWidth=954&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=102294&status=done&style=none&taskId=u6e6765f0-3d76-4a77-af35-8285a326781&title=&width=508.8\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>更加普适的来说，上面的 ql 代码其实是为了实现这么一个功能： List<E>,我们获取到泛型中的参数 E 之后，判断它是否为 NumberType 类型，如果是的话，isSanitizer 会返回 true，也就是当前污染链切断。<br>这里还进行了一段<code>pt.getTypeArgument(0)</code>的执行，&lt;E,L&gt;泛型中不一定只会有一个参数，ParameterizedType 获取参数时，获取的是泛型里面整体，但是我们本次实验中仅仅只针对这一项误报而做出的处理，所以getTypeArgument(0)就能够定位到 Long<br>添加上isSanitizer 的重写之后，我们再看结果，发现确实解决刚才的误报问题了<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714439620614-d68790c5-8f25-4525-b479-704af1db2ee7.png#averageHue=%23272432&clientId=u34ffbe8d-3e30-4&from=paste&height=242&id=ud1f9ad3d&originHeight=454&originWidth=1294&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=121546&status=done&style=none&taskId=u0b49023d-edaf-493a-81b6-bc0cc59f7e9&title=&width=690.1333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></E></Long></p>\n<h2 id=\"0x02-漏报\"><a href=\"#0x02-漏报\" class=\"headerlink\" title=\"0x02 漏报\"></a>0x02 漏报</h2><p>误报的问题能够从结果中自己检索出来，但是如果出现漏报问题就很难受了，我们其实是看不出来的，只能说是事后复盘解决（在有正确思路的情况下）。可以先看看这个漏报的点在哪<br>IndexController 下的<code>/optinal_like</code>路由<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714440137427-6820aa37-76fb-4b9f-abe8-b244af9ac3e3.png#averageHue=%23333430&clientId=u34ffbe8d-3e30-4&from=paste&height=120&id=u1aaef4b7&originHeight=225&originWidth=1860&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=123398&status=done&style=none&taskId=u98a0a565-1d1a-47ca-83d5-211db306db5&title=&width=992\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>我们跟进它的getStudentWithOptional 方法<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714440184433-76c8503a-9482-4e1b-a428-41d9080257fc.png#averageHue=%23373831&clientId=u34ffbe8d-3e30-4&from=paste&height=146&id=u6886fc95&originHeight=274&originWidth=1802&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=147674&status=done&style=none&taskId=u8a46fbde-1c31-48dc-834d-7ceae0be7e3&title=&width=961.0666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>对比我们 select 出来的结果，发现是没有这条 sink 的，具体流程其实是到了定义 sqlWithOptional 的时候，我们传参进来的是 username，此时会调用 username 的 get 方法，可能是 Codeql 的引擎并没有识别到 Option 类型，所以无法调用 useraname 的 get 方法，于是这条攻击链就断了<br>下面的解决方案可能不适合所有漏报的情形，因为仅仅只是针对这一个漏报进行的修复<br>在 codeql 中我们采用 isAdditionalTaintStep  方法来强制将两节点连接，从而使攻击链能够走下去<br>我们首先看如何定位到当前 node，也就是我们调用 get 方法，以及 username 传进来的这个节点<br>根据文章中的谓词使用，浅写一个测试代码，帮助我们了解这个<code>isTaintedString</code></p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">import</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">java</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">dataflow</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">FlowSources</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">security</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">QueryInjection</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import DataFlow::PathGraph</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">predicate isTaintedString(Expr expSrc, Expr expDest,Method method, MethodAccess call, MethodAccess call1) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">  exists(| </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    expSrc = call1</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getArgument(0) </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and expDest=call </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and call</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getMethod() = method </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and method</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">hasName(&quot;get&quot;) </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and method</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getDeclaringType()</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">toString() = &quot;Optional&lt;String&gt;&quot; </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and call1</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getArgument(0)</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getType()</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">toString() = &quot;Optional&lt;String&gt;&quot;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">  )</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">from DataFlow::Node a,DataFlow::Node b,Method method,MethodAccess call,MethodAccess call1</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">where isTaintedString(a</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">asExpr(), b</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">asExpr(),method,call,call1)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">select a,b,method,call,call1</span></span></code></pre></div><p>结果如下<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714467884124-cdf4c859-c018-4f94-9ae4-fc110213cfac.png#averageHue=%23272435&clientId=u8d506303-14ab-4&from=paste&height=433&id=u5356d448&originHeight=812&originWidth=2011&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=347345&status=done&style=none&taskId=ua16679a8-a749-425e-9370-2b339e68eff&title=&width=1072.5333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>首先我们要明白当前的<code>isTaintedString</code>谓词是为了判断我们是否定位到了 <code>username</code> 和 <code>username.get</code>这两个点，如果定位成功，<code>isAdditionalTaintStep</code>后续会将这两个节点拼接，当前这条攻击链就能够顺利进行，我们最终检索出的 sql 注入点就不会缺少这一条可能了<br><code>expSrc = call1.getArgument(0)</code>   <code>expDest=call</code>,expsrc 和 expDest 两者就是username 和username.get，后续的描述条件说白了就是：我们尽可能的将当前的情形描述详细，能够准确定位到当前的情况<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714470449676-3dc70073-27e5-4950-8a88-5d8601d258a8.png#averageHue=%2335352f&clientId=u8d506303-14ab-4&from=paste&height=153&id=W58vX&originHeight=286&originWidth=1719&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146987&status=done&style=none&taskId=u73140437-2eba-445b-b8d8-9baecbd113d&title=&width=916.8\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n<ol>\n<li><code>call.getMethod() = method</code>与<code>method.hasName(&quot;get&quot;)</code>两种条件描述都是为了定位到 <code>username.get</code>而服务的，两者交换顺序也是没问题的，就像一条工作流，我们为了得到其中的某种物质，漏斗的顺序放置是对结果没有区别的</li>\n<li><code>call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;</code>定位到<code>getStudentWithOptional(Optional&lt;String&gt; username)</code>而服务</li>\n<li><code>method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot;</code>定位 get</li>\n</ol>\n<p>虽说这么做了之后确实能够定位到这一个漏报的 SQL 注入点，但其实遇到其他情况的漏报就有点不够用了，或许有更好的方法也说不定（？</p>\n<h2 id=\"0x03-Lombok-问题\"><a href=\"#0x03-Lombok-问题\" class=\"headerlink\" title=\"0x03 Lombok 问题\"></a>0x03 Lombok 问题</h2><p>Lombok 是一个用来帮助写类定义的插件，我们可以通过注解来完成 get set 方法以及构造方法的书写<br>那么这里就会出现一个问题，如果我们所审计的项目中使用了 Lombok，codeql 是无法识别出这些类的 setget 方法的<br>在 Codeql 的官方 issue 中是有提到这个问题的，解决方案如下</p>\n<div class=\"language-powershell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">powershell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #676E95; font-style: italic\"># get a copy of lombok.jar</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">wget https:</span><span style=\"color: #89DDFF\">//</span><span style=\"color: #BABED8\">projectlombok.org</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">downloads</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">lombok.jar </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">O </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">lombok.jar</span><span style=\"color: #89DDFF\">&quot;</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\"># run &quot;delombok&quot; on the source files and write the generated files to a folder named &quot;delombok&quot;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">java </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">jar </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">lombok.jar</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> delombok </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">n </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">onlyChanged </span><span style=\"color: #89DDFF\">.</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">d </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">delombok</span><span style=\"color: #89DDFF\">&quot;</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\"># remove &quot;generated by&quot; comments</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">find </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">delombok</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">name </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">*.java</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">exec sed </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">/Generated by delombok/d</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">i </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">&#123;&#125;</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">;</span><span style=\"color: #89DDFF\">&#39;</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\"># remove any left-over import statements</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">find </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">delombok</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">name </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">*.java</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">exec sed </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">/import lombok/d</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">i </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">&#123;&#125;</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">;</span><span style=\"color: #89DDFF\">&#39;</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\"># copy delombok&#39;d files over the original ones</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">cp </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">r </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">delombok/.</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">./</span><span style=\"color: #89DDFF\">&quot;</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\"># remove the &quot;delombok&quot; folder</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">rm </span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">rf </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">delombok</span><span style=\"color: #89DDFF\">&quot;</span></span>\n<span class=\"line\"></span></code></pre></div><p>大概的操作就是通过去掉代码里面的 lombok 注释，并且还原 setter 和 getter 方法，这样就和正常的类效果是一样的了</p>\n<p>所以最终我们关于这个项目的 SQL 注入查找的 codeql 代码写为：</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">import</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">java</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">dataflow</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">FlowSources</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">security</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">QueryInjection</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import DataFlow::PathGraph</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">predicate isTaintedString(Expr expSrc, Expr expDest) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">  exists(Method method, MethodAccess call, MethodAccess call1 | </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    expSrc = call1</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getArgument(0) </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and expDest=call </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and call</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getMethod() = method </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and method</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">hasName(&quot;get&quot;) </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and method</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getDeclaringType()</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">toString() = &quot;Optional&lt;String&gt;&quot; </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    and call1</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getArgument(0)</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getType()</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">toString() = &quot;Optional&lt;String&gt;&quot;  </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">  )</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">class VulConfig extends TaintTracking::Configuration &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot; &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">   </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">   </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     override predicate isSink(DataFlow::Node sink) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">       exists(Method method, MethodAccess call |</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">        </span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         method</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">hasName(&quot;query&quot;)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         and</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         call</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getMethod() = method</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         and</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">         sink</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">asExpr() = call</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getArgument(0)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">       )</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">     override predicate isSanitizer(DataFlow::Node node) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">      node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getType() instanceof PrimitiveType or</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">      node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getType() instanceof BoxedType or</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">      node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getType() instanceof NumberType or</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">      exists(ParameterizedType pt| node</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getType() = pt and pt</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getTypeArgument(0) instanceof NumberType )</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">      isTaintedString(node1</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">asExpr(), node2</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">asExpr())</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">   &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">where config</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">hasFlowPath(source, sink)</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">select source</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getNode(), source, sink, &quot;source&quot;</span></span>\n<span class=\"line\"></span></code></pre></div><h1 id=\"持续工程化\"><a href=\"#持续工程化\" class=\"headerlink\" title=\"持续工程化\"></a>持续工程化</h1><p>经过分析测试过后，我们得到了一份关于常规 Springboot 项目的能够进行 SQL 注入检测的 codeql 代码，现在要考虑如何才能将这份代码用于实践<br>两行命令，按照我们之前所有的步骤来总结就两步：</p>\n<ol>\n<li>生成中间数据库</li>\n</ol>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">codeql database create </span><span style=\"color: #89DDFF\">~/</span><span style=\"color: #BABED8\">CodeQL</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">databases</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">micro</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">service</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">seclab  </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">language</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">java</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\">  </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">command</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">mvn clean install --file pom.xml -Dmaven.test.skip=true</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">source</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">root</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">~/Code/micro-service-seclab/</span><span style=\"color: #89DDFF\">&quot;</span></span></code></pre></div><ol start=\"2\">\n<li>运行 codeql 代码,这里是执行刚才写好的 codeql 代码，然后将结果输出到 csv 文件</li>\n</ol>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">codeql database analyze </span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">CodeQL</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">databases</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">micro</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">service</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">seclab </span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">CodeQL</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">ql</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">java</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">ql</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">examples</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">demo </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">format</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\">csv </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">output</span><span style=\"color: #89DDFF\">=/</span><span style=\"color: #BABED8\">CodeQL</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">Result</span><span style=\"color: #89DDFF\">/</span><span style=\"color: #BABED8\">micro</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">service</span><span style=\"color: #89DDFF\">-</span><span style=\"color: #BABED8\">seclab</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #BABED8\">csv </span><span style=\"color: #89DDFF\">--</span><span style=\"color: #BABED8\">rerun</span></span></code></pre></div><h1 id=\"Codeql-语法查漏补缺\"><a href=\"#Codeql-语法查漏补缺\" class=\"headerlink\" title=\"Codeql 语法查漏补缺\"></a>Codeql 语法查漏补缺</h1><p>其实刚才一路跟过来，我为了弄懂一些语法而写了很多测试代码，期间也跟进过源码进行一些方法的查看，给我的感受就是大部分的语法我都很陌生，所以这里单独开一个用来记录的篇章，主要是为了记录一些初见不是很能理解的语法</p>\n<h2 id=\"Instanceof\"><a href=\"#Instanceof\" class=\"headerlink\" title=\"Instanceof\"></a>Instanceof</h2><p>java 里面其实也见到过，只不过在 Codeql 的源码中我们能够经常看到，并且在指定扫描 source 时用的特别多<br>就拿我们本次的 isSource 判定来说</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">override predicate </span><span style=\"color: #82AAFF\">isSource</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #BABED8\">DataFlow</span><span style=\"color: #89DDFF; font-style: italic\">::</span><span style=\"color: #C792EA\">Node</span><span style=\"color: #BABED8\"> src</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span><span style=\"color: #BABED8\"> src </span><span style=\"color: #89DDFF\">instanceof</span><span style=\"color: #BABED8\"> RemoteFlowSource </span><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>我们并没有写很多的 exist 子查询来判定 source，只是通过判定节点 src 是否 instance RemoteFlowSource 就完成了 source 的检索工作，可以想象RemoteFlowSource 里面应该集成了很多类型的 source 用作判定<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714633520438-8e90e5fc-f3bf-4c72-bbf6-a74de0dc8373.png#averageHue=%23262335&clientId=u8b8ef068-c78d-4&from=paste&height=597&id=u5eeb2144&originHeight=1120&originWidth=1278&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=416076&status=done&style=none&taskId=u1eb5c5cf-7672-4279-b2c0-fc8329edfb0&title=&width=681.6\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>可以看到 ReomteSource 的定义中有许多的子类扩展，这里和 java 的语法还有点不太一样，ReomteSource 是一个 abstract 的抽象类定义，而 java 中的抽象类必须要有实现类和对应的实现方法才能够使用功能，这里我们使用ReomteSource 时没有具体的指定要实现它的某些方法，但是我们依然能够用到它的功能。原因就在于 Codeql 中的抽象类，只要我们选择继承，并且在某处有调用的话，所有的子类都会被调用一遍，也就是说，这里所有的 RemoteSource 的子类都会在我们 <code>src instanceof RemoteSource</code> 的时候被调用，那其实大部分的常见入口点 source 都会被检测一遍了</p>\n<h2 id=\"子类递归问题\"><a href=\"#子类递归问题\" class=\"headerlink\" title=\"子类递归问题\"></a>子类递归问题</h2><p>面向对象的一个常见问题，当我们的一个类中出现了子类的定义时，需要一些特殊的处理才能够准确区分和识别到子类与父类<br>比如：</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C792EA\">public</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">class</span><span style=\"color: #BABED8\"> </span><span style=\"color: #FFCB6B\">StudentService</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #C792EA\">class</span><span style=\"color: #BABED8\"> </span><span style=\"color: #FFCB6B\">innerOne</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #C792EA\">public</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">innerOne</span><span style=\"color: #89DDFF\">()&#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #C792EA\">class</span><span style=\"color: #BABED8\"> </span><span style=\"color: #FFCB6B\">innerTwo</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">            </span><span style=\"color: #C792EA\">public</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">innerTwo</span><span style=\"color: #89DDFF\">()&#123;&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">            </span><span style=\"color: #C792EA\">public</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">String</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">Nihao</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">                </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">Nihao</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">            </span><span style=\"color: #89DDFF\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #89DDFF\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #C792EA\">public</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">String</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">Hi</span><span style=\"color: #89DDFF\">()&#123;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">            </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">hello</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">        </span><span style=\"color: #89DDFF\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">    </span><span style=\"color: #89DDFF\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>这里我们定义了三个类：StudentService，innerOne，innerTwo<br>如何通过 innerTwo 定位到最外层的 StudentService 呢？</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">from </span><span style=\"color: #C792EA\">Class</span><span style=\"color: #BABED8\"> classes</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">where classes</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getName</span><span style=\"color: #89DDFF\">().</span><span style=\"color: #82AAFF\">toString</span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">innerTwo</span><span style=\"color: #89DDFF\">&quot;</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">select classes</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getEnclosingType</span><span style=\"color: #89DDFF\">().</span><span style=\"color: #82AAFF\">getEnclosingType</span><span style=\"color: #89DDFF\">()</span></span></code></pre></div><p>这里我们先从所有的 class 定义中获取到 innerTwo 的定义，然后通过<code>getEnclosingType()</code>来获取其上一级的封闭类定义，跟 java 中的<code>getEnclosingType()</code>简直不要太一样<br>实际情况下，我们肯定不知道目标类到底有多少层封闭类的定义，所以这么做只存在于我们知道目标类具体结构的情况下才能使用的<br>还有一种方法能够自动递归来获取其封闭类</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F78C6C\">import</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">java</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">dataflow</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">FlowSources</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import semmle</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">code</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">java</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">security</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">QueryInjection</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">import DataFlow::PathGraph</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">from Class classes</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">where classes</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getName()</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">toString() = &quot;innerTwo&quot;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">select classes</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #C792EA\">getEnclosingType+()</span></span></code></pre></div><p><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714635122775-ad0c61bb-8e5a-4eb9-99bf-e53729374ece.png#averageHue=%23232526&clientId=u8b8ef068-c78d-4&from=paste&height=286&id=u4137e1f0&originHeight=537&originWidth=1915&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=225675&status=done&style=none&taskId=u052819d0-89c6-474e-abb8-bca3ce6234a&title=&width=1021.3333333333334\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>或者我们可以将+改写为*，都是可以的<br><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714635164139-d34daa96-48df-4bad-b4ba-27ac4c96182a.png#averageHue=%23232425&clientId=u8b8ef068-c78d-4&from=paste&height=289&id=u6337d615&originHeight=542&originWidth=1972&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=211620&status=done&style=none&taskId=ucd098b10-2c5f-498c-a511-0b8df4651c0&title=&width=1051.7333333333333\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n<h2 id=\"类型筛选\"><a href=\"#类型筛选\" class=\"headerlink\" title=\"类型筛选\"></a>类型筛选</h2><p>如何筛选出我们想要的类型参数也是一个大问题，通常我们首先会通过如下的代码获取到当前项目中所有的调用参数</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">from </span><span style=\"color: #C792EA\">Parameter</span><span style=\"color: #BABED8\"> param</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">select param</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> param</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">()</span></span></code></pre></div><p><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714636020782-d58b23b5-3b7e-48ed-a070-52b0636b5874.png#averageHue=%23262727&clientId=u8b8ef068-c78d-4&from=paste&height=706&id=uee412917&originHeight=1323&originWidth=1939&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=459091&status=done&style=none&taskId=uce71af7a-716f-423d-88fe-9aad6b76b87&title=&width=1034.1333333333334\" referrerpolicy=\"no-referrer\" alt=\"image.png\"><br>然后我们可以用(RefType)来进行过滤</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">from </span><span style=\"color: #C792EA\">Parameter</span><span style=\"color: #BABED8\"> param</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">select param</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> param</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">().(</span><span style=\"color: #BABED8\">RefType</span><span style=\"color: #89DDFF\">)</span></span></code></pre></div><p>这里的 RefType 代表的是什么呢？它相当于一层 filter，将所有的 6种数字类型（byte&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double）、1种字符型（char）、1种布尔型（boolean）  过滤了一遍，再将结果输出出来<br>我们还可以指定过滤一些特定的类型,这里就是指定筛选出所有的 int 类型</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">from </span><span style=\"color: #C792EA\">Parameter</span><span style=\"color: #BABED8\"> param</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">select param</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #BABED8\"> param</span><span style=\"color: #89DDFF\">.</span><span style=\"color: #82AAFF\">getType</span><span style=\"color: #89DDFF\">().(</span><span style=\"color: #BABED8\">IntegralType</span><span style=\"color: #89DDFF\">)</span></span></code></pre></div><p><img src=\"https://cdn.nlark.com/yuque/0/2024/png/36078896/1714636425505-f67602ee-7fbc-4acf-aa9e-672015978edc.png#averageHue=%23262828&clientId=u8b8ef068-c78d-4&from=paste&height=688&id=u8c98b5a3&originHeight=1290&originWidth=1970&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=394516&status=done&style=none&taskId=u9b4ea65d-d467-4615-9df6-ec67c7eb5c2&title=&width=1050.6666666666667\" referrerpolicy=\"no-referrer\" alt=\"image.png\"></p>\n","feature":true,"text":"本文为个人学习笔记+一些个人的理解调试，仅供学习参考 首先存几个学习地点https://drun1baby.top/2023/09/03/CodeQL-%E5%...","permalink":"/post/CodeQL学习","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"挥刀练习之codeQL","slug":"挥刀练习之codeQL","count":1,"path":"api/categories/挥刀练习之codeQL.json"}],"tags":[{"name":"用刀的技艺","slug":"用刀的技艺","count":1,"path":"api/tags/用刀的技艺.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-CodeQL\"><span class=\"toc-text\">什么是 CodeQL</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CodeQL-%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">CodeQL 配置</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CodeQL-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">CodeQL 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x01-%E6%B5%8B%E8%AF%95-Helloworld\"><span class=\"toc-text\">0x01 测试 Helloworld</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x02-CodeQL-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">0x02 CodeQL 基本语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x03-%E7%B1%BB%E5%BA%93\"><span class=\"toc-text\">0x03 类库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x04-%E8%B0%93%E8%AF%8D%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">0x04 谓词使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x05-Node%EF%BC%8CExpr%EF%BC%8CParam\"><span class=\"toc-text\">0x05 Node，Expr，Param</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x06-source-%EF%BC%8Csink%EF%BC%8C-sanitizer\"><span class=\"toc-text\">0x06 source ，sink， sanitizer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1x01-%E8%AE%BE%E7%BD%AE-source\"><span class=\"toc-text\">1x01 设置 source</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1x02-%E8%AE%BE%E7%BD%AE-sink\"><span class=\"toc-text\">1x02 设置 sink</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1x03-Flow-%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">1x03 Flow 数据流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1x04-%E6%95%B4%E4%BD%93%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">1x04 整体查询</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">结果优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x01-%E8%AF%AF%E6%8A%A5\"><span class=\"toc-text\">0x01 误报</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x02-%E6%BC%8F%E6%8A%A5\"><span class=\"toc-text\">0x02 漏报</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x03-Lombok-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">0x03 Lombok 问题</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8C%81%E7%BB%AD%E5%B7%A5%E7%A8%8B%E5%8C%96\"><span class=\"toc-text\">持续工程化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Codeql-%E8%AF%AD%E6%B3%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA\"><span class=\"toc-text\">Codeql 语法查漏补缺</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Instanceof\"><span class=\"toc-text\">Instanceof</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">子类递归问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E7%AD%9B%E9%80%89\"><span class=\"toc-text\">类型筛选</span></a></li></ol></li></ol>","author":{"name":"stoocea","slug":"blog-author","avatar":"https://bu.dusays.com/2024/06/28/667ece6738c20.jpg","link":"/","description":"time thick away","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java二次反序列化学习","uid":"9eef0bafd340d6fd0d85cf5145bacfba","slug":"Java二次反序列化","date":"2024-06-04T06:00:00.000Z","updated":"2024-06-28T15:09:08.329Z","comments":true,"path":"api/articles/Java二次反序列化.json","keywords":null,"cover":"https://bu.dusays.com/2024/06/28/667ecfe7b6094.webp","text":"前言二次反序列化大多数时候是用来绕过黑名单或者解决不出网的问题，不会作为一条单独且完整的利用链存在，而是作为一个中间节点，用来绕过。二次反序列化一般来说有如下几...","permalink":"/post/Java二次反序列化","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"锻刀的理论学习-java二次反序列化","slug":"锻刀的理论学习-java二次反序列化","count":1,"path":"api/categories/锻刀的理论学习-java二次反序列化.json"}],"tags":[{"name":"锻刀","slug":"锻刀","count":11,"path":"api/tags/锻刀.json"}],"author":{"name":"stoocea","slug":"blog-author","avatar":"https://bu.dusays.com/2024/06/28/667ece6738c20.jpg","link":"/","description":"time thick away","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Apache DolphinScheduler 任意代码执行漏洞分析","uid":"651d2c36bfca60e4d9856f4d1d38b3ec","slug":"Apache DolphinScheduler 任意代码执行漏洞分析","date":"2024-04-26T04:00:00.000Z","updated":"2024-06-28T02:54:20.914Z","comments":true,"path":"api/articles/Apache DolphinScheduler 任意代码执行漏洞分析.json","keywords":null,"cover":"https://bu.dusays.com/2024/03/08/65ea8090a709b.png","text":"包括如下几个 cve：CVE-2023-49299 CVE-2024-23320 漏洞描述 Apache DolphinScheduler 是一个分布式、易扩展...","permalink":"/post/Apache DolphinScheduler 任意代码执行漏洞分析","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"CVE","slug":"CVE","count":1,"path":"api/categories/CVE.json"}],"tags":[{"name":"CVESearch","slug":"CVESearch","count":1,"path":"api/tags/CVESearch.json"}],"author":{"name":"stoocea","slug":"blog-author","avatar":"https://bu.dusays.com/2024/06/28/667ece6738c20.jpg","link":"/","description":"time thick away","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}