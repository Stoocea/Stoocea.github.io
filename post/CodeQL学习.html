<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="stoocea" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  <meta name="description" content="time thicking away" />
  
  
  
  <title>
    
      CodeQL学习 
      
      
      |
    
     stoocea&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="https://bu.dusays.com/2024/04/15/661ce929d665d.png">
    <link rel="icon" href="https://bu.dusays.com/2024/04/15/661ce929d665d.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="https://bu.dusays.com/2024/04/15/661ce929d665d.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Stoocea</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">CodeQL学习</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2024-05-02 16:40:28
        </span>
        
      </div>
      <div class="markdown-body">
        <p>本文为个人学习笔记+一些个人的理解调试，仅供学习参考</p>
<p>首先存几个学习地点<br><a target="_blank" rel="noopener" href="https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/">https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/</a><br><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/283795.html">https://www.freebuf.com/articles/web/283795.html</a><br><a target="_blank" rel="noopener" href="https://codeql.github.com/docs/codeql-overview/about-codeql/">https://codeql.github.com/docs/codeql-overview/about-codeql/</a></p>
<h1 id="什么是-CodeQL"><a href="#什么是-CodeQL" class="headerlink" title="什么是 CodeQL"></a>什么是 CodeQL</h1><p>这里我本来想用一句话总结的，但是自己学的还不够，所以无法总结，深入学习之后再总结</p>
<h1 id="CodeQL-配置"><a href="#CodeQL-配置" class="headerlink" title="CodeQL 配置"></a>CodeQL 配置</h1><p>首先要先下载 CodeQL 的 CIL，这个官网的 releases 上有，我们选择 win64 版本的安装包<br>然后下 SDK</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Semmle/ql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下完之后的目录结构如下<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714028475927-93e54d1f-95a1-4acb-b766-e0cbd8764e51.png#averageHue=%23fbfbfb&clientId=uaa2b4734-80a9-4&from=paste&height=201&id=ub7157620&originHeight=376&originWidth=1474&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21552&status=done&style=none&taskId=ud0f0da22-d5b3-44e1-9ac7-6ca9b525191&title=&width=786.1333333333333" referrerpolicy="no-referrer" alt="image.png">然后配置环境变量，配置一个 codeql 的路径即可，这里的路径以我的为例就是</p>
<pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">H:<span class="token function selector">\CodeQL</span><span class="token function selector">\codeql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后运行一下 codeql 命令，出现如下内容就没太大问题了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714029257839-be740358-135a-4f8e-92e1-04c37dd89bb8.png#averageHue=%2345474e&clientId=uaa2b4734-80a9-4&from=paste&height=491&id=u7770b83e&originHeight=920&originWidth=1339&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=695160&status=done&style=none&taskId=u3cf96e93-64c0-440c-99fb-afed2c21753&title=&width=714.1333333333333" referrerpolicy="no-referrer" alt="image.png"></p>
<h1 id="CodeQL-使用"><a href="#CodeQL-使用" class="headerlink" title="CodeQL 使用"></a>CodeQL 使用</h1><h2 id="0x01-测试-Helloworld"><a href="#0x01-测试-Helloworld" class="headerlink" title="0x01 测试 Helloworld"></a>0x01 测试 Helloworld</h2><p>Codeql 处理对象并不是项目源码本身，而是中间生成的 AST 结构数据库，所以每次分析之前，我们需要将项目源码转化成 Codeql 能够识别的 CodeDataBase<br>这里以我们从<a target="_blank" rel="noopener" href="https://github.com/l4yn3/micro_service_seclab/">micro_service_seclab</a>靶场获取的源码为例，稍微看一下目录结构，作者写的一个很标准的 Springboot 的项目<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714029189965-318d9304-26f5-47e1-b3ce-669bd4fdf6aa.png#averageHue=%233d4243&clientId=uaa2b4734-80a9-4&from=paste&height=434&id=u30a15417&originHeight=813&originWidth=897&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=226094&status=done&style=none&taskId=u07345504-1b0c-48af-8f9b-833048f5eae&title=&width=478.4" referrerpolicy="no-referrer" alt="image.png"><br>然后我们执行如下命令</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">codeql database create <span class="token punctuation">.</span>/databases<span class="token operator">/</span>micro_service_seclab_database  <span class="token operator">--</span>language<span class="token operator">=</span><span class="token string">"java"</span>  <span class="token operator">--</span>command<span class="token operator">=</span><span class="token string">"mvn clean install --file pom.xml"</span> <span class="token operator">--</span>source<span class="token operator">-</span>root<span class="token operator">=</span><span class="token punctuation">.</span>/practice<span class="token operator">/</span>micro_service_seclab<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是初次运行，有很大概率会报错<br>这个原因有很多，解决方法可参考这位师傅，找了很多关于 java 本身 maven 编译项目的问题，都无法解决<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_63303407/article/details/128750198">https://blog.csdn.net/m0_63303407&#x2F;article&#x2F;details&#x2F;128750198</a><br>然后是我的环境变量<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714100745081-2c749e89-728f-4974-86aa-8b1b7ae5388d.png#averageHue=%23f3f0ed&clientId=ud3265ec2-e53a-4&from=paste&height=34&id=uef6d0d98&originHeight=63&originWidth=600&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5682&status=done&style=none&taskId=u7759ff90-eabf-47f7-82ed-4d8801cc8c5&title=&width=320" referrerpolicy="no-referrer" alt="image.png"><br>我个人这么配置之后基本上没啥问题了<br>然后是 Vscode 中配置一下我们刚才生成的 database，配置完这个之后我们就能够写查询语句了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714110696673-0070c5e1-3058-40d6-b884-1068f256db65.png#averageHue=%23221f2d&clientId=ud3e91435-e9be-4&from=paste&height=499&id=uc6371d9e&originHeight=1248&originWidth=841&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=242911&status=done&style=none&taskId=uad9cac80-4823-41f5-a89a-59bacc94fc7&title=&width=336.5333557128906" referrerpolicy="no-referrer" alt="image.png"><br>在当前这个目录下，新建一个 demo.ql 文件，用来写我们的查询语句，这里我们简单的 select 出来一个 helloworld 字符串<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714110750954-0698a9f5-6ec3-41a4-8e0f-fcd9d659a3ec.png#averageHue=%23272333&clientId=ud3e91435-e9be-4&from=paste&height=728&id=ufd4f9034&originHeight=1365&originWidth=2560&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=736744&status=done&style=none&taskId=u33a47813-f83d-49a8-9cdc-d223cd43021&title=&width=1365.3333333333333" referrerpolicy="no-referrer" alt="image.png"></p>
<h2 id="0x02-CodeQL-基本语法"><a href="#0x02-CodeQL-基本语法" class="headerlink" title="0x02 CodeQL 基本语法"></a>0x02 CodeQL 基本语法</h2><p>我们最开始提到了在 CodeQL 中，代码被视作数据，而漏洞，错误或者其他报错都被建模为可以针对的从代码中提权的数据库查询。其实就拿刚才的项目来说，我们先将项目中的内容转化为 Codeql 能够识别出来的数据库，这个过程其实就是 codeql 引擎将我们的项目内容（java 代码）转化为了我们 codeql 可识别的 AST 数据库，然后按照 Codql 中的编写的规则去查询数据库中的数据。这个思想其实在我看来就是将面向对象的数据库查询<br>稍微理解了一下 Codeql 整体的流程，看个例子</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java</span>

from <span class="token keyword">int</span> i
where i<span class="token operator">=</span><span class="token number">1</span>
select i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714111820691-a739d39c-59f9-4bfa-83b8-4dfb0dfb686f.png#averageHue=%232d2939&clientId=ud3e91435-e9be-4&from=paste&height=247&id=u5d04bff4&originHeight=464&originWidth=2183&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=225030&status=done&style=none&taskId=u2965f6a6-7b09-4088-bc6a-e0735bbbf5d&title=&width=1164.2666666666667" referrerpolicy="no-referrer" alt="image.png"></p>
<ul>
<li><code>import java</code> 由于我们审计的是 java 项目，所以要导入 java 的类库</li>
<li><code>from int i</code> 这句代码表示我们从 int 这个整数组中取一个变量作为 i，其实这一步更像是给 i 这个属性定类型，int i </li>
<li><code>where i= 1</code> 就是当我们的 i 为 1 时，就执行下面的逻辑</li>
<li><code>select 1</code> 也就是在上一句的 where 条件达成之后，我们执行一段 select 语句</li>
</ul>
<p>其实大部分的 codeql 代码都可以浓缩为这一段</p>
<h2 id="0x03-类库"><a href="#0x03-类库" class="headerlink" title="0x03 类库"></a>0x03 类库</h2><p>上面提到了 codeql 引擎把 java 代码转化为了 databases，这里其实有一个细节，就是复数 databases，我们知道 java 是一门典型的面向对象的语言，类是必不可少的，而这里的每一个 dababase，就对应一个类。这也是为什么每一个 java 项目转化之后被称为了 databases 了—-类数据集。而类库的具体实现，就是一个一个 AST 结构表示出来的，这里我们演示一段查看某一 database 的 AST 结构<br>首先将我们的源码添加到工作区，我们待会能够直接从 vscode 中指定到源码<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714188363446-9dff9b5b-53db-409c-a420-f74dc52bb7b6.png#averageHue=%23211e2c&clientId=u591b4bf5-34dd-4&from=paste&height=426&id=u9b528ae4&originHeight=798&originWidth=675&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=109815&status=done&style=none&taskId=u56e123bb-9ea5-420c-b21a-6b590cb3f93&title=&width=360" referrerpolicy="no-referrer" alt="image.png"><br>添加成功之后你就能够看到在 CodeQL 这个大文件夹外面会多一层源码目录，这个时候我们选定 IndexController.java 文件<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714188468096-45e70570-6b72-45a3-813b-8ccd5efeeab9.png#averageHue=%23282435&clientId=u591b4bf5-34dd-4&from=paste&height=676&id=u454e3adf&originHeight=1267&originWidth=2423&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=895204&status=done&style=none&taskId=u380528e5-6c73-4572-bf22-261fdef61c2&title=&width=1292.2666666666667" referrerpolicy="no-referrer" alt="image.png"><br>再去 codeql 中点击 view AST，就能够看到当前 IndexController.java 类的 AST 结构了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714188529071-ae86f1a8-558e-4ac2-a2ed-b5457d2ccfa2.png#averageHue=%23292536&clientId=u591b4bf5-34dd-4&from=paste&height=641&id=ue05c82a2&originHeight=1202&originWidth=2393&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=921086&status=done&style=none&taskId=ubcaf0fbe-7863-492e-a71b-311638ff43e&title=&width=1276.2666666666667" referrerpolicy="no-referrer" alt="image.png"><br>当然除了我们本来的这些 java 代码的类库，我们还有 codeql 中帮助我们集成的一些类库，比如 Method，MethodAccess，Parameter 等。这里列出来的三个都是很常见的三个类库，具体作用如下：</p>
<ol>
<li>Method，方法类库，用来存储当前项目的中的所有方法</li>
<li>MethodAccess，调用方法类库，用来存储当前项目中的所有方法调用</li>
<li>Parameter，参数类库，用来存储当前项目中所有的参数</li>
</ol>
<p>当然，这三个类库都是有对应类的，名字是一样的。既然是类，那么一定有类方法和类属性，我们这里稍微看一下 Method 类的方法使用</p>
<pre class="line-numbers language-plsql" data-language="plsql"><code class="language-plsql">import <span class="token keyword">java</span>

<span class="token keyword">from</span> Method method
<span class="token keyword">where</span> method<span class="token punctuation">.</span>hasName<span class="token punctuation">(</span><span class="token string">"getStudent"</span><span class="token punctuation">)</span>
<span class="token keyword">select</span> method<span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>method<span class="token punctuation">.</span>getDeclaringType<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是结果<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714270196970-8878fd0c-aa14-45e7-8d15-6c71ee2e5062.png#averageHue=%23322d3e&clientId=ue4758036-374d-4&from=paste&height=130&id=u91d3760b&originHeight=244&originWidth=897&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50181&status=done&style=none&taskId=ucaa4a13e-aaa9-4791-bd87-2d1e968ddd2&title=&width=478.4" referrerpolicy="no-referrer" alt="image.png"><br>method.getName 就是获取到我们搜索到的方法名，method.getDeclaringType 就是获取到定义当前方法的类</p>
<h2 id="0x04-谓词使用"><a href="#0x04-谓词使用" class="headerlink" title="0x04 谓词使用"></a>0x04 谓词使用</h2><p>谓词的出现，是为了解决 where 条件过长，影响逻辑分析的情况。其实谓词也可以叫做函数，只不过在 codeql 中都是叫谓词，看如下谓词</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">import</span> java

predicate isgetStudent<span class="token punctuation">(</span>Method method<span class="token punctuation">)</span> &#123;
    <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token operator">|</span>method<span class="token punctuation">.</span>hasName<span class="token punctuation">(</span><span class="token string">"getStudent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

&#125;

<span class="token keyword">from</span> Method method
<span class="token keyword">where</span> isgetStudent<span class="token punctuation">(</span>method<span class="token punctuation">)</span>
<span class="token keyword">select</span> method<span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>method<span class="token punctuation">.</span>getDeclaringType<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>格式和函数是差不多的</p>
<blockquote>
<p>predicate 表示当前方法没有返回值<br>exists 叫做子查询，他可以根据参数中的子查询来返回 true 或者 false，这里要注意一下格式，子查询前面有一个 |,这个格式其实用意在于，| 前半段的数据作为参数，| 后半段的代码作为执行的判断逻辑代码，前面的参数是可以传递给后半段的代码执行中的</p>
</blockquote>
<h2 id="0x05-Node，Expr，Param"><a href="#0x05-Node，Expr，Param" class="headerlink" title="0x05 Node，Expr，Param"></a>0x05 Node，Expr，Param</h2><p>这一块算是自己单独分出来的一部分笔记，因为我学到后面之后有些参数的意思不能够瞬间反应出来，觉得有些基础概念还是没过<br>Expr 和 Param 分别叫做表达式和参数，他们两者都是 Node 的类型，并且 Node 就这两种类型，我们能够分别通过 asExpr()和 asParam()方法将他们取出来<br>Expr：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//String sql = "select * from students where username like '%" + username.get() + "%'";</span>
    <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from students where username like '%"</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">"%'"</span><span class="token punctuation">;</span>
    <span class="token comment">//String sql = "select * from students where username like ?";</span>
    <span class="token keyword">return</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>sql<span class="token punctuation">,</span> <span class="token constant">ROW_MAPPER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x06-source-，sink，-sanitizer"><a href="#0x06-source-，sink，-sanitizer" class="headerlink" title="0x06 source ，sink， sanitizer"></a>0x06 source ，sink， sanitizer</h2><p>sink 应该很熟悉了，	指最终执行点。source 指的是入口点，也就是漏洞污染链条输入点。sanitizer 叫做净化函数，在整个漏洞链条的执行过程中如果出现了一个点，能够阻断整条攻击链的逻辑执行，那么这个点就叫做sanitizer<br>总结一下，如果用 codeql 编写规则去找漏洞，我们要保证 source 和 sink 都存在，并且链中不存在 sanitizer 即可</p>
<p>这里我们进行一个关于 Springboot 中的 SQL 注入的攻击链寻找，那么最终触发的方法（sink）一般是 query 或者 exeSql 了。当然还需要考虑入口点，也就是 source，Springboot 中一般就是各路由下的接收变量参数了</p>
<h3 id="1x01-设置-source"><a href="#1x01-设置-source" class="headerlink" title="1x01 设置 source"></a>1x01 设置 source</h3><p>在 codeql 中我们可以用如下谓词来查询 source</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">override predicate isSource<span class="token punctuation">(</span>DataFlow::Node src<span class="token punctuation">)</span>&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于我们当前分析的是 SpringBoot 的项目，入口点应该是每一个具有接收数据流的参数，以及它对应的类<br>比如 IndexController 中大部分路由下都有的一个 RequestParam 参数<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714274559202-402479b8-717d-4b5c-9d4d-2b75dc840ad3.png#averageHue=%232d283a&clientId=ubd7eff1b-c86b-4&from=paste&height=443&id=ufab7df02&originHeight=830&originWidth=1140&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=435834&status=done&style=none&taskId=u17e4c21b-ac04-4caf-b833-576862ec06e&title=&width=608" referrerpolicy="no-referrer" alt="image.png"><br>这些都是我们需要去收集的 source<br>那收集这些参数的谓词该怎么写呢？我们可以拿 Codeql 中原生的规则来用</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">override predicate isSource<span class="token punctuation">(</span>DataFlow::Node src<span class="token punctuation">)</span> &#123; 
src instanceof RemoteFlowSource 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这是 SDK 中自带的规则，里面包含了大多数常用的 Source 入口<br>这段初看还是有点懵的，先看 RemoteFlowSource，它是一个类库，具体位置在 <code>semmle.code.java.dataflow.FlowSources</code>，本来的用意是存储可能的远程用户控制的数据流源，它里面内置了很多常见的 source 入口，包括我们本次要用到的 Springboot 中的常见传参<br>至于谓词里面的内容，我们之后再记，这里插个 flag</p>
<h3 id="1x02-设置-sink"><a href="#1x02-设置-sink" class="headerlink" title="1x02 设置 sink"></a>1x02 设置 sink</h3><p>开头提到了我们本次案例查找 SQL 注入的最终触发方法是 query 方法或者 exeSql 方法，所以在 sink 的谓词中，我们会直接查找 query 或者 exeSql 方法，以及它的调用</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">override predicate isSink<span class="token punctuation">(</span>DataFlow::Node sink<span class="token punctuation">)</span> &#123;
<span class="token keyword">exists</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> MethodAccess <span class="token keyword">call</span> <span class="token operator">|</span>
  method<span class="token punctuation">.</span>hasName<span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span>
  <span class="token operator">and</span>
  <span class="token keyword">call</span><span class="token punctuation">.</span>getMethod<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> method <span class="token operator">and</span>
  sink<span class="token punctuation">.</span>asExpr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">call</span><span class="token punctuation">.</span>getArgument<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的语法初见肯定会奇怪，我们拆开来分析<br>谓词结构:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">override predicate isSink<span class="token punctuation">(</span>DataFlow::Node sink<span class="token punctuation">)</span> &#123;
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>里面的内容先不看，我们只看整体的结构，参数 DataFlow::Node 类型的 sink，这里举个例子来理解：java 种各式各样的攻击链，期间一定会有一段参数是一直在传递的，这个参数一般就是我们的最开始输入的 payload。我们再看 source 谓词的参数：<code>DataFlow::Node src</code>，也就是这个 DataFlow::Node 其实就是我们一开始输入的正常参数或者 payload<br>我们再看谓词里面的内容 ：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">exists</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> MethodAccess <span class="token keyword">call</span> <span class="token operator">|</span>
  method<span class="token punctuation">.</span>hasName<span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span>
  <span class="token operator">and</span>
  <span class="token keyword">call</span><span class="token punctuation">.</span>getMethod<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> method 
  <span class="token operator">and</span>
  sink<span class="token punctuation">.</span>asExpr<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">call</span><span class="token punctuation">.</span>getArgument<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实整体就是一个 exists 子查询，exists(object| …..)，这里接收到了 Method，以及调用参数 MethodAccess。后续的调用中我们会判断该方法名是否等于 “query”。然后判断调用当前方法的方法<br>其实这里我一直不太理解为什么要加<code>call.getMethod() = method</code>，甚至可以说我不太理解这整段关于 sink 的寻找，直到下面整体使用的时候才稍微清晰一点,这里就拿后面的理解提前分析一下这段关于 sink 的子查询了<br>首先是 <code>method.hashName(&quot;query&quot;)</code>，他其实就是先从所有调用流中将我们所有包含 query 方法的数据流给检索出来，当然这里检索出来可能并不会直接调用到 query 方法，可能是调用链的第 N 环<br>然后是<code>call.getMethod() = method</code>，结合上面我们检索出的数据流，我们查找调用方法中，当前正在调用 query 方法 Node 节点<br>最后 <code>sink.asExpr() = call.getArgument(0)</code>，就是判断 sink 点是否作为当前方法调用的第一个参数，结合上面两个流程，意思就是说我们的 sink 点要作为 query 方法的第一个参数</p>
<h3 id="1x03-Flow-数据流"><a href="#1x03-Flow-数据流" class="headerlink" title="1x03 Flow 数据流"></a>1x03 Flow 数据流</h3><p>我们确定好开头 source 以及链尾 sink 之后，还需要保证整条攻击链是打通的，也就是说不能够出现跟进一半流程跟不下去的情况。那么该怎么去写 codeql 代码保证 Flow 数据流能够正常流通呢？这个确保联通的工作其实交由 codeql 引擎帮助我们完成，我们可以通过<code>Vulnconfig.hasFlowPath</code> 方法来判断是否联通<br>测试代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">from <span class="token class-name">VulnConfig</span> config<span class="token punctuation">,</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> source<span class="token punctuation">,</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span>	sink
where config<span class="token punctuation">.</span><span class="token function">hasFlowPath</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span>sink<span class="token punctuation">)</span>
select source<span class="token punctuation">.</span><span class="token function">getNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>source<span class="token punctuation">,</span>sink<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<h3 id="1x04-整体查询"><a href="#1x04-整体查询" class="headerlink" title="1x04 整体查询"></a>1x04 整体查询</h3><p>Codeql 的语法其实和 java 的很像，写完之后才理解为什么说 codeql 是面向对象版的 sql 查询</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>dataflow<span class="token punctuation">.</span></span><span class="token class-name">FlowSources</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">QueryInjection</span>
<span class="token keyword">import</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathGraph</span>


<span class="token keyword">class</span> <span class="token class-name">VulConfig</span> <span class="token keyword">extends</span> <span class="token class-name">TaintTracking</span><span class="token operator">::</span><span class="token class-name">Configuration</span> <span class="token punctuation">&#123;</span>
     <span class="token class-name">VulConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token string">"SqlInjectionConfig"</span> <span class="token punctuation">&#125;</span>
   
     override predicate <span class="token function">isSource</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> src<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> src <span class="token keyword">instanceof</span> <span class="token class-name">RemoteFlowSource</span> <span class="token punctuation">&#125;</span>
   
     override predicate <span class="token function">isSink</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> sink<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token function">exists</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">MethodAccess</span> call <span class="token operator">|</span>
        
         method<span class="token punctuation">.</span><span class="token function">hasName</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span>
         and
         call<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> method
         and
         sink<span class="token punctuation">.</span><span class="token function">asExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> call<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token punctuation">)</span>
     <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>

from <span class="token class-name">VulConfig</span> config<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> source<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> sink
where config<span class="token punctuation">.</span><span class="token function">hasFlowPath</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>
select source<span class="token punctuation">.</span><span class="token function">getNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">,</span> <span class="token string">"source"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实 isSource 或者 isSink 如果直接按照我上面分析的一样去写是会报错的，因为加了一个限定词 Override,很明显它肯定是一个重写方法，那他最开始的定义在哪里呢？我们跟进TaintTracking 的定义<br>发现TaintTracking 很像一个接口形式的类，也就是大致的包含和定义还是规定了，但是具体的定义没有写<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714390728462-b9acbf7c-ac17-4246-83d8-9f4d1a08f34a.png#averageHue=%23242234&clientId=u6622cb15-b286-4&from=paste&height=377&id=u4018e3ba&originHeight=706&originWidth=1784&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=302659&status=done&style=none&taskId=ubc50db75-348d-4ed0-90fb-a7e9428e03e&title=&width=951.4666666666667" referrerpolicy="no-referrer" alt="image.png"><br>有一个TaintTrackingImpl，我们拿面向对象的思想去套，说不定它里面就有呢？跟进之后发现这是一个文件，后缀是 qll，这个没太了解，但是我么能够在这个文件中找到<code>Configuration extends DataFlow::Configuration</code>的定义，这也是我们为什么定义的 Class 要继承<code>TaintTracking::Configuration</code>，往后翻就能在Configuration 中找到 isSource 和 isSink 的定义<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714392663239-24311c96-0497-4cab-9d16-a9693826dc2b.png#averageHue=%23252235&clientId=u6622cb15-b286-4&from=paste&height=535&id=u86bfc050&originHeight=1003&originWidth=1011&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=290136&status=done&style=none&taskId=ubc7063d9-9a09-4fbb-a033-49a84c8ea80&title=&width=539.2" referrerpolicy="no-referrer" alt="image.png"><br>相信整体的代码也能够理解了，为什么要先写一个类继承自<code>TaintTracking::Configuration</code>，然后再写 isSink 和 isSource 方法，这跟面向对象的语法其实是很像的<br>再解析一下最后三行的代码：<br>实例化（？）一个我们重写的 VulnConfig，然后获取两个 DataFlow 的节点 Node，分别叫做 source 和 sink，只不过之后放入 config 中就会由 codeql 引擎去判断以及我们写的 issink 或者 issource 是否为 sink 和 source，然后判断数据流是否通了。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">from <span class="token class-name">VulConfig</span> config<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> source<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> sink
where config<span class="token punctuation">.</span><span class="token function">hasFlowPath</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>
select source<span class="token punctuation">.</span><span class="token function">getNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">,</span> <span class="token string">"source"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>结果如下<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714393791808-ad72c883-001f-4c79-aa4c-ffc06b9200af.png#averageHue=%23272433&clientId=u6622cb15-b286-4&from=paste&height=254&id=u2335cbec&originHeight=476&originWidth=1293&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=133496&status=done&style=none&taskId=uc4585cf9-a1c2-4b37-8486-0fc3d822e72&title=&width=689.6" referrerpolicy="no-referrer" alt="image.png"><br>这里可能还有一个疑问，isSource 和 isSink 是在哪里执行的？跟进hasFlowPath()就能够找到具体执行的点了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714439540109-147209f9-9c52-4c95-b482-7160d226ea20.png#averageHue=%23272437&clientId=u34ffbe8d-3e30-4&from=paste&height=165&id=ud52ca25d&originHeight=310&originWidth=1087&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=78288&status=done&style=none&taskId=uae401d48-6ace-4102-be09-eafc32982d7&title=&width=579.7333333333333" referrerpolicy="no-referrer" alt="image.png"></p>
<h1 id="结果优化"><a href="#结果优化" class="headerlink" title="结果优化"></a>结果优化</h1><h2 id="0x01-误报"><a href="#0x01-误报" class="headerlink" title="0x01 误报"></a>0x01 误报</h2><p>我们一个一个去检查结果，发现在第三个结果中出现了误报现象：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714436651363-557f5145-af90-4478-b859-3a334d6478e9.png#averageHue=%23262436&clientId=u34ffbe8d-3e30-4&from=paste&height=108&id=u3604c111&originHeight=203&originWidth=1006&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=59302&status=done&style=none&taskId=u41349745-02bc-4c4a-8f4e-15db4b83a8f&title=&width=536.5333333333333" referrerpolicy="no-referrer" alt="image.png"><br>其实靶场的作者也帮我们标注出来了，发现 source 的传参类型是 List<long>的类型，也就是长整数类型，我们并不能够通过参数的传入打入 SQL 注入<br>其实大多数情况下，如果结果 ql 代码这么写的话，都是会出现这种情况的误报的，那如何去解决这个问题呢？<br>这里我们可以用到<code>TaintTracking::Configuration</code>中提供的方法—isSanitier，他是 Configuration 中提供的净化方法，我们能够从源码中找到它的原型定义<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714437065383-81eeec4e-8f68-4c0f-8c8b-cbb8d316806d.png#averageHue=%23232033&clientId=u34ffbe8d-3e30-4&from=paste&height=71&id=ud7dc979a&originHeight=133&originWidth=820&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27591&status=done&style=none&taskId=u9f454ae7-37d0-495d-9c17-23556af1cb7&title=&width=437.3333333333333" referrerpolicy="no-referrer" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714437125709-88f39ada-138d-4fca-a5cf-af03493e8bd8.png#averageHue=%23262335&clientId=u34ffbe8d-3e30-4&from=paste&height=124&id=u7a2f0a7c&originHeight=232&originWidth=1112&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47984&status=done&style=none&taskId=ueb369164-f69c-4d8b-92b4-842ec2ced1e&title=&width=593.0666666666667" referrerpolicy="no-referrer" alt="image.png"><br>isSanitier 方法它本身是会对基础类型以及一些奇怪类型进行判断的：</long></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">override predicate <span class="token function">isSanitizer</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">PrimitiveType</span> or
node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">BoxedType</span> or
node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">NumberType</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一个类型好像在 Unity 引擎中见到过，但是第二个类型是真没见过，当然第三个类型就是数字类型了。也就是这三种类型，如果 DataFlow 在当前节点中判断出是这三种基础类型，就会直接切断污染链的运行<br>我们可以通过重写该方法来实现更多类型的过滤</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">override predicate <span class="token function">isSanitizer</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">PrimitiveType</span> or
    node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">BoxedType</span> or
    node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">NumberType</span> or
    <span class="token function">exists</span><span class="token punctuation">(</span><span class="token class-name">ParameterizedType</span> pt<span class="token operator">|</span> node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> pt and pt<span class="token punctuation">.</span><span class="token function">getTypeArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">NumberType</span> <span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们重点关注这句<code>exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )</code><br>传参的类型是ParameterizedType，他其实是一个关于泛型参数的 class，它所代表的其实是泛型中的参数，比如 List<Long>,那么ParameterizedType 就代表 Long<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714438124654-aa3daa14-3acd-4590-a2f6-301edc6a267b.png#averageHue=%23252235&clientId=u34ffbe8d-3e30-4&from=paste&height=243&id=uc3ab5a19&originHeight=455&originWidth=954&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=102294&status=done&style=none&taskId=u6e6765f0-3d76-4a77-af35-8285a326781&title=&width=508.8" referrerpolicy="no-referrer" alt="image.png"><br>更加普适的来说，上面的 ql 代码其实是为了实现这么一个功能： List<E>,我们获取到泛型中的参数 E 之后，判断它是否为 NumberType 类型，如果是的话，isSanitizer 会返回 true，也就是当前污染链切断。<br>这里还进行了一段<code>pt.getTypeArgument(0)</code>的执行，&lt;E,L&gt;泛型中不一定只会有一个参数，ParameterizedType 获取参数时，获取的是泛型里面整体，但是我们本次实验中仅仅只针对这一项误报而做出的处理，所以getTypeArgument(0)就能够定位到 Long<br>添加上isSanitizer 的重写之后，我们再看结果，发现确实解决刚才的误报问题了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714439620614-d68790c5-8f25-4525-b479-704af1db2ee7.png#averageHue=%23272432&clientId=u34ffbe8d-3e30-4&from=paste&height=242&id=ud1f9ad3d&originHeight=454&originWidth=1294&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=121546&status=done&style=none&taskId=u0b49023d-edaf-493a-81b6-bc0cc59f7e9&title=&width=690.1333333333333" referrerpolicy="no-referrer" alt="image.png"></E></Long></p>
<h2 id="0x02-漏报"><a href="#0x02-漏报" class="headerlink" title="0x02 漏报"></a>0x02 漏报</h2><p>误报的问题能够从结果中自己检索出来，但是如果出现漏报问题就很难受了，我们其实是看不出来的，只能说是事后复盘解决（在有正确思路的情况下）。可以先看看这个漏报的点在哪<br>IndexController 下的<code>/optinal_like</code>路由<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714440137427-6820aa37-76fb-4b9f-abe8-b244af9ac3e3.png#averageHue=%23333430&clientId=u34ffbe8d-3e30-4&from=paste&height=120&id=u1aaef4b7&originHeight=225&originWidth=1860&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=123398&status=done&style=none&taskId=u98a0a565-1d1a-47ca-83d5-211db306db5&title=&width=992" referrerpolicy="no-referrer" alt="image.png"><br>我们跟进它的getStudentWithOptional 方法<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714440184433-76c8503a-9482-4e1b-a428-41d9080257fc.png#averageHue=%23373831&clientId=u34ffbe8d-3e30-4&from=paste&height=146&id=u6886fc95&originHeight=274&originWidth=1802&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=147674&status=done&style=none&taskId=u8a46fbde-1c31-48dc-834d-7ceae0be7e3&title=&width=961.0666666666667" referrerpolicy="no-referrer" alt="image.png"><br>对比我们 select 出来的结果，发现是没有这条 sink 的，具体流程其实是到了定义 sqlWithOptional 的时候，我们传参进来的是 username，此时会调用 username 的 get 方法，可能是 Codeql 的引擎并没有识别到 Option 类型，所以无法调用 useraname 的 get 方法，于是这条攻击链就断了<br>下面的解决方案可能不适合所有漏报的情形，因为仅仅只是针对这一个漏报进行的修复<br>在 codeql 中我们采用 isAdditionalTaintStep  方法来强制将两节点连接，从而使攻击链能够走下去<br>我们首先看如何定位到当前 node，也就是我们调用 get 方法，以及 username 传进来的这个节点<br>根据文章中的谓词使用，浅写一个测试代码，帮助我们了解这个<code>isTaintedString</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>dataflow<span class="token punctuation">.</span></span><span class="token class-name">FlowSources</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">QueryInjection</span>
<span class="token keyword">import</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathGraph</span>


predicate <span class="token function">isTaintedString</span><span class="token punctuation">(</span><span class="token class-name">Expr</span> expSrc<span class="token punctuation">,</span> <span class="token class-name">Expr</span> expDest<span class="token punctuation">,</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">MethodAccess</span> call<span class="token punctuation">,</span> <span class="token class-name">MethodAccess</span> call1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">exists</span><span class="token punctuation">(</span><span class="token operator">|</span> 
    expSrc <span class="token operator">=</span> call1<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
    and expDest<span class="token operator">=</span>call 
    and call<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> method 
    and method<span class="token punctuation">.</span><span class="token function">hasName</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span> 
    and method<span class="token punctuation">.</span><span class="token function">getDeclaringType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Optional&lt;String>"</span> 
    and call1<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Optional&lt;String>"</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

from <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> a<span class="token punctuation">,</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> b<span class="token punctuation">,</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span><span class="token class-name">MethodAccess</span> call<span class="token punctuation">,</span><span class="token class-name">MethodAccess</span> call1
where <span class="token function">isTaintedString</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">asExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">asExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>method<span class="token punctuation">,</span>call<span class="token punctuation">,</span>call1<span class="token punctuation">)</span>
select a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>method<span class="token punctuation">,</span>call<span class="token punctuation">,</span>call1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果如下<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714467884124-cdf4c859-c018-4f94-9ae4-fc110213cfac.png#averageHue=%23272435&clientId=u8d506303-14ab-4&from=paste&height=433&id=u5356d448&originHeight=812&originWidth=2011&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=347345&status=done&style=none&taskId=ua16679a8-a749-425e-9370-2b339e68eff&title=&width=1072.5333333333333" referrerpolicy="no-referrer" alt="image.png"><br>首先我们要明白当前的<code>isTaintedString</code>谓词是为了判断我们是否定位到了 <code>username</code> 和 <code>username.get</code>这两个点，如果定位成功，<code>isAdditionalTaintStep</code>后续会将这两个节点拼接，当前这条攻击链就能够顺利进行，我们最终检索出的 sql 注入点就不会缺少这一条可能了<br><code>expSrc = call1.getArgument(0)</code>   <code>expDest=call</code>,expsrc 和 expDest 两者就是username 和username.get，后续的描述条件说白了就是：我们尽可能的将当前的情形描述详细，能够准确定位到当前的情况<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714470449676-3dc70073-27e5-4950-8a88-5d8601d258a8.png#averageHue=%2335352f&clientId=u8d506303-14ab-4&from=paste&height=153&id=W58vX&originHeight=286&originWidth=1719&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=146987&status=done&style=none&taskId=u73140437-2eba-445b-b8d8-9baecbd113d&title=&width=916.8" referrerpolicy="no-referrer" alt="image.png"></p>
<ol>
<li><code>call.getMethod() = method</code>与<code>method.hasName(&quot;get&quot;)</code>两种条件描述都是为了定位到 <code>username.get</code>而服务的，两者交换顺序也是没问题的，就像一条工作流，我们为了得到其中的某种物质，漏斗的顺序放置是对结果没有区别的</li>
<li><code>call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;</code>定位到<code>getStudentWithOptional(Optional&lt;String&gt; username)</code>而服务</li>
<li><code>method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot;</code>定位 get</li>
</ol>
<p>虽说这么做了之后确实能够定位到这一个漏报的 SQL 注入点，但其实遇到其他情况的漏报就有点不够用了，或许有更好的方法也说不定（？</p>
<h2 id="0x03-Lombok-问题"><a href="#0x03-Lombok-问题" class="headerlink" title="0x03 Lombok 问题"></a>0x03 Lombok 问题</h2><p>Lombok 是一个用来帮助写类定义的插件，我们可以通过注解来完成 get set 方法以及构造方法的书写<br>那么这里就会出现一个问题，如果我们所审计的项目中使用了 Lombok，codeql 是无法识别出这些类的 setget 方法的<br>在 Codeql 的官方 issue 中是有提到这个问题的，解决方案如下</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># get a copy of lombok.jar</span>
wget https:<span class="token operator">/</span><span class="token operator">/</span>projectlombok<span class="token punctuation">.</span>org/downloads/lombok<span class="token punctuation">.</span>jar <span class="token operator">-</span>O <span class="token string">"lombok.jar"</span>
<span class="token comment"># run "delombok" on the source files and write the generated files to a folder named "delombok"</span>
java <span class="token operator">-</span>jar <span class="token string">"lombok.jar"</span> delombok <span class="token operator">-</span>n <span class="token operator">--</span>onlyChanged <span class="token punctuation">.</span> <span class="token operator">-</span>d <span class="token string">"delombok"</span>
<span class="token comment"># remove "generated by" comments</span>
find <span class="token string">"delombok"</span> <span class="token operator">-</span>name <span class="token string">'*.java'</span> <span class="token operator">-</span>exec sed <span class="token string">'/Generated by delombok/d'</span> <span class="token operator">-</span>i <span class="token string">'&#123;&#125;'</span> <span class="token string">';'</span>
<span class="token comment"># remove any left-over import statements</span>
find <span class="token string">"delombok"</span> <span class="token operator">-</span>name <span class="token string">'*.java'</span> <span class="token operator">-</span>exec sed <span class="token string">'/import lombok/d'</span> <span class="token operator">-</span>i <span class="token string">'&#123;&#125;'</span> <span class="token string">';'</span>
<span class="token comment"># copy delombok'd files over the original ones</span>
<span class="token function">cp</span> <span class="token operator">-</span>r <span class="token string">"delombok/."</span> <span class="token string">"./"</span>
<span class="token comment"># remove the "delombok" folder</span>
<span class="token function">rm</span> <span class="token operator">-</span>rf <span class="token string">"delombok"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大概的操作就是通过去掉代码里面的 lombok 注释，并且还原 setter 和 getter 方法，这样就和正常的类效果是一样的了</p>
<p>所以最终我们关于这个项目的 SQL 注入查找的 codeql 代码写为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>dataflow<span class="token punctuation">.</span></span><span class="token class-name">FlowSources</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">QueryInjection</span>
<span class="token keyword">import</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathGraph</span>


predicate <span class="token function">isTaintedString</span><span class="token punctuation">(</span><span class="token class-name">Expr</span> expSrc<span class="token punctuation">,</span> <span class="token class-name">Expr</span> expDest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">exists</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">MethodAccess</span> call<span class="token punctuation">,</span> <span class="token class-name">MethodAccess</span> call1 <span class="token operator">|</span> 
    expSrc <span class="token operator">=</span> call1<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
    and expDest<span class="token operator">=</span>call 
    and call<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> method 
    and method<span class="token punctuation">.</span><span class="token function">hasName</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span> 
    and method<span class="token punctuation">.</span><span class="token function">getDeclaringType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Optional&lt;String>"</span> 
    and call1<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Optional&lt;String>"</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">VulConfig</span> <span class="token keyword">extends</span> <span class="token class-name">TaintTracking</span><span class="token operator">::</span><span class="token class-name">Configuration</span> <span class="token punctuation">&#123;</span>
     <span class="token class-name">VulConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token string">"SqlInjectionConfig"</span> <span class="token punctuation">&#125;</span>
   
     override predicate <span class="token function">isSource</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> src<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> src <span class="token keyword">instanceof</span> <span class="token class-name">RemoteFlowSource</span> <span class="token punctuation">&#125;</span>
   
     override predicate <span class="token function">isSink</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> sink<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token function">exists</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">MethodAccess</span> call <span class="token operator">|</span>
        
         method<span class="token punctuation">.</span><span class="token function">hasName</span><span class="token punctuation">(</span><span class="token string">"query"</span><span class="token punctuation">)</span>
         and
         call<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> method
         and
         sink<span class="token punctuation">.</span><span class="token function">asExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> call<span class="token punctuation">.</span><span class="token function">getArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token punctuation">)</span>
     <span class="token punctuation">&#125;</span>
     override predicate <span class="token function">isSanitizer</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">PrimitiveType</span> or
      node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">BoxedType</span> or
      node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">NumberType</span> or
      <span class="token function">exists</span><span class="token punctuation">(</span><span class="token class-name">ParameterizedType</span> pt<span class="token operator">|</span> node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> pt and pt<span class="token punctuation">.</span><span class="token function">getTypeArgument</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">NumberType</span> <span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    override predicate <span class="token function">isAdditionalTaintStep</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> node1<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> node2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">isTaintedString</span><span class="token punctuation">(</span>node1<span class="token punctuation">.</span><span class="token function">asExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node2<span class="token punctuation">.</span><span class="token function">asExpr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>

from <span class="token class-name">VulConfig</span> config<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> source<span class="token punctuation">,</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathNode</span> sink
where config<span class="token punctuation">.</span><span class="token function">hasFlowPath</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>
select source<span class="token punctuation">.</span><span class="token function">getNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">,</span> <span class="token string">"source"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="持续工程化"><a href="#持续工程化" class="headerlink" title="持续工程化"></a>持续工程化</h1><p>经过分析测试过后，我们得到了一份关于常规 Springboot 项目的能够进行 SQL 注入检测的 codeql 代码，现在要考虑如何才能将这份代码用于实践<br>两行命令，按照我们之前所有的步骤来总结就两步：</p>
<ol>
<li><p>生成中间数据库</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">codeql database create <span class="token operator">~</span><span class="token operator">/</span><span class="token class-name">CodeQL</span><span class="token operator">/</span>databases<span class="token operator">/</span>micro<span class="token operator">-</span>service<span class="token operator">-</span>seclab  <span class="token operator">--</span>language<span class="token operator">=</span><span class="token string">"java"</span>  <span class="token operator">--</span>command<span class="token operator">=</span><span class="token string">"mvn clean install --file pom.xml -Dmaven.test.skip=true"</span> <span class="token operator">--</span>source<span class="token operator">-</span>root<span class="token operator">=</span><span class="token string">"~/Code/micro-service-seclab/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>运行 codeql 代码,这里是执行刚才写好的 codeql 代码，然后将结果输出到 csv 文件</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">codeql database analyze <span class="token operator">/</span><span class="token class-name">CodeQL</span><span class="token operator">/</span>databases<span class="token operator">/</span>micro<span class="token operator">-</span>service<span class="token operator">-</span>seclab <span class="token operator">/</span><span class="token class-name">CodeQL</span><span class="token operator">/</span>ql<span class="token operator">/</span>java<span class="token operator">/</span>ql<span class="token operator">/</span>examples<span class="token operator">/</span>demo <span class="token operator">--</span>format<span class="token operator">=</span>csv <span class="token operator">--</span>output<span class="token operator">=</span><span class="token operator">/</span><span class="token class-name">CodeQL</span><span class="token operator">/</span><span class="token class-name">Result</span><span class="token operator">/</span>micro<span class="token operator">-</span>service<span class="token operator">-</span>seclab<span class="token punctuation">.</span>csv <span class="token operator">--</span>rerun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h1 id="Codeql-语法查漏补缺"><a href="#Codeql-语法查漏补缺" class="headerlink" title="Codeql 语法查漏补缺"></a>Codeql 语法查漏补缺</h1><p>其实刚才一路跟过来，我为了弄懂一些语法而写了很多测试代码，期间也跟进过源码进行一些方法的查看，给我的感受就是大部分的语法我都很陌生，所以这里单独开一个用来记录的篇章，主要是为了记录一些初见不是很能理解的语法</p>
<h2 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h2><p>java 里面其实也见到过，只不过在 Codeql 的源码中我们能够经常看到，并且在指定扫描 source 时用的特别多<br>就拿我们本次的 isSource 判定来说</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">override predicate <span class="token function">isSource</span><span class="token punctuation">(</span><span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">Node</span> src<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> src <span class="token keyword">instanceof</span> <span class="token class-name">RemoteFlowSource</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们并没有写很多的 exist 子查询来判定 source，只是通过判定节点 src 是否 instance RemoteFlowSource 就完成了 source 的检索工作，可以想象RemoteFlowSource 里面应该集成了很多类型的 source 用作判定<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714633520438-8e90e5fc-f3bf-4c72-bbf6-a74de0dc8373.png#averageHue=%23262335&clientId=u8b8ef068-c78d-4&from=paste&height=597&id=u5eeb2144&originHeight=1120&originWidth=1278&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=416076&status=done&style=none&taskId=u1eb5c5cf-7672-4279-b2c0-fc8329edfb0&title=&width=681.6" referrerpolicy="no-referrer" alt="image.png"><br>可以看到 ReomteSource 的定义中有许多的子类扩展，这里和 java 的语法还有点不太一样，ReomteSource 是一个 abstract 的抽象类定义，而 java 中的抽象类必须要有实现类和对应的实现方法才能够使用功能，这里我们使用ReomteSource 时没有具体的指定要实现它的某些方法，但是我们依然能够用到它的功能。原因就在于 Codeql 中的抽象类，只要我们选择继承，并且在某处有调用的话，所有的子类都会被调用一遍，也就是说，这里所有的 RemoteSource 的子类都会在我们 <code>src instanceof RemoteSource</code> 的时候被调用，那其实大部分的常见入口点 source 都会被检测一遍了</p>
<h2 id="子类递归问题"><a href="#子类递归问题" class="headerlink" title="子类递归问题"></a>子类递归问题</h2><p>面向对象的一个常见问题，当我们的一个类中出现了子类的定义时，需要一些特殊的处理才能够准确区分和识别到子类与父类<br>比如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentService</span> <span class="token punctuation">&#123;</span>
 
    <span class="token keyword">class</span> innerOne <span class="token punctuation">&#123;</span>
        <span class="token keyword">public</span> <span class="token function">innerOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
 
        <span class="token keyword">class</span> innerTwo <span class="token punctuation">&#123;</span>
            <span class="token keyword">public</span> <span class="token function">innerTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
 
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token class-name">Nihao</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token string">"Nihao"</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token class-name">Hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们定义了三个类：StudentService，innerOne，innerTwo<br>如何通过 innerTwo 定位到最外层的 StudentService 呢？</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">from <span class="token class-name">Class</span> classes
where classes<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"innerTwo"</span>
select classes<span class="token punctuation">.</span><span class="token function">getEnclosingType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEnclosingType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里我们先从所有的 class 定义中获取到 innerTwo 的定义，然后通过<code>getEnclosingType()</code>来获取其上一级的封闭类定义，跟 java 中的<code>getEnclosingType()</code>简直不要太一样<br>实际情况下，我们肯定不知道目标类到底有多少层封闭类的定义，所以这么做只存在于我们知道目标类具体结构的情况下才能使用的<br>还有一种方法能够自动递归来获取其封闭类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>dataflow<span class="token punctuation">.</span></span><span class="token class-name">FlowSources</span>
<span class="token keyword">import</span> <span class="token namespace">semmle<span class="token punctuation">.</span>code<span class="token punctuation">.</span>java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">QueryInjection</span>
<span class="token keyword">import</span> <span class="token class-name">DataFlow</span><span class="token operator">::</span><span class="token class-name">PathGraph</span>


from <span class="token class-name">Class</span> classes
where classes<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"innerTwo"</span>
select classes<span class="token punctuation">.</span>getEnclosingType<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714635122775-ad0c61bb-8e5a-4eb9-99bf-e53729374ece.png#averageHue=%23232526&clientId=u8b8ef068-c78d-4&from=paste&height=286&id=u4137e1f0&originHeight=537&originWidth=1915&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=225675&status=done&style=none&taskId=u052819d0-89c6-474e-abb8-bca3ce6234a&title=&width=1021.3333333333334" referrerpolicy="no-referrer" alt="image.png"><br>或者我们可以将+改写为*，都是可以的<br><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714635164139-d34daa96-48df-4bad-b4ba-27ac4c96182a.png#averageHue=%23232425&clientId=u8b8ef068-c78d-4&from=paste&height=289&id=u6337d615&originHeight=542&originWidth=1972&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=211620&status=done&style=none&taskId=ucd098b10-2c5f-498c-a511-0b8df4651c0&title=&width=1051.7333333333333" referrerpolicy="no-referrer" alt="image.png"></p>
<h2 id="类型筛选"><a href="#类型筛选" class="headerlink" title="类型筛选"></a>类型筛选</h2><p>如何筛选出我们想要的类型参数也是一个大问题，通常我们首先会通过如下的代码获取到当前项目中所有的调用参数</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">from <span class="token class-name">Parameter</span> param
select param<span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714636020782-d58b23b5-3b7e-48ed-a070-52b0636b5874.png#averageHue=%23262727&clientId=u8b8ef068-c78d-4&from=paste&height=706&id=uee412917&originHeight=1323&originWidth=1939&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=459091&status=done&style=none&taskId=uce71af7a-716f-423d-88fe-9aad6b76b87&title=&width=1034.1333333333334" referrerpolicy="no-referrer" alt="image.png"><br>然后我们可以用(RefType)来进行过滤</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">from <span class="token class-name">Parameter</span> param
select param<span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token class-name">RefType</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里的 RefType 代表的是什么呢？它相当于一层 filter，将所有的 6种数字类型（byte&#x2F;short&#x2F;int&#x2F;long&#x2F;float&#x2F;double）、1种字符型（char）、1种布尔型（boolean）  过滤了一遍，再将结果输出出来<br>我们还可以指定过滤一些特定的类型,这里就是指定筛选出所有的 int 类型</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">from <span class="token class-name">Parameter</span> param
select param<span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token class-name">IntegralType</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/36078896/1714636425505-f67602ee-7fbc-4acf-aa9e-672015978edc.png#averageHue=%23262828&clientId=u8b8ef068-c78d-4&from=paste&height=688&id=u8c98b5a3&originHeight=1290&originWidth=1970&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=394516&status=done&style=none&taskId=u9b4ea65d-d467-4615-9df6-ec67c7eb5c2&title=&width=1050.6666666666667" referrerpolicy="no-referrer" alt="image.png"></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/post/Apache%20DolphinScheduler%20%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2024-05-02 16:40:28
            </span>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/post/Java%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CodeQL"><span class="toc-text">什么是 CodeQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CodeQL-%E9%85%8D%E7%BD%AE"><span class="toc-text">CodeQL 配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CodeQL-%E4%BD%BF%E7%94%A8"><span class="toc-text">CodeQL 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E6%B5%8B%E8%AF%95-Helloworld"><span class="toc-text">0x01 测试 Helloworld</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-CodeQL-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">0x02 CodeQL 基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E7%B1%BB%E5%BA%93"><span class="toc-text">0x03 类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E8%B0%93%E8%AF%8D%E4%BD%BF%E7%94%A8"><span class="toc-text">0x04 谓词使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-Node%EF%BC%8CExpr%EF%BC%8CParam"><span class="toc-text">0x05 Node，Expr，Param</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-source-%EF%BC%8Csink%EF%BC%8C-sanitizer"><span class="toc-text">0x06 source ，sink， sanitizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1x01-%E8%AE%BE%E7%BD%AE-source"><span class="toc-text">1x01 设置 source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1x02-%E8%AE%BE%E7%BD%AE-sink"><span class="toc-text">1x02 设置 sink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1x03-Flow-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">1x03 Flow 数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1x04-%E6%95%B4%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-text">1x04 整体查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E4%BC%98%E5%8C%96"><span class="toc-text">结果优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E8%AF%AF%E6%8A%A5"><span class="toc-text">0x01 误报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E6%BC%8F%E6%8A%A5"><span class="toc-text">0x02 漏报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-Lombok-%E9%97%AE%E9%A2%98"><span class="toc-text">0x03 Lombok 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">持续工程化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Codeql-%E8%AF%AD%E6%B3%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA"><span class="toc-text">Codeql 语法查漏补缺</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Instanceof"><span class="toc-text">Instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-text">子类递归问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%AD%9B%E9%80%89"><span class="toc-text">类型筛选</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2024 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + CodeQL%E5%AD%A6%E4%B9%A0 + '&url=' + http%3A%2F%2Fexample.com%2Fpost%2FCodeQL%25E5%25AD%25A6%25E4%25B9%25A0.html + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/post/CodeQL%E5%AD%A6%E4%B9%A0.html" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
